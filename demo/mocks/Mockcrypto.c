/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "Mockcrypto.h"

static const char* CMockString_ad_length = "ad_length";
static const char* CMockString_additional_data = "additional_data";
static const char* CMockString_additional_data_length = "additional_data_length";
static const char* CMockString_alg = "alg";
static const char* CMockString_attributes = "attributes";
static const char* CMockString_bits = "bits";
static const char* CMockString_capacity = "capacity";
static const char* CMockString_ciphertext = "ciphertext";
static const char* CMockString_ciphertext_length = "ciphertext_length";
static const char* CMockString_ciphertext_size = "ciphertext_size";
static const char* CMockString_data = "data";
static const char* CMockString_data_length = "data_length";
static const char* CMockString_data_size = "data_size";
static const char* CMockString_expected = "expected";
static const char* CMockString_expected_output = "expected_output";
static const char* CMockString_hash = "hash";
static const char* CMockString_hash_length = "hash_length";
static const char* CMockString_hash_size = "hash_size";
static const char* CMockString_input = "input";
static const char* CMockString_input_length = "input_length";
static const char* CMockString_iv = "iv";
static const char* CMockString_iv_length = "iv_length";
static const char* CMockString_iv_size = "iv_size";
static const char* CMockString_key = "key";
static const char* CMockString_lifetime = "lifetime";
static const char* CMockString_mac = "mac";
static const char* CMockString_mac_length = "mac_length";
static const char* CMockString_mac_size = "mac_size";
static const char* CMockString_nonce = "nonce";
static const char* CMockString_nonce_length = "nonce_length";
static const char* CMockString_nonce_size = "nonce_size";
static const char* CMockString_operation = "operation";
static const char* CMockString_output = "output";
static const char* CMockString_output_length = "output_length";
static const char* CMockString_output_size = "output_size";
static const char* CMockString_peer_key = "peer_key";
static const char* CMockString_peer_key_length = "peer_key_length";
static const char* CMockString_plaintext = "plaintext";
static const char* CMockString_plaintext_length = "plaintext_length";
static const char* CMockString_plaintext_size = "plaintext_size";
static const char* CMockString_private_key = "private_key";
static const char* CMockString_psa_aead_abort = "psa_aead_abort";
static const char* CMockString_psa_aead_decrypt = "psa_aead_decrypt";
static const char* CMockString_psa_aead_decrypt_setup = "psa_aead_decrypt_setup";
static const char* CMockString_psa_aead_encrypt = "psa_aead_encrypt";
static const char* CMockString_psa_aead_encrypt_setup = "psa_aead_encrypt_setup";
static const char* CMockString_psa_aead_finish = "psa_aead_finish";
static const char* CMockString_psa_aead_generate_nonce = "psa_aead_generate_nonce";
static const char* CMockString_psa_aead_operation_init = "psa_aead_operation_init";
static const char* CMockString_psa_aead_set_lengths = "psa_aead_set_lengths";
static const char* CMockString_psa_aead_set_nonce = "psa_aead_set_nonce";
static const char* CMockString_psa_aead_update = "psa_aead_update";
static const char* CMockString_psa_aead_update_ad = "psa_aead_update_ad";
static const char* CMockString_psa_aead_verify = "psa_aead_verify";
static const char* CMockString_psa_asymmetric_decrypt = "psa_asymmetric_decrypt";
static const char* CMockString_psa_asymmetric_encrypt = "psa_asymmetric_encrypt";
static const char* CMockString_psa_cipher_abort = "psa_cipher_abort";
static const char* CMockString_psa_cipher_decrypt = "psa_cipher_decrypt";
static const char* CMockString_psa_cipher_decrypt_setup = "psa_cipher_decrypt_setup";
static const char* CMockString_psa_cipher_encrypt = "psa_cipher_encrypt";
static const char* CMockString_psa_cipher_encrypt_setup = "psa_cipher_encrypt_setup";
static const char* CMockString_psa_cipher_finish = "psa_cipher_finish";
static const char* CMockString_psa_cipher_generate_iv = "psa_cipher_generate_iv";
static const char* CMockString_psa_cipher_operation_init = "psa_cipher_operation_init";
static const char* CMockString_psa_cipher_set_iv = "psa_cipher_set_iv";
static const char* CMockString_psa_cipher_update = "psa_cipher_update";
static const char* CMockString_psa_copy_key = "psa_copy_key";
static const char* CMockString_psa_crypto_init = "psa_crypto_init";
static const char* CMockString_psa_destroy_key = "psa_destroy_key";
static const char* CMockString_psa_export_key = "psa_export_key";
static const char* CMockString_psa_export_public_key = "psa_export_public_key";
static const char* CMockString_psa_generate_key = "psa_generate_key";
static const char* CMockString_psa_generate_random = "psa_generate_random";
static const char* CMockString_psa_get_key_algorithm = "psa_get_key_algorithm";
static const char* CMockString_psa_get_key_attributes = "psa_get_key_attributes";
static const char* CMockString_psa_get_key_bits = "psa_get_key_bits";
static const char* CMockString_psa_get_key_id = "psa_get_key_id";
static const char* CMockString_psa_get_key_lifetime = "psa_get_key_lifetime";
static const char* CMockString_psa_get_key_type = "psa_get_key_type";
static const char* CMockString_psa_get_key_usage_flags = "psa_get_key_usage_flags";
static const char* CMockString_psa_hash_abort = "psa_hash_abort";
static const char* CMockString_psa_hash_clone = "psa_hash_clone";
static const char* CMockString_psa_hash_compare = "psa_hash_compare";
static const char* CMockString_psa_hash_compute = "psa_hash_compute";
static const char* CMockString_psa_hash_finish = "psa_hash_finish";
static const char* CMockString_psa_hash_operation_init = "psa_hash_operation_init";
static const char* CMockString_psa_hash_setup = "psa_hash_setup";
static const char* CMockString_psa_hash_update = "psa_hash_update";
static const char* CMockString_psa_hash_verify = "psa_hash_verify";
static const char* CMockString_psa_import_key = "psa_import_key";
static const char* CMockString_psa_key_attributes_init = "psa_key_attributes_init";
static const char* CMockString_psa_key_derivation_abort = "psa_key_derivation_abort";
static const char* CMockString_psa_key_derivation_get_capacity = "psa_key_derivation_get_capacity";
static const char* CMockString_psa_key_derivation_input_bytes = "psa_key_derivation_input_bytes";
static const char* CMockString_psa_key_derivation_input_integer = "psa_key_derivation_input_integer";
static const char* CMockString_psa_key_derivation_input_key = "psa_key_derivation_input_key";
static const char* CMockString_psa_key_derivation_key_agreement = "psa_key_derivation_key_agreement";
static const char* CMockString_psa_key_derivation_operation_init = "psa_key_derivation_operation_init";
static const char* CMockString_psa_key_derivation_output_bytes = "psa_key_derivation_output_bytes";
static const char* CMockString_psa_key_derivation_output_key = "psa_key_derivation_output_key";
static const char* CMockString_psa_key_derivation_set_capacity = "psa_key_derivation_set_capacity";
static const char* CMockString_psa_key_derivation_setup = "psa_key_derivation_setup";
static const char* CMockString_psa_key_derivation_verify_bytes = "psa_key_derivation_verify_bytes";
static const char* CMockString_psa_key_derivation_verify_key = "psa_key_derivation_verify_key";
static const char* CMockString_psa_mac_abort = "psa_mac_abort";
static const char* CMockString_psa_mac_compute = "psa_mac_compute";
static const char* CMockString_psa_mac_operation_init = "psa_mac_operation_init";
static const char* CMockString_psa_mac_sign_finish = "psa_mac_sign_finish";
static const char* CMockString_psa_mac_sign_setup = "psa_mac_sign_setup";
static const char* CMockString_psa_mac_update = "psa_mac_update";
static const char* CMockString_psa_mac_verify = "psa_mac_verify";
static const char* CMockString_psa_mac_verify_finish = "psa_mac_verify_finish";
static const char* CMockString_psa_mac_verify_setup = "psa_mac_verify_setup";
static const char* CMockString_psa_purge_key = "psa_purge_key";
static const char* CMockString_psa_raw_key_agreement = "psa_raw_key_agreement";
static const char* CMockString_psa_reset_key_attributes = "psa_reset_key_attributes";
static const char* CMockString_psa_set_key_algorithm = "psa_set_key_algorithm";
static const char* CMockString_psa_set_key_bits = "psa_set_key_bits";
static const char* CMockString_psa_set_key_id = "psa_set_key_id";
static const char* CMockString_psa_set_key_lifetime = "psa_set_key_lifetime";
static const char* CMockString_psa_set_key_type = "psa_set_key_type";
static const char* CMockString_psa_set_key_usage_flags = "psa_set_key_usage_flags";
static const char* CMockString_psa_sign_hash = "psa_sign_hash";
static const char* CMockString_psa_sign_message = "psa_sign_message";
static const char* CMockString_psa_verify_hash = "psa_verify_hash";
static const char* CMockString_psa_verify_message = "psa_verify_message";
static const char* CMockString_salt = "salt";
static const char* CMockString_salt_length = "salt_length";
static const char* CMockString_signature = "signature";
static const char* CMockString_signature_length = "signature_length";
static const char* CMockString_signature_size = "signature_size";
static const char* CMockString_source_key = "source_key";
static const char* CMockString_source_operation = "source_operation";
static const char* CMockString_step = "step";
static const char* CMockString_tag = "tag";
static const char* CMockString_tag_length = "tag_length";
static const char* CMockString_tag_size = "tag_size";
static const char* CMockString_target_key = "target_key";
static const char* CMockString_target_operation = "target_operation";
static const char* CMockString_type = "type";
static const char* CMockString_usage_flags = "usage_flags";
static const char* CMockString_value = "value";

typedef struct _CMOCK_psa_crypto_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;

} CMOCK_psa_crypto_init_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_attributes_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_attributes_t ReturnVal;

} CMOCK_psa_key_attributes_init_CALL_INSTANCE;

typedef struct _CMOCK_psa_set_key_id_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_attributes_t* Expected_attributes;
  psa_key_id_t Expected_key;

} CMOCK_psa_set_key_id_CALL_INSTANCE;

typedef struct _CMOCK_psa_set_key_lifetime_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_attributes_t* Expected_attributes;
  psa_key_lifetime_t Expected_lifetime;

} CMOCK_psa_set_key_lifetime_CALL_INSTANCE;

typedef struct _CMOCK_psa_get_key_id_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_id_t ReturnVal;
  const psa_key_attributes_t* Expected_attributes;

} CMOCK_psa_get_key_id_CALL_INSTANCE;

typedef struct _CMOCK_psa_get_key_lifetime_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_lifetime_t ReturnVal;
  const psa_key_attributes_t* Expected_attributes;

} CMOCK_psa_get_key_lifetime_CALL_INSTANCE;

typedef struct _CMOCK_psa_set_key_usage_flags_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_attributes_t* Expected_attributes;
  psa_key_usage_t Expected_usage_flags;

} CMOCK_psa_set_key_usage_flags_CALL_INSTANCE;

typedef struct _CMOCK_psa_get_key_usage_flags_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_usage_t ReturnVal;
  const psa_key_attributes_t* Expected_attributes;

} CMOCK_psa_get_key_usage_flags_CALL_INSTANCE;

typedef struct _CMOCK_psa_set_key_algorithm_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_attributes_t* Expected_attributes;
  psa_algorithm_t Expected_alg;

} CMOCK_psa_set_key_algorithm_CALL_INSTANCE;

typedef struct _CMOCK_psa_get_key_algorithm_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_algorithm_t ReturnVal;
  const psa_key_attributes_t* Expected_attributes;

} CMOCK_psa_get_key_algorithm_CALL_INSTANCE;

typedef struct _CMOCK_psa_set_key_type_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_attributes_t* Expected_attributes;
  psa_key_type_t Expected_type;

} CMOCK_psa_set_key_type_CALL_INSTANCE;

typedef struct _CMOCK_psa_set_key_bits_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_attributes_t* Expected_attributes;
  size_t Expected_bits;

} CMOCK_psa_set_key_bits_CALL_INSTANCE;

typedef struct _CMOCK_psa_get_key_type_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_type_t ReturnVal;
  const psa_key_attributes_t* Expected_attributes;

} CMOCK_psa_get_key_type_CALL_INSTANCE;

typedef struct _CMOCK_psa_get_key_bits_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  size_t ReturnVal;
  const psa_key_attributes_t* Expected_attributes;

} CMOCK_psa_get_key_bits_CALL_INSTANCE;

typedef struct _CMOCK_psa_get_key_attributes_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_key_attributes_t* Expected_attributes;

} CMOCK_psa_get_key_attributes_CALL_INSTANCE;

typedef struct _CMOCK_psa_reset_key_attributes_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_attributes_t* Expected_attributes;

} CMOCK_psa_reset_key_attributes_CALL_INSTANCE;

typedef struct _CMOCK_psa_purge_key_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;

} CMOCK_psa_purge_key_CALL_INSTANCE;

typedef struct _CMOCK_psa_copy_key_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_source_key;
  const psa_key_attributes_t* Expected_attributes;
  psa_key_id_t* Expected_target_key;

} CMOCK_psa_copy_key_CALL_INSTANCE;

typedef struct _CMOCK_psa_destroy_key_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;

} CMOCK_psa_destroy_key_CALL_INSTANCE;

typedef struct _CMOCK_psa_import_key_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  const psa_key_attributes_t* Expected_attributes;
  const uint8_t* Expected_data;
  size_t Expected_data_length;
  psa_key_id_t* Expected_key;

} CMOCK_psa_import_key_CALL_INSTANCE;

typedef struct _CMOCK_psa_export_key_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  uint8_t* Expected_data;
  size_t Expected_data_size;
  size_t* Expected_data_length;

} CMOCK_psa_export_key_CALL_INSTANCE;

typedef struct _CMOCK_psa_export_public_key_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  uint8_t* Expected_data;
  size_t Expected_data_size;
  size_t* Expected_data_length;

} CMOCK_psa_export_public_key_CALL_INSTANCE;

typedef struct _CMOCK_psa_hash_compute_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_input;
  size_t Expected_input_length;
  uint8_t* Expected_hash;
  size_t Expected_hash_size;
  size_t* Expected_hash_length;

} CMOCK_psa_hash_compute_CALL_INSTANCE;

typedef struct _CMOCK_psa_hash_compare_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_input;
  size_t Expected_input_length;
  const uint8_t* Expected_hash;
  size_t Expected_hash_length;

} CMOCK_psa_hash_compare_CALL_INSTANCE;

typedef struct _CMOCK_psa_hash_operation_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_hash_operation_t ReturnVal;

} CMOCK_psa_hash_operation_init_CALL_INSTANCE;

typedef struct _CMOCK_psa_hash_setup_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_hash_operation_t* Expected_operation;
  psa_algorithm_t Expected_alg;

} CMOCK_psa_hash_setup_CALL_INSTANCE;

typedef struct _CMOCK_psa_hash_update_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_hash_operation_t* Expected_operation;
  const uint8_t* Expected_input;
  size_t Expected_input_length;

} CMOCK_psa_hash_update_CALL_INSTANCE;

typedef struct _CMOCK_psa_hash_finish_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_hash_operation_t* Expected_operation;
  uint8_t* Expected_hash;
  size_t Expected_hash_size;
  size_t* Expected_hash_length;

} CMOCK_psa_hash_finish_CALL_INSTANCE;

typedef struct _CMOCK_psa_hash_verify_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_hash_operation_t* Expected_operation;
  const uint8_t* Expected_hash;
  size_t Expected_hash_length;

} CMOCK_psa_hash_verify_CALL_INSTANCE;

typedef struct _CMOCK_psa_hash_abort_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_hash_operation_t* Expected_operation;

} CMOCK_psa_hash_abort_CALL_INSTANCE;

typedef struct _CMOCK_psa_hash_clone_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  const psa_hash_operation_t* Expected_source_operation;
  psa_hash_operation_t* Expected_target_operation;

} CMOCK_psa_hash_clone_CALL_INSTANCE;

typedef struct _CMOCK_psa_mac_compute_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_input;
  size_t Expected_input_length;
  uint8_t* Expected_mac;
  size_t Expected_mac_size;
  size_t* Expected_mac_length;

} CMOCK_psa_mac_compute_CALL_INSTANCE;

typedef struct _CMOCK_psa_mac_verify_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_input;
  size_t Expected_input_length;
  const uint8_t* Expected_mac;
  size_t Expected_mac_length;

} CMOCK_psa_mac_verify_CALL_INSTANCE;

typedef struct _CMOCK_psa_mac_operation_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_mac_operation_t ReturnVal;

} CMOCK_psa_mac_operation_init_CALL_INSTANCE;

typedef struct _CMOCK_psa_mac_sign_setup_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_mac_operation_t* Expected_operation;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;

} CMOCK_psa_mac_sign_setup_CALL_INSTANCE;

typedef struct _CMOCK_psa_mac_verify_setup_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_mac_operation_t* Expected_operation;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;

} CMOCK_psa_mac_verify_setup_CALL_INSTANCE;

typedef struct _CMOCK_psa_mac_update_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_mac_operation_t* Expected_operation;
  const uint8_t* Expected_input;
  size_t Expected_input_length;

} CMOCK_psa_mac_update_CALL_INSTANCE;

typedef struct _CMOCK_psa_mac_sign_finish_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_mac_operation_t* Expected_operation;
  uint8_t* Expected_mac;
  size_t Expected_mac_size;
  size_t* Expected_mac_length;

} CMOCK_psa_mac_sign_finish_CALL_INSTANCE;

typedef struct _CMOCK_psa_mac_verify_finish_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_mac_operation_t* Expected_operation;
  const uint8_t* Expected_mac;
  size_t Expected_mac_length;

} CMOCK_psa_mac_verify_finish_CALL_INSTANCE;

typedef struct _CMOCK_psa_mac_abort_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_mac_operation_t* Expected_operation;

} CMOCK_psa_mac_abort_CALL_INSTANCE;

typedef struct _CMOCK_psa_cipher_encrypt_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_input;
  size_t Expected_input_length;
  uint8_t* Expected_output;
  size_t Expected_output_size;
  size_t* Expected_output_length;

} CMOCK_psa_cipher_encrypt_CALL_INSTANCE;

typedef struct _CMOCK_psa_cipher_decrypt_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_input;
  size_t Expected_input_length;
  uint8_t* Expected_output;
  size_t Expected_output_size;
  size_t* Expected_output_length;

} CMOCK_psa_cipher_decrypt_CALL_INSTANCE;

typedef struct _CMOCK_psa_cipher_operation_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_cipher_operation_t ReturnVal;

} CMOCK_psa_cipher_operation_init_CALL_INSTANCE;

typedef struct _CMOCK_psa_cipher_encrypt_setup_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_cipher_operation_t* Expected_operation;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;

} CMOCK_psa_cipher_encrypt_setup_CALL_INSTANCE;

typedef struct _CMOCK_psa_cipher_decrypt_setup_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_cipher_operation_t* Expected_operation;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;

} CMOCK_psa_cipher_decrypt_setup_CALL_INSTANCE;

typedef struct _CMOCK_psa_cipher_generate_iv_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_cipher_operation_t* Expected_operation;
  uint8_t* Expected_iv;
  size_t Expected_iv_size;
  size_t* Expected_iv_length;

} CMOCK_psa_cipher_generate_iv_CALL_INSTANCE;

typedef struct _CMOCK_psa_cipher_set_iv_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_cipher_operation_t* Expected_operation;
  const uint8_t* Expected_iv;
  size_t Expected_iv_length;

} CMOCK_psa_cipher_set_iv_CALL_INSTANCE;

typedef struct _CMOCK_psa_cipher_update_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_cipher_operation_t* Expected_operation;
  const uint8_t* Expected_input;
  size_t Expected_input_length;
  uint8_t* Expected_output;
  size_t Expected_output_size;
  size_t* Expected_output_length;

} CMOCK_psa_cipher_update_CALL_INSTANCE;

typedef struct _CMOCK_psa_cipher_finish_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_cipher_operation_t* Expected_operation;
  uint8_t* Expected_output;
  size_t Expected_output_size;
  size_t* Expected_output_length;

} CMOCK_psa_cipher_finish_CALL_INSTANCE;

typedef struct _CMOCK_psa_cipher_abort_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_cipher_operation_t* Expected_operation;

} CMOCK_psa_cipher_abort_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_encrypt_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_nonce;
  size_t Expected_nonce_length;
  const uint8_t* Expected_additional_data;
  size_t Expected_additional_data_length;
  const uint8_t* Expected_plaintext;
  size_t Expected_plaintext_length;
  uint8_t* Expected_ciphertext;
  size_t Expected_ciphertext_size;
  size_t* Expected_ciphertext_length;

} CMOCK_psa_aead_encrypt_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_decrypt_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_nonce;
  size_t Expected_nonce_length;
  const uint8_t* Expected_additional_data;
  size_t Expected_additional_data_length;
  const uint8_t* Expected_ciphertext;
  size_t Expected_ciphertext_length;
  uint8_t* Expected_plaintext;
  size_t Expected_plaintext_size;
  size_t* Expected_plaintext_length;

} CMOCK_psa_aead_decrypt_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_operation_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_aead_operation_t ReturnVal;

} CMOCK_psa_aead_operation_init_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_encrypt_setup_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_aead_operation_t* Expected_operation;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;

} CMOCK_psa_aead_encrypt_setup_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_decrypt_setup_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_aead_operation_t* Expected_operation;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;

} CMOCK_psa_aead_decrypt_setup_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_generate_nonce_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_aead_operation_t* Expected_operation;
  uint8_t* Expected_nonce;
  size_t Expected_nonce_size;
  size_t* Expected_nonce_length;

} CMOCK_psa_aead_generate_nonce_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_set_nonce_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_aead_operation_t* Expected_operation;
  const uint8_t* Expected_nonce;
  size_t Expected_nonce_length;

} CMOCK_psa_aead_set_nonce_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_set_lengths_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_aead_operation_t* Expected_operation;
  size_t Expected_ad_length;
  size_t Expected_plaintext_length;

} CMOCK_psa_aead_set_lengths_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_update_ad_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_aead_operation_t* Expected_operation;
  const uint8_t* Expected_input;
  size_t Expected_input_length;

} CMOCK_psa_aead_update_ad_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_update_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_aead_operation_t* Expected_operation;
  const uint8_t* Expected_input;
  size_t Expected_input_length;
  uint8_t* Expected_output;
  size_t Expected_output_size;
  size_t* Expected_output_length;

} CMOCK_psa_aead_update_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_finish_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_aead_operation_t* Expected_operation;
  uint8_t* Expected_ciphertext;
  size_t Expected_ciphertext_size;
  size_t* Expected_ciphertext_length;
  uint8_t* Expected_tag;
  size_t Expected_tag_size;
  size_t* Expected_tag_length;

} CMOCK_psa_aead_finish_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_verify_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_aead_operation_t* Expected_operation;
  uint8_t* Expected_plaintext;
  size_t Expected_plaintext_size;
  size_t* Expected_plaintext_length;
  const uint8_t* Expected_tag;
  size_t Expected_tag_length;

} CMOCK_psa_aead_verify_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_abort_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_aead_operation_t* Expected_operation;

} CMOCK_psa_aead_abort_CALL_INSTANCE;

typedef struct _CMOCK_psa_sign_message_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_input;
  size_t Expected_input_length;
  uint8_t* Expected_signature;
  size_t Expected_signature_size;
  size_t* Expected_signature_length;

} CMOCK_psa_sign_message_CALL_INSTANCE;

typedef struct _CMOCK_psa_verify_message_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_input;
  size_t Expected_input_length;
  const uint8_t* Expected_signature;
  size_t Expected_signature_length;

} CMOCK_psa_verify_message_CALL_INSTANCE;

typedef struct _CMOCK_psa_sign_hash_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_hash;
  size_t Expected_hash_length;
  uint8_t* Expected_signature;
  size_t Expected_signature_size;
  size_t* Expected_signature_length;

} CMOCK_psa_sign_hash_CALL_INSTANCE;

typedef struct _CMOCK_psa_verify_hash_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_hash;
  size_t Expected_hash_length;
  const uint8_t* Expected_signature;
  size_t Expected_signature_length;

} CMOCK_psa_verify_hash_CALL_INSTANCE;

typedef struct _CMOCK_psa_asymmetric_encrypt_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_input;
  size_t Expected_input_length;
  const uint8_t* Expected_salt;
  size_t Expected_salt_length;
  uint8_t* Expected_output;
  size_t Expected_output_size;
  size_t* Expected_output_length;

} CMOCK_psa_asymmetric_encrypt_CALL_INSTANCE;

typedef struct _CMOCK_psa_asymmetric_decrypt_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_input;
  size_t Expected_input_length;
  const uint8_t* Expected_salt;
  size_t Expected_salt_length;
  uint8_t* Expected_output;
  size_t Expected_output_size;
  size_t* Expected_output_length;

} CMOCK_psa_asymmetric_decrypt_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_operation_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_derivation_operation_t ReturnVal;

} CMOCK_psa_key_derivation_operation_init_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_setup_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_derivation_operation_t* Expected_operation;
  psa_algorithm_t Expected_alg;

} CMOCK_psa_key_derivation_setup_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_get_capacity_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  const psa_key_derivation_operation_t* Expected_operation;
  size_t* Expected_capacity;

} CMOCK_psa_key_derivation_get_capacity_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_set_capacity_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_derivation_operation_t* Expected_operation;
  size_t Expected_capacity;

} CMOCK_psa_key_derivation_set_capacity_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_input_bytes_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_derivation_operation_t* Expected_operation;
  psa_key_derivation_step_t Expected_step;
  const uint8_t* Expected_data;
  size_t Expected_data_length;

} CMOCK_psa_key_derivation_input_bytes_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_input_integer_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_derivation_operation_t* Expected_operation;
  psa_key_derivation_step_t Expected_step;
  uint64_t Expected_value;

} CMOCK_psa_key_derivation_input_integer_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_input_key_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_derivation_operation_t* Expected_operation;
  psa_key_derivation_step_t Expected_step;
  psa_key_id_t Expected_key;

} CMOCK_psa_key_derivation_input_key_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_key_agreement_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_derivation_operation_t* Expected_operation;
  psa_key_derivation_step_t Expected_step;
  psa_key_id_t Expected_private_key;
  const uint8_t* Expected_peer_key;
  size_t Expected_peer_key_length;

} CMOCK_psa_key_derivation_key_agreement_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_output_bytes_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_derivation_operation_t* Expected_operation;
  uint8_t* Expected_output;
  size_t Expected_output_length;

} CMOCK_psa_key_derivation_output_bytes_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_output_key_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  const psa_key_attributes_t* Expected_attributes;
  psa_key_derivation_operation_t* Expected_operation;
  psa_key_id_t* Expected_key;

} CMOCK_psa_key_derivation_output_key_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_verify_bytes_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_derivation_operation_t* Expected_operation;
  const uint8_t* Expected_expected_output;
  size_t Expected_output_length;

} CMOCK_psa_key_derivation_verify_bytes_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_verify_key_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_derivation_operation_t* Expected_operation;
  psa_key_id_t Expected_expected;

} CMOCK_psa_key_derivation_verify_key_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_abort_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_derivation_operation_t* Expected_operation;

} CMOCK_psa_key_derivation_abort_CALL_INSTANCE;

typedef struct _CMOCK_psa_raw_key_agreement_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_algorithm_t Expected_alg;
  psa_key_id_t Expected_private_key;
  const uint8_t* Expected_peer_key;
  size_t Expected_peer_key_length;
  uint8_t* Expected_output;
  size_t Expected_output_size;
  size_t* Expected_output_length;

} CMOCK_psa_raw_key_agreement_CALL_INSTANCE;

typedef struct _CMOCK_psa_generate_random_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  uint8_t* Expected_output;
  size_t Expected_output_size;

} CMOCK_psa_generate_random_CALL_INSTANCE;

typedef struct _CMOCK_psa_generate_key_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  const psa_key_attributes_t* Expected_attributes;
  psa_key_id_t* Expected_key;

} CMOCK_psa_generate_key_CALL_INSTANCE;

static struct MockcryptoInstance
{
  CMOCK_MEM_INDEX_TYPE psa_crypto_init_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_key_attributes_init_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_set_key_id_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_set_key_lifetime_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_get_key_id_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_get_key_lifetime_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_set_key_usage_flags_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_get_key_usage_flags_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_set_key_algorithm_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_get_key_algorithm_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_set_key_type_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_set_key_bits_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_get_key_type_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_get_key_bits_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_get_key_attributes_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_reset_key_attributes_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_purge_key_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_copy_key_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_destroy_key_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_import_key_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_export_key_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_export_public_key_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_hash_compute_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_hash_compare_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_hash_operation_init_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_hash_setup_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_hash_update_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_hash_finish_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_hash_verify_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_hash_abort_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_hash_clone_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_mac_compute_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_mac_verify_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_mac_operation_init_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_mac_sign_setup_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_mac_verify_setup_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_mac_update_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_mac_sign_finish_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_mac_verify_finish_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_mac_abort_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_cipher_encrypt_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_cipher_decrypt_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_cipher_operation_init_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_cipher_encrypt_setup_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_cipher_decrypt_setup_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_cipher_generate_iv_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_cipher_set_iv_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_cipher_update_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_cipher_finish_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_cipher_abort_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_aead_encrypt_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_aead_decrypt_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_aead_operation_init_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_aead_encrypt_setup_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_aead_decrypt_setup_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_aead_generate_nonce_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_aead_set_nonce_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_aead_set_lengths_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_aead_update_ad_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_aead_update_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_aead_finish_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_aead_verify_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_aead_abort_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_sign_message_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_verify_message_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_sign_hash_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_verify_hash_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_asymmetric_encrypt_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_asymmetric_decrypt_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_operation_init_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_setup_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_get_capacity_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_set_capacity_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_input_bytes_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_input_integer_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_input_key_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_key_agreement_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_output_bytes_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_output_key_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_verify_bytes_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_verify_key_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_abort_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_raw_key_agreement_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_generate_random_CallInstance;
  CMOCK_MEM_INDEX_TYPE psa_generate_key_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void Mockcrypto_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.psa_crypto_init_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_crypto_init);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_key_attributes_init_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_attributes_init);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_set_key_id_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_set_key_id);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_set_key_lifetime_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_set_key_lifetime);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_get_key_id_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_get_key_id);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_get_key_lifetime_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_get_key_lifetime);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_set_key_usage_flags_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_set_key_usage_flags);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_get_key_usage_flags_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_get_key_usage_flags);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_set_key_algorithm_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_set_key_algorithm);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_get_key_algorithm_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_get_key_algorithm);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_set_key_type_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_set_key_type);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_set_key_bits_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_set_key_bits);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_get_key_type_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_get_key_type);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_get_key_bits_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_get_key_bits);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_get_key_attributes_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_get_key_attributes);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_reset_key_attributes_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_reset_key_attributes);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_purge_key_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_purge_key);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_copy_key_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_copy_key);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_destroy_key_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_destroy_key);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_import_key_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_import_key);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_export_key_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_export_key);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_export_public_key_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_export_public_key);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_hash_compute_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_hash_compute);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_hash_compare_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_hash_compare);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_hash_operation_init_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_hash_operation_init);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_hash_setup_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_hash_setup);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_hash_update_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_hash_update);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_hash_finish_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_hash_finish);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_hash_verify_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_hash_verify);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_hash_abort_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_hash_abort);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_hash_clone_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_hash_clone);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_mac_compute_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_mac_compute);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_mac_verify_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_mac_verify);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_mac_operation_init_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_mac_operation_init);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_mac_sign_setup_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_mac_sign_setup);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_mac_verify_setup_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_mac_verify_setup);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_mac_update_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_mac_update);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_mac_sign_finish_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_mac_sign_finish);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_mac_verify_finish_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_mac_verify_finish);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_mac_abort_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_mac_abort);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_cipher_encrypt_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_cipher_encrypt);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_cipher_decrypt_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_cipher_decrypt);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_cipher_operation_init_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_cipher_operation_init);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_cipher_encrypt_setup_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_cipher_encrypt_setup);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_cipher_decrypt_setup_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_cipher_decrypt_setup);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_cipher_generate_iv_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_cipher_generate_iv);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_cipher_set_iv_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_cipher_set_iv);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_cipher_update_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_cipher_update);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_cipher_finish_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_cipher_finish);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_cipher_abort_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_cipher_abort);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_aead_encrypt_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_encrypt);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_aead_decrypt_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_decrypt);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_aead_operation_init_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_operation_init);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_aead_encrypt_setup_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_encrypt_setup);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_aead_decrypt_setup_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_decrypt_setup);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_aead_generate_nonce_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_generate_nonce);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_aead_set_nonce_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_set_nonce);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_aead_set_lengths_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_set_lengths);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_aead_update_ad_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_update_ad);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_aead_update_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_update);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_aead_finish_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_finish);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_aead_verify_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_verify);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_aead_abort_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_abort);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_sign_message_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_sign_message);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_verify_message_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_verify_message);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_sign_hash_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_sign_hash);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_verify_hash_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_verify_hash);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_asymmetric_encrypt_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_asymmetric_encrypt);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_asymmetric_decrypt_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_asymmetric_decrypt);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_key_derivation_operation_init_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_operation_init);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_key_derivation_setup_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_setup);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_key_derivation_get_capacity_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_get_capacity);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_key_derivation_set_capacity_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_set_capacity);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_key_derivation_input_bytes_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_input_bytes);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_key_derivation_input_integer_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_input_integer);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_key_derivation_input_key_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_input_key);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_key_derivation_key_agreement_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_key_agreement);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_key_derivation_output_bytes_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_output_bytes);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_key_derivation_output_key_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_output_key);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_key_derivation_verify_bytes_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_verify_bytes);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_key_derivation_verify_key_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_verify_key);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_key_derivation_abort_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_abort);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_raw_key_agreement_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_raw_key_agreement);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_generate_random_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_generate_random);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.psa_generate_key_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_generate_key);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
}

void Mockcrypto_Init(void)
{
  Mockcrypto_Destroy();
}

void Mockcrypto_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

psa_status_t psa_crypto_init(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_crypto_init_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_crypto_init);
  cmock_call_instance = (CMOCK_psa_crypto_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_crypto_init_CallInstance);
  Mock.psa_crypto_init_CallInstance = CMock_Guts_MemNext(Mock.psa_crypto_init_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void psa_crypto_init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_crypto_init_CALL_INSTANCE));
  CMOCK_psa_crypto_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_crypto_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_crypto_init_CallInstance = CMock_Guts_MemChain(Mock.psa_crypto_init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_key_attributes_t psa_key_attributes_init(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_attributes_init_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_attributes_init);
  cmock_call_instance = (CMOCK_psa_key_attributes_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_attributes_init_CallInstance);
  Mock.psa_key_attributes_init_CallInstance = CMock_Guts_MemNext(Mock.psa_key_attributes_init_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void psa_key_attributes_init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_attributes_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_attributes_init_CALL_INSTANCE));
  CMOCK_psa_key_attributes_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_attributes_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_attributes_init_CallInstance = CMock_Guts_MemChain(Mock.psa_key_attributes_init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_key_attributes_t[sizeof(cmock_to_return) == sizeof(psa_key_attributes_t) ? 1 : -1])); /* add psa_key_attributes_t to :treat_as_array if this causes an error */
}

void psa_set_key_id(psa_key_attributes_t* attributes, psa_key_id_t key)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_set_key_id_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_set_key_id);
  cmock_call_instance = (CMOCK_psa_set_key_id_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_set_key_id_CallInstance);
  Mock.psa_set_key_id_CallInstance = CMock_Guts_MemNext(Mock.psa_set_key_id_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_set_key_id,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_set_key_id,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_psa_set_key_id(CMOCK_psa_set_key_id_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes, psa_key_id_t key);
void CMockExpectParameters_psa_set_key_id(CMOCK_psa_set_key_id_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes, psa_key_id_t key)
{
  cmock_call_instance->Expected_attributes = attributes;
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
}

void psa_set_key_id_CMockExpect(UNITY_LINE_TYPE cmock_line, psa_key_attributes_t* attributes, psa_key_id_t key)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_set_key_id_CALL_INSTANCE));
  CMOCK_psa_set_key_id_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_set_key_id_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_set_key_id_CallInstance = CMock_Guts_MemChain(Mock.psa_set_key_id_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_set_key_id(cmock_call_instance, attributes, key);
}

void psa_set_key_lifetime(psa_key_attributes_t* attributes, psa_key_lifetime_t lifetime)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_set_key_lifetime_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_set_key_lifetime);
  cmock_call_instance = (CMOCK_psa_set_key_lifetime_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_set_key_lifetime_CallInstance);
  Mock.psa_set_key_lifetime_CallInstance = CMock_Guts_MemNext(Mock.psa_set_key_lifetime_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_set_key_lifetime,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_set_key_lifetime,CMockString_lifetime);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_lifetime), (void*)(&lifetime), sizeof(psa_key_lifetime_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_psa_set_key_lifetime(CMOCK_psa_set_key_lifetime_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes, psa_key_lifetime_t lifetime);
void CMockExpectParameters_psa_set_key_lifetime(CMOCK_psa_set_key_lifetime_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes, psa_key_lifetime_t lifetime)
{
  cmock_call_instance->Expected_attributes = attributes;
  memcpy((void*)(&cmock_call_instance->Expected_lifetime), (void*)(&lifetime),
         sizeof(psa_key_lifetime_t[sizeof(lifetime) == sizeof(psa_key_lifetime_t) ? 1 : -1])); /* add psa_key_lifetime_t to :treat_as_array if this causes an error */
}

void psa_set_key_lifetime_CMockExpect(UNITY_LINE_TYPE cmock_line, psa_key_attributes_t* attributes, psa_key_lifetime_t lifetime)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_set_key_lifetime_CALL_INSTANCE));
  CMOCK_psa_set_key_lifetime_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_set_key_lifetime_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_set_key_lifetime_CallInstance = CMock_Guts_MemChain(Mock.psa_set_key_lifetime_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_set_key_lifetime(cmock_call_instance, attributes, lifetime);
}

psa_key_id_t psa_get_key_id(const psa_key_attributes_t* attributes)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_get_key_id_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_get_key_id);
  cmock_call_instance = (CMOCK_psa_get_key_id_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_get_key_id_CallInstance);
  Mock.psa_get_key_id_CallInstance = CMock_Guts_MemNext(Mock.psa_get_key_id_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_get_key_id,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(const psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_get_key_id(CMOCK_psa_get_key_id_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes);
void CMockExpectParameters_psa_get_key_id(CMOCK_psa_get_key_id_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes)
{
  cmock_call_instance->Expected_attributes = attributes;
}

void psa_get_key_id_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const psa_key_attributes_t* attributes, psa_key_id_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_get_key_id_CALL_INSTANCE));
  CMOCK_psa_get_key_id_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_get_key_id_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_get_key_id_CallInstance = CMock_Guts_MemChain(Mock.psa_get_key_id_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_get_key_id(cmock_call_instance, attributes);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_key_id_t[sizeof(cmock_to_return) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
}

psa_key_lifetime_t psa_get_key_lifetime(const psa_key_attributes_t* attributes)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_get_key_lifetime_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_get_key_lifetime);
  cmock_call_instance = (CMOCK_psa_get_key_lifetime_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_get_key_lifetime_CallInstance);
  Mock.psa_get_key_lifetime_CallInstance = CMock_Guts_MemNext(Mock.psa_get_key_lifetime_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_get_key_lifetime,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(const psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_get_key_lifetime(CMOCK_psa_get_key_lifetime_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes);
void CMockExpectParameters_psa_get_key_lifetime(CMOCK_psa_get_key_lifetime_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes)
{
  cmock_call_instance->Expected_attributes = attributes;
}

void psa_get_key_lifetime_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const psa_key_attributes_t* attributes, psa_key_lifetime_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_get_key_lifetime_CALL_INSTANCE));
  CMOCK_psa_get_key_lifetime_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_get_key_lifetime_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_get_key_lifetime_CallInstance = CMock_Guts_MemChain(Mock.psa_get_key_lifetime_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_get_key_lifetime(cmock_call_instance, attributes);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_key_lifetime_t[sizeof(cmock_to_return) == sizeof(psa_key_lifetime_t) ? 1 : -1])); /* add psa_key_lifetime_t to :treat_as_array if this causes an error */
}

void psa_set_key_usage_flags(psa_key_attributes_t* attributes, psa_key_usage_t usage_flags)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_set_key_usage_flags_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_set_key_usage_flags);
  cmock_call_instance = (CMOCK_psa_set_key_usage_flags_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_set_key_usage_flags_CallInstance);
  Mock.psa_set_key_usage_flags_CallInstance = CMock_Guts_MemNext(Mock.psa_set_key_usage_flags_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_set_key_usage_flags,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_set_key_usage_flags,CMockString_usage_flags);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_usage_flags), (void*)(&usage_flags), sizeof(psa_key_usage_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_psa_set_key_usage_flags(CMOCK_psa_set_key_usage_flags_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes, psa_key_usage_t usage_flags);
void CMockExpectParameters_psa_set_key_usage_flags(CMOCK_psa_set_key_usage_flags_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes, psa_key_usage_t usage_flags)
{
  cmock_call_instance->Expected_attributes = attributes;
  memcpy((void*)(&cmock_call_instance->Expected_usage_flags), (void*)(&usage_flags),
         sizeof(psa_key_usage_t[sizeof(usage_flags) == sizeof(psa_key_usage_t) ? 1 : -1])); /* add psa_key_usage_t to :treat_as_array if this causes an error */
}

void psa_set_key_usage_flags_CMockExpect(UNITY_LINE_TYPE cmock_line, psa_key_attributes_t* attributes, psa_key_usage_t usage_flags)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_set_key_usage_flags_CALL_INSTANCE));
  CMOCK_psa_set_key_usage_flags_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_set_key_usage_flags_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_set_key_usage_flags_CallInstance = CMock_Guts_MemChain(Mock.psa_set_key_usage_flags_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_set_key_usage_flags(cmock_call_instance, attributes, usage_flags);
}

psa_key_usage_t psa_get_key_usage_flags(const psa_key_attributes_t* attributes)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_get_key_usage_flags_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_get_key_usage_flags);
  cmock_call_instance = (CMOCK_psa_get_key_usage_flags_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_get_key_usage_flags_CallInstance);
  Mock.psa_get_key_usage_flags_CallInstance = CMock_Guts_MemNext(Mock.psa_get_key_usage_flags_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_get_key_usage_flags,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(const psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_get_key_usage_flags(CMOCK_psa_get_key_usage_flags_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes);
void CMockExpectParameters_psa_get_key_usage_flags(CMOCK_psa_get_key_usage_flags_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes)
{
  cmock_call_instance->Expected_attributes = attributes;
}

void psa_get_key_usage_flags_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const psa_key_attributes_t* attributes, psa_key_usage_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_get_key_usage_flags_CALL_INSTANCE));
  CMOCK_psa_get_key_usage_flags_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_get_key_usage_flags_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_get_key_usage_flags_CallInstance = CMock_Guts_MemChain(Mock.psa_get_key_usage_flags_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_get_key_usage_flags(cmock_call_instance, attributes);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_key_usage_t[sizeof(cmock_to_return) == sizeof(psa_key_usage_t) ? 1 : -1])); /* add psa_key_usage_t to :treat_as_array if this causes an error */
}

void psa_set_key_algorithm(psa_key_attributes_t* attributes, psa_algorithm_t alg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_set_key_algorithm_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_set_key_algorithm);
  cmock_call_instance = (CMOCK_psa_set_key_algorithm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_set_key_algorithm_CallInstance);
  Mock.psa_set_key_algorithm_CallInstance = CMock_Guts_MemNext(Mock.psa_set_key_algorithm_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_set_key_algorithm,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_set_key_algorithm,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_psa_set_key_algorithm(CMOCK_psa_set_key_algorithm_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes, psa_algorithm_t alg);
void CMockExpectParameters_psa_set_key_algorithm(CMOCK_psa_set_key_algorithm_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes, psa_algorithm_t alg)
{
  cmock_call_instance->Expected_attributes = attributes;
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
}

void psa_set_key_algorithm_CMockExpect(UNITY_LINE_TYPE cmock_line, psa_key_attributes_t* attributes, psa_algorithm_t alg)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_set_key_algorithm_CALL_INSTANCE));
  CMOCK_psa_set_key_algorithm_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_set_key_algorithm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_set_key_algorithm_CallInstance = CMock_Guts_MemChain(Mock.psa_set_key_algorithm_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_set_key_algorithm(cmock_call_instance, attributes, alg);
}

psa_algorithm_t psa_get_key_algorithm(const psa_key_attributes_t* attributes)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_get_key_algorithm_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_get_key_algorithm);
  cmock_call_instance = (CMOCK_psa_get_key_algorithm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_get_key_algorithm_CallInstance);
  Mock.psa_get_key_algorithm_CallInstance = CMock_Guts_MemNext(Mock.psa_get_key_algorithm_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_get_key_algorithm,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(const psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_get_key_algorithm(CMOCK_psa_get_key_algorithm_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes);
void CMockExpectParameters_psa_get_key_algorithm(CMOCK_psa_get_key_algorithm_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes)
{
  cmock_call_instance->Expected_attributes = attributes;
}

void psa_get_key_algorithm_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const psa_key_attributes_t* attributes, psa_algorithm_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_get_key_algorithm_CALL_INSTANCE));
  CMOCK_psa_get_key_algorithm_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_get_key_algorithm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_get_key_algorithm_CallInstance = CMock_Guts_MemChain(Mock.psa_get_key_algorithm_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_get_key_algorithm(cmock_call_instance, attributes);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_algorithm_t[sizeof(cmock_to_return) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
}

void psa_set_key_type(psa_key_attributes_t* attributes, psa_key_type_t type)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_set_key_type_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_set_key_type);
  cmock_call_instance = (CMOCK_psa_set_key_type_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_set_key_type_CallInstance);
  Mock.psa_set_key_type_CallInstance = CMock_Guts_MemNext(Mock.psa_set_key_type_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_set_key_type,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_set_key_type,CMockString_type);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_type), (void*)(&type), sizeof(psa_key_type_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_psa_set_key_type(CMOCK_psa_set_key_type_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes, psa_key_type_t type);
void CMockExpectParameters_psa_set_key_type(CMOCK_psa_set_key_type_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes, psa_key_type_t type)
{
  cmock_call_instance->Expected_attributes = attributes;
  memcpy((void*)(&cmock_call_instance->Expected_type), (void*)(&type),
         sizeof(psa_key_type_t[sizeof(type) == sizeof(psa_key_type_t) ? 1 : -1])); /* add psa_key_type_t to :treat_as_array if this causes an error */
}

void psa_set_key_type_CMockExpect(UNITY_LINE_TYPE cmock_line, psa_key_attributes_t* attributes, psa_key_type_t type)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_set_key_type_CALL_INSTANCE));
  CMOCK_psa_set_key_type_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_set_key_type_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_set_key_type_CallInstance = CMock_Guts_MemChain(Mock.psa_set_key_type_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_set_key_type(cmock_call_instance, attributes, type);
}

void psa_set_key_bits(psa_key_attributes_t* attributes, size_t bits)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_set_key_bits_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_set_key_bits);
  cmock_call_instance = (CMOCK_psa_set_key_bits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_set_key_bits_CallInstance);
  Mock.psa_set_key_bits_CallInstance = CMock_Guts_MemNext(Mock.psa_set_key_bits_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_set_key_bits,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_set_key_bits,CMockString_bits);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_bits), (void*)(&bits), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_psa_set_key_bits(CMOCK_psa_set_key_bits_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes, size_t bits);
void CMockExpectParameters_psa_set_key_bits(CMOCK_psa_set_key_bits_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes, size_t bits)
{
  cmock_call_instance->Expected_attributes = attributes;
  memcpy((void*)(&cmock_call_instance->Expected_bits), (void*)(&bits),
         sizeof(size_t[sizeof(bits) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_set_key_bits_CMockExpect(UNITY_LINE_TYPE cmock_line, psa_key_attributes_t* attributes, size_t bits)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_set_key_bits_CALL_INSTANCE));
  CMOCK_psa_set_key_bits_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_set_key_bits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_set_key_bits_CallInstance = CMock_Guts_MemChain(Mock.psa_set_key_bits_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_set_key_bits(cmock_call_instance, attributes, bits);
}

psa_key_type_t psa_get_key_type(const psa_key_attributes_t* attributes)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_get_key_type_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_get_key_type);
  cmock_call_instance = (CMOCK_psa_get_key_type_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_get_key_type_CallInstance);
  Mock.psa_get_key_type_CallInstance = CMock_Guts_MemNext(Mock.psa_get_key_type_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_get_key_type,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(const psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_get_key_type(CMOCK_psa_get_key_type_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes);
void CMockExpectParameters_psa_get_key_type(CMOCK_psa_get_key_type_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes)
{
  cmock_call_instance->Expected_attributes = attributes;
}

void psa_get_key_type_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const psa_key_attributes_t* attributes, psa_key_type_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_get_key_type_CALL_INSTANCE));
  CMOCK_psa_get_key_type_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_get_key_type_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_get_key_type_CallInstance = CMock_Guts_MemChain(Mock.psa_get_key_type_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_get_key_type(cmock_call_instance, attributes);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_key_type_t[sizeof(cmock_to_return) == sizeof(psa_key_type_t) ? 1 : -1])); /* add psa_key_type_t to :treat_as_array if this causes an error */
}

size_t psa_get_key_bits(const psa_key_attributes_t* attributes)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_get_key_bits_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_get_key_bits);
  cmock_call_instance = (CMOCK_psa_get_key_bits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_get_key_bits_CallInstance);
  Mock.psa_get_key_bits_CallInstance = CMock_Guts_MemNext(Mock.psa_get_key_bits_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_get_key_bits,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(const psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_get_key_bits(CMOCK_psa_get_key_bits_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes);
void CMockExpectParameters_psa_get_key_bits(CMOCK_psa_get_key_bits_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes)
{
  cmock_call_instance->Expected_attributes = attributes;
}

void psa_get_key_bits_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const psa_key_attributes_t* attributes, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_get_key_bits_CALL_INSTANCE));
  CMOCK_psa_get_key_bits_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_get_key_bits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_get_key_bits_CallInstance = CMock_Guts_MemChain(Mock.psa_get_key_bits_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_get_key_bits(cmock_call_instance, attributes);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

psa_status_t psa_get_key_attributes(psa_key_id_t key, psa_key_attributes_t* attributes)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_get_key_attributes_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_get_key_attributes);
  cmock_call_instance = (CMOCK_psa_get_key_attributes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_get_key_attributes_CallInstance);
  Mock.psa_get_key_attributes_CallInstance = CMock_Guts_MemNext(Mock.psa_get_key_attributes_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_get_key_attributes,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_get_key_attributes,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_get_key_attributes(CMOCK_psa_get_key_attributes_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_key_attributes_t* attributes);
void CMockExpectParameters_psa_get_key_attributes(CMOCK_psa_get_key_attributes_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_key_attributes_t* attributes)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_attributes = attributes;
}

void psa_get_key_attributes_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_key_attributes_t* attributes, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_get_key_attributes_CALL_INSTANCE));
  CMOCK_psa_get_key_attributes_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_get_key_attributes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_get_key_attributes_CallInstance = CMock_Guts_MemChain(Mock.psa_get_key_attributes_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_get_key_attributes(cmock_call_instance, key, attributes);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_reset_key_attributes(psa_key_attributes_t* attributes)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_reset_key_attributes_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_reset_key_attributes);
  cmock_call_instance = (CMOCK_psa_reset_key_attributes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_reset_key_attributes_CallInstance);
  Mock.psa_reset_key_attributes_CallInstance = CMock_Guts_MemNext(Mock.psa_reset_key_attributes_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_reset_key_attributes,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_psa_reset_key_attributes(CMOCK_psa_reset_key_attributes_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes);
void CMockExpectParameters_psa_reset_key_attributes(CMOCK_psa_reset_key_attributes_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes)
{
  cmock_call_instance->Expected_attributes = attributes;
}

void psa_reset_key_attributes_CMockExpect(UNITY_LINE_TYPE cmock_line, psa_key_attributes_t* attributes)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_reset_key_attributes_CALL_INSTANCE));
  CMOCK_psa_reset_key_attributes_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_reset_key_attributes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_reset_key_attributes_CallInstance = CMock_Guts_MemChain(Mock.psa_reset_key_attributes_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_reset_key_attributes(cmock_call_instance, attributes);
}

psa_status_t psa_purge_key(psa_key_id_t key)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_purge_key_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_purge_key);
  cmock_call_instance = (CMOCK_psa_purge_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_purge_key_CallInstance);
  Mock.psa_purge_key_CallInstance = CMock_Guts_MemNext(Mock.psa_purge_key_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_purge_key,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_purge_key(CMOCK_psa_purge_key_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key);
void CMockExpectParameters_psa_purge_key(CMOCK_psa_purge_key_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
}

void psa_purge_key_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_purge_key_CALL_INSTANCE));
  CMOCK_psa_purge_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_purge_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_purge_key_CallInstance = CMock_Guts_MemChain(Mock.psa_purge_key_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_purge_key(cmock_call_instance, key);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_copy_key(psa_key_id_t source_key, const psa_key_attributes_t* attributes, psa_key_id_t* target_key)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_copy_key_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_copy_key);
  cmock_call_instance = (CMOCK_psa_copy_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_copy_key_CallInstance);
  Mock.psa_copy_key_CallInstance = CMock_Guts_MemNext(Mock.psa_copy_key_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_copy_key,CMockString_source_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_source_key), (void*)(&source_key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_copy_key,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(const psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_copy_key,CMockString_target_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_target_key), (void*)(target_key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_copy_key(CMOCK_psa_copy_key_CALL_INSTANCE* cmock_call_instance, psa_key_id_t source_key, const psa_key_attributes_t* attributes, psa_key_id_t* target_key);
void CMockExpectParameters_psa_copy_key(CMOCK_psa_copy_key_CALL_INSTANCE* cmock_call_instance, psa_key_id_t source_key, const psa_key_attributes_t* attributes, psa_key_id_t* target_key)
{
  memcpy((void*)(&cmock_call_instance->Expected_source_key), (void*)(&source_key),
         sizeof(psa_key_id_t[sizeof(source_key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_attributes = attributes;
  cmock_call_instance->Expected_target_key = target_key;
}

void psa_copy_key_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t source_key, const psa_key_attributes_t* attributes, psa_key_id_t* target_key, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_copy_key_CALL_INSTANCE));
  CMOCK_psa_copy_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_copy_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_copy_key_CallInstance = CMock_Guts_MemChain(Mock.psa_copy_key_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_copy_key(cmock_call_instance, source_key, attributes, target_key);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_destroy_key(psa_key_id_t key)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_destroy_key_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_destroy_key);
  cmock_call_instance = (CMOCK_psa_destroy_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_destroy_key_CallInstance);
  Mock.psa_destroy_key_CallInstance = CMock_Guts_MemNext(Mock.psa_destroy_key_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_destroy_key,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_destroy_key(CMOCK_psa_destroy_key_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key);
void CMockExpectParameters_psa_destroy_key(CMOCK_psa_destroy_key_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
}

void psa_destroy_key_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_destroy_key_CALL_INSTANCE));
  CMOCK_psa_destroy_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_destroy_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_destroy_key_CallInstance = CMock_Guts_MemChain(Mock.psa_destroy_key_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_destroy_key(cmock_call_instance, key);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_import_key(const psa_key_attributes_t* attributes, const uint8_t* data, size_t data_length, psa_key_id_t* key)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_import_key_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_import_key);
  cmock_call_instance = (CMOCK_psa_import_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_import_key_CallInstance);
  Mock.psa_import_key_CallInstance = CMock_Guts_MemNext(Mock.psa_import_key_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_import_key,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(const psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_import_key,CMockString_data);
    if (cmock_call_instance->Expected_data == NULL)
      { UNITY_TEST_ASSERT_NULL(data, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_data, data, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_import_key,CMockString_data_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_data_length), (void*)(&data_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_import_key,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_key), (void*)(key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_import_key(CMOCK_psa_import_key_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes, const uint8_t* data, size_t data_length, psa_key_id_t* key);
void CMockExpectParameters_psa_import_key(CMOCK_psa_import_key_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes, const uint8_t* data, size_t data_length, psa_key_id_t* key)
{
  cmock_call_instance->Expected_attributes = attributes;
  cmock_call_instance->Expected_data = data;
  memcpy((void*)(&cmock_call_instance->Expected_data_length), (void*)(&data_length),
         sizeof(size_t[sizeof(data_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_key = key;
}

void psa_import_key_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const psa_key_attributes_t* attributes, const uint8_t* data, size_t data_length, psa_key_id_t* key, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_import_key_CALL_INSTANCE));
  CMOCK_psa_import_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_import_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_import_key_CallInstance = CMock_Guts_MemChain(Mock.psa_import_key_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_import_key(cmock_call_instance, attributes, data, data_length, key);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_export_key(psa_key_id_t key, uint8_t* data, size_t data_size, size_t* data_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_export_key_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_export_key);
  cmock_call_instance = (CMOCK_psa_export_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_export_key_CallInstance);
  Mock.psa_export_key_CallInstance = CMock_Guts_MemNext(Mock.psa_export_key_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_export_key,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_export_key,CMockString_data);
    if (cmock_call_instance->Expected_data == NULL)
      { UNITY_TEST_ASSERT_NULL(data, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_data, data, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_export_key,CMockString_data_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_data_size), (void*)(&data_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_export_key,CMockString_data_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_data_length), (void*)(data_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_export_key(CMOCK_psa_export_key_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, uint8_t* data, size_t data_size, size_t* data_length);
void CMockExpectParameters_psa_export_key(CMOCK_psa_export_key_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, uint8_t* data, size_t data_size, size_t* data_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_data = data;
  memcpy((void*)(&cmock_call_instance->Expected_data_size), (void*)(&data_size),
         sizeof(size_t[sizeof(data_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_data_length = data_length;
}

void psa_export_key_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, uint8_t* data, size_t data_size, size_t* data_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_export_key_CALL_INSTANCE));
  CMOCK_psa_export_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_export_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_export_key_CallInstance = CMock_Guts_MemChain(Mock.psa_export_key_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_export_key(cmock_call_instance, key, data, data_size, data_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_export_public_key(psa_key_id_t key, uint8_t* data, size_t data_size, size_t* data_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_export_public_key_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_export_public_key);
  cmock_call_instance = (CMOCK_psa_export_public_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_export_public_key_CallInstance);
  Mock.psa_export_public_key_CallInstance = CMock_Guts_MemNext(Mock.psa_export_public_key_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_export_public_key,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_export_public_key,CMockString_data);
    if (cmock_call_instance->Expected_data == NULL)
      { UNITY_TEST_ASSERT_NULL(data, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_data, data, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_export_public_key,CMockString_data_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_data_size), (void*)(&data_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_export_public_key,CMockString_data_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_data_length), (void*)(data_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_export_public_key(CMOCK_psa_export_public_key_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, uint8_t* data, size_t data_size, size_t* data_length);
void CMockExpectParameters_psa_export_public_key(CMOCK_psa_export_public_key_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, uint8_t* data, size_t data_size, size_t* data_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_data = data;
  memcpy((void*)(&cmock_call_instance->Expected_data_size), (void*)(&data_size),
         sizeof(size_t[sizeof(data_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_data_length = data_length;
}

void psa_export_public_key_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, uint8_t* data, size_t data_size, size_t* data_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_export_public_key_CALL_INSTANCE));
  CMOCK_psa_export_public_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_export_public_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_export_public_key_CallInstance = CMock_Guts_MemChain(Mock.psa_export_public_key_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_export_public_key(cmock_call_instance, key, data, data_size, data_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_hash_compute(psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* hash, size_t hash_size, size_t* hash_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_hash_compute_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_hash_compute);
  cmock_call_instance = (CMOCK_psa_hash_compute_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_hash_compute_CallInstance);
  Mock.psa_hash_compute_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_compute_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_compute,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_compute,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_compute,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_compute,CMockString_hash);
    if (cmock_call_instance->Expected_hash == NULL)
      { UNITY_TEST_ASSERT_NULL(hash, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_hash, hash, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_compute,CMockString_hash_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_hash_size), (void*)(&hash_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_compute,CMockString_hash_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hash_length), (void*)(hash_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_hash_compute(CMOCK_psa_hash_compute_CALL_INSTANCE* cmock_call_instance, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* hash, size_t hash_size, size_t* hash_length);
void CMockExpectParameters_psa_hash_compute(CMOCK_psa_hash_compute_CALL_INSTANCE* cmock_call_instance, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* hash, size_t hash_size, size_t* hash_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_hash = hash;
  memcpy((void*)(&cmock_call_instance->Expected_hash_size), (void*)(&hash_size),
         sizeof(size_t[sizeof(hash_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_hash_length = hash_length;
}

void psa_hash_compute_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* hash, size_t hash_size, size_t* hash_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_compute_CALL_INSTANCE));
  CMOCK_psa_hash_compute_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_compute_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_compute_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_compute_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_hash_compute(cmock_call_instance, alg, input, input_length, hash, hash_size, hash_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_hash_compare(psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* hash, size_t hash_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_hash_compare_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_hash_compare);
  cmock_call_instance = (CMOCK_psa_hash_compare_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_hash_compare_CallInstance);
  Mock.psa_hash_compare_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_compare_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_compare,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_compare,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_compare,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_compare,CMockString_hash);
    if (cmock_call_instance->Expected_hash == NULL)
      { UNITY_TEST_ASSERT_NULL(hash, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_hash, hash, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_compare,CMockString_hash_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_hash_length), (void*)(&hash_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_hash_compare(CMOCK_psa_hash_compare_CALL_INSTANCE* cmock_call_instance, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* hash, size_t hash_length);
void CMockExpectParameters_psa_hash_compare(CMOCK_psa_hash_compare_CALL_INSTANCE* cmock_call_instance, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* hash, size_t hash_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_hash = hash;
  memcpy((void*)(&cmock_call_instance->Expected_hash_length), (void*)(&hash_length),
         sizeof(size_t[sizeof(hash_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_hash_compare_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* hash, size_t hash_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_compare_CALL_INSTANCE));
  CMOCK_psa_hash_compare_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_compare_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_compare_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_compare_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_hash_compare(cmock_call_instance, alg, input, input_length, hash, hash_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_hash_operation_t psa_hash_operation_init(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_hash_operation_init_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_hash_operation_init);
  cmock_call_instance = (CMOCK_psa_hash_operation_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_hash_operation_init_CallInstance);
  Mock.psa_hash_operation_init_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_operation_init_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void psa_hash_operation_init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_hash_operation_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_operation_init_CALL_INSTANCE));
  CMOCK_psa_hash_operation_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_operation_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_operation_init_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_operation_init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_hash_operation_t[sizeof(cmock_to_return) == sizeof(psa_hash_operation_t) ? 1 : -1])); /* add psa_hash_operation_t to :treat_as_array if this causes an error */
}

psa_status_t psa_hash_setup(psa_hash_operation_t* operation, psa_algorithm_t alg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_hash_setup_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_hash_setup);
  cmock_call_instance = (CMOCK_psa_hash_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_hash_setup_CallInstance);
  Mock.psa_hash_setup_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_setup_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_setup,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_hash_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_setup,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_hash_setup(CMOCK_psa_hash_setup_CALL_INSTANCE* cmock_call_instance, psa_hash_operation_t* operation, psa_algorithm_t alg);
void CMockExpectParameters_psa_hash_setup(CMOCK_psa_hash_setup_CALL_INSTANCE* cmock_call_instance, psa_hash_operation_t* operation, psa_algorithm_t alg)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
}

void psa_hash_setup_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_hash_operation_t* operation, psa_algorithm_t alg, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_setup_CALL_INSTANCE));
  CMOCK_psa_hash_setup_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_setup_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_setup_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_hash_setup(cmock_call_instance, operation, alg);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_hash_update(psa_hash_operation_t* operation, const uint8_t* input, size_t input_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_hash_update_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_hash_update);
  cmock_call_instance = (CMOCK_psa_hash_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_hash_update_CallInstance);
  Mock.psa_hash_update_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_update_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_update,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_hash_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_update,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_update,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_hash_update(CMOCK_psa_hash_update_CALL_INSTANCE* cmock_call_instance, psa_hash_operation_t* operation, const uint8_t* input, size_t input_length);
void CMockExpectParameters_psa_hash_update(CMOCK_psa_hash_update_CALL_INSTANCE* cmock_call_instance, psa_hash_operation_t* operation, const uint8_t* input, size_t input_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_hash_update_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_hash_operation_t* operation, const uint8_t* input, size_t input_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_update_CALL_INSTANCE));
  CMOCK_psa_hash_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_update_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_update_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_hash_update(cmock_call_instance, operation, input, input_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_hash_finish(psa_hash_operation_t* operation, uint8_t* hash, size_t hash_size, size_t* hash_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_hash_finish_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_hash_finish);
  cmock_call_instance = (CMOCK_psa_hash_finish_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_hash_finish_CallInstance);
  Mock.psa_hash_finish_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_finish_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_finish,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_hash_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_finish,CMockString_hash);
    if (cmock_call_instance->Expected_hash == NULL)
      { UNITY_TEST_ASSERT_NULL(hash, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_hash, hash, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_finish,CMockString_hash_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_hash_size), (void*)(&hash_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_finish,CMockString_hash_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hash_length), (void*)(hash_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_hash_finish(CMOCK_psa_hash_finish_CALL_INSTANCE* cmock_call_instance, psa_hash_operation_t* operation, uint8_t* hash, size_t hash_size, size_t* hash_length);
void CMockExpectParameters_psa_hash_finish(CMOCK_psa_hash_finish_CALL_INSTANCE* cmock_call_instance, psa_hash_operation_t* operation, uint8_t* hash, size_t hash_size, size_t* hash_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_hash = hash;
  memcpy((void*)(&cmock_call_instance->Expected_hash_size), (void*)(&hash_size),
         sizeof(size_t[sizeof(hash_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_hash_length = hash_length;
}

void psa_hash_finish_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_hash_operation_t* operation, uint8_t* hash, size_t hash_size, size_t* hash_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_finish_CALL_INSTANCE));
  CMOCK_psa_hash_finish_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_finish_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_finish_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_finish_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_hash_finish(cmock_call_instance, operation, hash, hash_size, hash_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_hash_verify(psa_hash_operation_t* operation, const uint8_t* hash, size_t hash_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_hash_verify_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_hash_verify);
  cmock_call_instance = (CMOCK_psa_hash_verify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_hash_verify_CallInstance);
  Mock.psa_hash_verify_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_verify_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_verify,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_hash_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_verify,CMockString_hash);
    if (cmock_call_instance->Expected_hash == NULL)
      { UNITY_TEST_ASSERT_NULL(hash, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_hash, hash, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_verify,CMockString_hash_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_hash_length), (void*)(&hash_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_hash_verify(CMOCK_psa_hash_verify_CALL_INSTANCE* cmock_call_instance, psa_hash_operation_t* operation, const uint8_t* hash, size_t hash_length);
void CMockExpectParameters_psa_hash_verify(CMOCK_psa_hash_verify_CALL_INSTANCE* cmock_call_instance, psa_hash_operation_t* operation, const uint8_t* hash, size_t hash_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_hash = hash;
  memcpy((void*)(&cmock_call_instance->Expected_hash_length), (void*)(&hash_length),
         sizeof(size_t[sizeof(hash_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_hash_verify_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_hash_operation_t* operation, const uint8_t* hash, size_t hash_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_verify_CALL_INSTANCE));
  CMOCK_psa_hash_verify_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_verify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_verify_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_verify_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_hash_verify(cmock_call_instance, operation, hash, hash_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_hash_abort(psa_hash_operation_t* operation)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_hash_abort_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_hash_abort);
  cmock_call_instance = (CMOCK_psa_hash_abort_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_hash_abort_CallInstance);
  Mock.psa_hash_abort_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_abort_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_abort,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_hash_operation_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_hash_abort(CMOCK_psa_hash_abort_CALL_INSTANCE* cmock_call_instance, psa_hash_operation_t* operation);
void CMockExpectParameters_psa_hash_abort(CMOCK_psa_hash_abort_CALL_INSTANCE* cmock_call_instance, psa_hash_operation_t* operation)
{
  cmock_call_instance->Expected_operation = operation;
}

void psa_hash_abort_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_hash_operation_t* operation, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_abort_CALL_INSTANCE));
  CMOCK_psa_hash_abort_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_abort_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_abort_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_abort_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_hash_abort(cmock_call_instance, operation);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_hash_clone(const psa_hash_operation_t* source_operation, psa_hash_operation_t* target_operation)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_hash_clone_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_hash_clone);
  cmock_call_instance = (CMOCK_psa_hash_clone_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_hash_clone_CallInstance);
  Mock.psa_hash_clone_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_clone_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_clone,CMockString_source_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_source_operation), (void*)(source_operation), sizeof(const psa_hash_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_clone,CMockString_target_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_target_operation), (void*)(target_operation), sizeof(psa_hash_operation_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_hash_clone(CMOCK_psa_hash_clone_CALL_INSTANCE* cmock_call_instance, const psa_hash_operation_t* source_operation, psa_hash_operation_t* target_operation);
void CMockExpectParameters_psa_hash_clone(CMOCK_psa_hash_clone_CALL_INSTANCE* cmock_call_instance, const psa_hash_operation_t* source_operation, psa_hash_operation_t* target_operation)
{
  cmock_call_instance->Expected_source_operation = source_operation;
  cmock_call_instance->Expected_target_operation = target_operation;
}

void psa_hash_clone_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const psa_hash_operation_t* source_operation, psa_hash_operation_t* target_operation, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_clone_CALL_INSTANCE));
  CMOCK_psa_hash_clone_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_clone_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_clone_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_clone_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_hash_clone(cmock_call_instance, source_operation, target_operation);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_mac_compute(psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* mac, size_t mac_size, size_t* mac_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_mac_compute_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_mac_compute);
  cmock_call_instance = (CMOCK_psa_mac_compute_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_mac_compute_CallInstance);
  Mock.psa_mac_compute_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_compute_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_compute,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_compute,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_compute,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_compute,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_compute,CMockString_mac);
    if (cmock_call_instance->Expected_mac == NULL)
      { UNITY_TEST_ASSERT_NULL(mac, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_mac, mac, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_compute,CMockString_mac_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mac_size), (void*)(&mac_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_compute,CMockString_mac_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_mac_length), (void*)(mac_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_mac_compute(CMOCK_psa_mac_compute_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* mac, size_t mac_size, size_t* mac_length);
void CMockExpectParameters_psa_mac_compute(CMOCK_psa_mac_compute_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* mac, size_t mac_size, size_t* mac_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_mac = mac;
  memcpy((void*)(&cmock_call_instance->Expected_mac_size), (void*)(&mac_size),
         sizeof(size_t[sizeof(mac_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_mac_length = mac_length;
}

void psa_mac_compute_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* mac, size_t mac_size, size_t* mac_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_compute_CALL_INSTANCE));
  CMOCK_psa_mac_compute_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_compute_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_compute_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_compute_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_mac_compute(cmock_call_instance, key, alg, input, input_length, mac, mac_size, mac_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_mac_verify(psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* mac, size_t mac_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_mac_verify_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_mac_verify);
  cmock_call_instance = (CMOCK_psa_mac_verify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_mac_verify_CallInstance);
  Mock.psa_mac_verify_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_verify_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_verify,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_verify,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_verify,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_verify,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_verify,CMockString_mac);
    if (cmock_call_instance->Expected_mac == NULL)
      { UNITY_TEST_ASSERT_NULL(mac, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_mac, mac, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_verify,CMockString_mac_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mac_length), (void*)(&mac_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_mac_verify(CMOCK_psa_mac_verify_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* mac, size_t mac_length);
void CMockExpectParameters_psa_mac_verify(CMOCK_psa_mac_verify_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* mac, size_t mac_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_mac = mac;
  memcpy((void*)(&cmock_call_instance->Expected_mac_length), (void*)(&mac_length),
         sizeof(size_t[sizeof(mac_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_mac_verify_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* mac, size_t mac_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_verify_CALL_INSTANCE));
  CMOCK_psa_mac_verify_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_verify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_verify_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_verify_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_mac_verify(cmock_call_instance, key, alg, input, input_length, mac, mac_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_mac_operation_t psa_mac_operation_init(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_mac_operation_init_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_mac_operation_init);
  cmock_call_instance = (CMOCK_psa_mac_operation_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_mac_operation_init_CallInstance);
  Mock.psa_mac_operation_init_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_operation_init_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void psa_mac_operation_init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_mac_operation_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_operation_init_CALL_INSTANCE));
  CMOCK_psa_mac_operation_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_operation_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_operation_init_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_operation_init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_mac_operation_t[sizeof(cmock_to_return) == sizeof(psa_mac_operation_t) ? 1 : -1])); /* add psa_mac_operation_t to :treat_as_array if this causes an error */
}

psa_status_t psa_mac_sign_setup(psa_mac_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_mac_sign_setup_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_mac_sign_setup);
  cmock_call_instance = (CMOCK_psa_mac_sign_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_mac_sign_setup_CallInstance);
  Mock.psa_mac_sign_setup_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_sign_setup_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_sign_setup,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_mac_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_sign_setup,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_sign_setup,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_mac_sign_setup(CMOCK_psa_mac_sign_setup_CALL_INSTANCE* cmock_call_instance, psa_mac_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg);
void CMockExpectParameters_psa_mac_sign_setup(CMOCK_psa_mac_sign_setup_CALL_INSTANCE* cmock_call_instance, psa_mac_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
}

void psa_mac_sign_setup_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_mac_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_sign_setup_CALL_INSTANCE));
  CMOCK_psa_mac_sign_setup_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_sign_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_sign_setup_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_sign_setup_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_mac_sign_setup(cmock_call_instance, operation, key, alg);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_mac_verify_setup(psa_mac_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_mac_verify_setup_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_mac_verify_setup);
  cmock_call_instance = (CMOCK_psa_mac_verify_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_mac_verify_setup_CallInstance);
  Mock.psa_mac_verify_setup_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_verify_setup_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_verify_setup,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_mac_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_verify_setup,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_verify_setup,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_mac_verify_setup(CMOCK_psa_mac_verify_setup_CALL_INSTANCE* cmock_call_instance, psa_mac_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg);
void CMockExpectParameters_psa_mac_verify_setup(CMOCK_psa_mac_verify_setup_CALL_INSTANCE* cmock_call_instance, psa_mac_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
}

void psa_mac_verify_setup_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_mac_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_verify_setup_CALL_INSTANCE));
  CMOCK_psa_mac_verify_setup_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_verify_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_verify_setup_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_verify_setup_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_mac_verify_setup(cmock_call_instance, operation, key, alg);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_mac_update(psa_mac_operation_t* operation, const uint8_t* input, size_t input_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_mac_update_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_mac_update);
  cmock_call_instance = (CMOCK_psa_mac_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_mac_update_CallInstance);
  Mock.psa_mac_update_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_update_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_update,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_mac_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_update,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_update,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_mac_update(CMOCK_psa_mac_update_CALL_INSTANCE* cmock_call_instance, psa_mac_operation_t* operation, const uint8_t* input, size_t input_length);
void CMockExpectParameters_psa_mac_update(CMOCK_psa_mac_update_CALL_INSTANCE* cmock_call_instance, psa_mac_operation_t* operation, const uint8_t* input, size_t input_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_mac_update_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_mac_operation_t* operation, const uint8_t* input, size_t input_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_update_CALL_INSTANCE));
  CMOCK_psa_mac_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_update_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_update_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_mac_update(cmock_call_instance, operation, input, input_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_mac_sign_finish(psa_mac_operation_t* operation, uint8_t* mac, size_t mac_size, size_t* mac_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_mac_sign_finish_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_mac_sign_finish);
  cmock_call_instance = (CMOCK_psa_mac_sign_finish_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_mac_sign_finish_CallInstance);
  Mock.psa_mac_sign_finish_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_sign_finish_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_sign_finish,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_mac_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_sign_finish,CMockString_mac);
    if (cmock_call_instance->Expected_mac == NULL)
      { UNITY_TEST_ASSERT_NULL(mac, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_mac, mac, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_sign_finish,CMockString_mac_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mac_size), (void*)(&mac_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_sign_finish,CMockString_mac_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_mac_length), (void*)(mac_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_mac_sign_finish(CMOCK_psa_mac_sign_finish_CALL_INSTANCE* cmock_call_instance, psa_mac_operation_t* operation, uint8_t* mac, size_t mac_size, size_t* mac_length);
void CMockExpectParameters_psa_mac_sign_finish(CMOCK_psa_mac_sign_finish_CALL_INSTANCE* cmock_call_instance, psa_mac_operation_t* operation, uint8_t* mac, size_t mac_size, size_t* mac_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_mac = mac;
  memcpy((void*)(&cmock_call_instance->Expected_mac_size), (void*)(&mac_size),
         sizeof(size_t[sizeof(mac_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_mac_length = mac_length;
}

void psa_mac_sign_finish_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_mac_operation_t* operation, uint8_t* mac, size_t mac_size, size_t* mac_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_sign_finish_CALL_INSTANCE));
  CMOCK_psa_mac_sign_finish_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_sign_finish_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_sign_finish_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_sign_finish_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_mac_sign_finish(cmock_call_instance, operation, mac, mac_size, mac_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_mac_verify_finish(psa_mac_operation_t* operation, const uint8_t* mac, size_t mac_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_mac_verify_finish_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_mac_verify_finish);
  cmock_call_instance = (CMOCK_psa_mac_verify_finish_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_mac_verify_finish_CallInstance);
  Mock.psa_mac_verify_finish_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_verify_finish_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_verify_finish,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_mac_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_verify_finish,CMockString_mac);
    if (cmock_call_instance->Expected_mac == NULL)
      { UNITY_TEST_ASSERT_NULL(mac, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_mac, mac, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_verify_finish,CMockString_mac_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mac_length), (void*)(&mac_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_mac_verify_finish(CMOCK_psa_mac_verify_finish_CALL_INSTANCE* cmock_call_instance, psa_mac_operation_t* operation, const uint8_t* mac, size_t mac_length);
void CMockExpectParameters_psa_mac_verify_finish(CMOCK_psa_mac_verify_finish_CALL_INSTANCE* cmock_call_instance, psa_mac_operation_t* operation, const uint8_t* mac, size_t mac_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_mac = mac;
  memcpy((void*)(&cmock_call_instance->Expected_mac_length), (void*)(&mac_length),
         sizeof(size_t[sizeof(mac_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_mac_verify_finish_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_mac_operation_t* operation, const uint8_t* mac, size_t mac_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_verify_finish_CALL_INSTANCE));
  CMOCK_psa_mac_verify_finish_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_verify_finish_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_verify_finish_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_verify_finish_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_mac_verify_finish(cmock_call_instance, operation, mac, mac_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_mac_abort(psa_mac_operation_t* operation)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_mac_abort_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_mac_abort);
  cmock_call_instance = (CMOCK_psa_mac_abort_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_mac_abort_CallInstance);
  Mock.psa_mac_abort_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_abort_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_abort,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_mac_operation_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_mac_abort(CMOCK_psa_mac_abort_CALL_INSTANCE* cmock_call_instance, psa_mac_operation_t* operation);
void CMockExpectParameters_psa_mac_abort(CMOCK_psa_mac_abort_CALL_INSTANCE* cmock_call_instance, psa_mac_operation_t* operation)
{
  cmock_call_instance->Expected_operation = operation;
}

void psa_mac_abort_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_mac_operation_t* operation, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_abort_CALL_INSTANCE));
  CMOCK_psa_mac_abort_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_abort_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_abort_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_abort_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_mac_abort(cmock_call_instance, operation);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_cipher_encrypt(psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_cipher_encrypt_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_cipher_encrypt);
  cmock_call_instance = (CMOCK_psa_cipher_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_cipher_encrypt_CallInstance);
  Mock.psa_cipher_encrypt_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_encrypt_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_encrypt,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_encrypt,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_encrypt,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_encrypt,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_encrypt,CMockString_output);
    if (cmock_call_instance->Expected_output == NULL)
      { UNITY_TEST_ASSERT_NULL(output, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_output, output, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_encrypt,CMockString_output_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_encrypt,CMockString_output_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_output_length), (void*)(output_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_cipher_encrypt(CMOCK_psa_cipher_encrypt_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length);
void CMockExpectParameters_psa_cipher_encrypt(CMOCK_psa_cipher_encrypt_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output = output;
  memcpy((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size),
         sizeof(size_t[sizeof(output_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output_length = output_length;
}

void psa_cipher_encrypt_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_encrypt_CALL_INSTANCE));
  CMOCK_psa_cipher_encrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_encrypt_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_encrypt_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_cipher_encrypt(cmock_call_instance, key, alg, input, input_length, output, output_size, output_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_cipher_decrypt(psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_cipher_decrypt_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_cipher_decrypt);
  cmock_call_instance = (CMOCK_psa_cipher_decrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_cipher_decrypt_CallInstance);
  Mock.psa_cipher_decrypt_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_decrypt_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_decrypt,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_decrypt,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_decrypt,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_decrypt,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_decrypt,CMockString_output);
    if (cmock_call_instance->Expected_output == NULL)
      { UNITY_TEST_ASSERT_NULL(output, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_output, output, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_decrypt,CMockString_output_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_decrypt,CMockString_output_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_output_length), (void*)(output_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_cipher_decrypt(CMOCK_psa_cipher_decrypt_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length);
void CMockExpectParameters_psa_cipher_decrypt(CMOCK_psa_cipher_decrypt_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output = output;
  memcpy((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size),
         sizeof(size_t[sizeof(output_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output_length = output_length;
}

void psa_cipher_decrypt_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_decrypt_CALL_INSTANCE));
  CMOCK_psa_cipher_decrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_decrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_decrypt_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_decrypt_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_cipher_decrypt(cmock_call_instance, key, alg, input, input_length, output, output_size, output_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_cipher_operation_t psa_cipher_operation_init(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_cipher_operation_init_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_cipher_operation_init);
  cmock_call_instance = (CMOCK_psa_cipher_operation_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_cipher_operation_init_CallInstance);
  Mock.psa_cipher_operation_init_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_operation_init_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void psa_cipher_operation_init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_cipher_operation_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_operation_init_CALL_INSTANCE));
  CMOCK_psa_cipher_operation_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_operation_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_operation_init_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_operation_init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_cipher_operation_t[sizeof(cmock_to_return) == sizeof(psa_cipher_operation_t) ? 1 : -1])); /* add psa_cipher_operation_t to :treat_as_array if this causes an error */
}

psa_status_t psa_cipher_encrypt_setup(psa_cipher_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_cipher_encrypt_setup_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_cipher_encrypt_setup);
  cmock_call_instance = (CMOCK_psa_cipher_encrypt_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_cipher_encrypt_setup_CallInstance);
  Mock.psa_cipher_encrypt_setup_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_encrypt_setup_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_encrypt_setup,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_cipher_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_encrypt_setup,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_encrypt_setup,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_cipher_encrypt_setup(CMOCK_psa_cipher_encrypt_setup_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg);
void CMockExpectParameters_psa_cipher_encrypt_setup(CMOCK_psa_cipher_encrypt_setup_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
}

void psa_cipher_encrypt_setup_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_cipher_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_encrypt_setup_CALL_INSTANCE));
  CMOCK_psa_cipher_encrypt_setup_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_encrypt_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_encrypt_setup_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_encrypt_setup_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_cipher_encrypt_setup(cmock_call_instance, operation, key, alg);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_cipher_decrypt_setup(psa_cipher_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_cipher_decrypt_setup_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_cipher_decrypt_setup);
  cmock_call_instance = (CMOCK_psa_cipher_decrypt_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_cipher_decrypt_setup_CallInstance);
  Mock.psa_cipher_decrypt_setup_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_decrypt_setup_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_decrypt_setup,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_cipher_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_decrypt_setup,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_decrypt_setup,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_cipher_decrypt_setup(CMOCK_psa_cipher_decrypt_setup_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg);
void CMockExpectParameters_psa_cipher_decrypt_setup(CMOCK_psa_cipher_decrypt_setup_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
}

void psa_cipher_decrypt_setup_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_cipher_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_decrypt_setup_CALL_INSTANCE));
  CMOCK_psa_cipher_decrypt_setup_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_decrypt_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_decrypt_setup_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_decrypt_setup_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_cipher_decrypt_setup(cmock_call_instance, operation, key, alg);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_cipher_generate_iv(psa_cipher_operation_t* operation, uint8_t* iv, size_t iv_size, size_t* iv_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_cipher_generate_iv_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_cipher_generate_iv);
  cmock_call_instance = (CMOCK_psa_cipher_generate_iv_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_cipher_generate_iv_CallInstance);
  Mock.psa_cipher_generate_iv_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_generate_iv_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_generate_iv,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_cipher_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_generate_iv,CMockString_iv);
    if (cmock_call_instance->Expected_iv == NULL)
      { UNITY_TEST_ASSERT_NULL(iv, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_iv, iv, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_generate_iv,CMockString_iv_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_iv_size), (void*)(&iv_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_generate_iv,CMockString_iv_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_iv_length), (void*)(iv_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_cipher_generate_iv(CMOCK_psa_cipher_generate_iv_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation, uint8_t* iv, size_t iv_size, size_t* iv_length);
void CMockExpectParameters_psa_cipher_generate_iv(CMOCK_psa_cipher_generate_iv_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation, uint8_t* iv, size_t iv_size, size_t* iv_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_iv = iv;
  memcpy((void*)(&cmock_call_instance->Expected_iv_size), (void*)(&iv_size),
         sizeof(size_t[sizeof(iv_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_iv_length = iv_length;
}

void psa_cipher_generate_iv_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_cipher_operation_t* operation, uint8_t* iv, size_t iv_size, size_t* iv_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_generate_iv_CALL_INSTANCE));
  CMOCK_psa_cipher_generate_iv_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_generate_iv_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_generate_iv_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_generate_iv_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_cipher_generate_iv(cmock_call_instance, operation, iv, iv_size, iv_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_cipher_set_iv(psa_cipher_operation_t* operation, const uint8_t* iv, size_t iv_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_cipher_set_iv_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_cipher_set_iv);
  cmock_call_instance = (CMOCK_psa_cipher_set_iv_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_cipher_set_iv_CallInstance);
  Mock.psa_cipher_set_iv_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_set_iv_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_set_iv,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_cipher_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_set_iv,CMockString_iv);
    if (cmock_call_instance->Expected_iv == NULL)
      { UNITY_TEST_ASSERT_NULL(iv, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_iv, iv, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_set_iv,CMockString_iv_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_iv_length), (void*)(&iv_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_cipher_set_iv(CMOCK_psa_cipher_set_iv_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation, const uint8_t* iv, size_t iv_length);
void CMockExpectParameters_psa_cipher_set_iv(CMOCK_psa_cipher_set_iv_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation, const uint8_t* iv, size_t iv_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_iv = iv;
  memcpy((void*)(&cmock_call_instance->Expected_iv_length), (void*)(&iv_length),
         sizeof(size_t[sizeof(iv_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_cipher_set_iv_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_cipher_operation_t* operation, const uint8_t* iv, size_t iv_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_set_iv_CALL_INSTANCE));
  CMOCK_psa_cipher_set_iv_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_set_iv_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_set_iv_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_set_iv_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_cipher_set_iv(cmock_call_instance, operation, iv, iv_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_cipher_update(psa_cipher_operation_t* operation, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_cipher_update_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_cipher_update);
  cmock_call_instance = (CMOCK_psa_cipher_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_cipher_update_CallInstance);
  Mock.psa_cipher_update_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_update_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_update,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_cipher_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_update,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_update,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_update,CMockString_output);
    if (cmock_call_instance->Expected_output == NULL)
      { UNITY_TEST_ASSERT_NULL(output, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_output, output, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_update,CMockString_output_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_update,CMockString_output_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_output_length), (void*)(output_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_cipher_update(CMOCK_psa_cipher_update_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length);
void CMockExpectParameters_psa_cipher_update(CMOCK_psa_cipher_update_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output = output;
  memcpy((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size),
         sizeof(size_t[sizeof(output_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output_length = output_length;
}

void psa_cipher_update_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_cipher_operation_t* operation, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_update_CALL_INSTANCE));
  CMOCK_psa_cipher_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_update_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_update_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_cipher_update(cmock_call_instance, operation, input, input_length, output, output_size, output_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_cipher_finish(psa_cipher_operation_t* operation, uint8_t* output, size_t output_size, size_t* output_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_cipher_finish_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_cipher_finish);
  cmock_call_instance = (CMOCK_psa_cipher_finish_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_cipher_finish_CallInstance);
  Mock.psa_cipher_finish_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_finish_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_finish,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_cipher_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_finish,CMockString_output);
    if (cmock_call_instance->Expected_output == NULL)
      { UNITY_TEST_ASSERT_NULL(output, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_output, output, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_finish,CMockString_output_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_finish,CMockString_output_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_output_length), (void*)(output_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_cipher_finish(CMOCK_psa_cipher_finish_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation, uint8_t* output, size_t output_size, size_t* output_length);
void CMockExpectParameters_psa_cipher_finish(CMOCK_psa_cipher_finish_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation, uint8_t* output, size_t output_size, size_t* output_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_output = output;
  memcpy((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size),
         sizeof(size_t[sizeof(output_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output_length = output_length;
}

void psa_cipher_finish_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_cipher_operation_t* operation, uint8_t* output, size_t output_size, size_t* output_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_finish_CALL_INSTANCE));
  CMOCK_psa_cipher_finish_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_finish_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_finish_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_finish_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_cipher_finish(cmock_call_instance, operation, output, output_size, output_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_cipher_abort(psa_cipher_operation_t* operation)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_cipher_abort_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_cipher_abort);
  cmock_call_instance = (CMOCK_psa_cipher_abort_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_cipher_abort_CallInstance);
  Mock.psa_cipher_abort_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_abort_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_abort,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_cipher_operation_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_cipher_abort(CMOCK_psa_cipher_abort_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation);
void CMockExpectParameters_psa_cipher_abort(CMOCK_psa_cipher_abort_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation)
{
  cmock_call_instance->Expected_operation = operation;
}

void psa_cipher_abort_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_cipher_operation_t* operation, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_abort_CALL_INSTANCE));
  CMOCK_psa_cipher_abort_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_abort_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_abort_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_abort_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_cipher_abort(cmock_call_instance, operation);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_aead_encrypt(psa_key_id_t key, psa_algorithm_t alg, const uint8_t* nonce, size_t nonce_length, const uint8_t* additional_data, size_t additional_data_length, const uint8_t* plaintext, size_t plaintext_length, uint8_t* ciphertext, size_t ciphertext_size, size_t* ciphertext_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_encrypt_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_encrypt);
  cmock_call_instance = (CMOCK_psa_aead_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_encrypt_CallInstance);
  Mock.psa_aead_encrypt_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_encrypt_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt,CMockString_nonce);
    if (cmock_call_instance->Expected_nonce == NULL)
      { UNITY_TEST_ASSERT_NULL(nonce, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_nonce, nonce, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt,CMockString_nonce_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_nonce_length), (void*)(&nonce_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt,CMockString_additional_data);
    if (cmock_call_instance->Expected_additional_data == NULL)
      { UNITY_TEST_ASSERT_NULL(additional_data, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_additional_data, additional_data, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt,CMockString_additional_data_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_additional_data_length), (void*)(&additional_data_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt,CMockString_plaintext);
    if (cmock_call_instance->Expected_plaintext == NULL)
      { UNITY_TEST_ASSERT_NULL(plaintext, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_plaintext, plaintext, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt,CMockString_plaintext_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_plaintext_length), (void*)(&plaintext_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt,CMockString_ciphertext);
    if (cmock_call_instance->Expected_ciphertext == NULL)
      { UNITY_TEST_ASSERT_NULL(ciphertext, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_ciphertext, ciphertext, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt,CMockString_ciphertext_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ciphertext_size), (void*)(&ciphertext_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt,CMockString_ciphertext_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_ciphertext_length), (void*)(ciphertext_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_aead_encrypt(CMOCK_psa_aead_encrypt_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* nonce, size_t nonce_length, const uint8_t* additional_data, size_t additional_data_length, const uint8_t* plaintext, size_t plaintext_length, uint8_t* ciphertext, size_t ciphertext_size, size_t* ciphertext_length);
void CMockExpectParameters_psa_aead_encrypt(CMOCK_psa_aead_encrypt_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* nonce, size_t nonce_length, const uint8_t* additional_data, size_t additional_data_length, const uint8_t* plaintext, size_t plaintext_length, uint8_t* ciphertext, size_t ciphertext_size, size_t* ciphertext_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_nonce = nonce;
  memcpy((void*)(&cmock_call_instance->Expected_nonce_length), (void*)(&nonce_length),
         sizeof(size_t[sizeof(nonce_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_additional_data = additional_data;
  memcpy((void*)(&cmock_call_instance->Expected_additional_data_length), (void*)(&additional_data_length),
         sizeof(size_t[sizeof(additional_data_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_plaintext = plaintext;
  memcpy((void*)(&cmock_call_instance->Expected_plaintext_length), (void*)(&plaintext_length),
         sizeof(size_t[sizeof(plaintext_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_ciphertext = ciphertext;
  memcpy((void*)(&cmock_call_instance->Expected_ciphertext_size), (void*)(&ciphertext_size),
         sizeof(size_t[sizeof(ciphertext_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_ciphertext_length = ciphertext_length;
}

void psa_aead_encrypt_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* nonce, size_t nonce_length, const uint8_t* additional_data, size_t additional_data_length, const uint8_t* plaintext, size_t plaintext_length, uint8_t* ciphertext, size_t ciphertext_size, size_t* ciphertext_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_encrypt_CALL_INSTANCE));
  CMOCK_psa_aead_encrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_encrypt_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_encrypt_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_aead_encrypt(cmock_call_instance, key, alg, nonce, nonce_length, additional_data, additional_data_length, plaintext, plaintext_length, ciphertext, ciphertext_size, ciphertext_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_aead_decrypt(psa_key_id_t key, psa_algorithm_t alg, const uint8_t* nonce, size_t nonce_length, const uint8_t* additional_data, size_t additional_data_length, const uint8_t* ciphertext, size_t ciphertext_length, uint8_t* plaintext, size_t plaintext_size, size_t* plaintext_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_decrypt_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_decrypt);
  cmock_call_instance = (CMOCK_psa_aead_decrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_decrypt_CallInstance);
  Mock.psa_aead_decrypt_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_decrypt_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt,CMockString_nonce);
    if (cmock_call_instance->Expected_nonce == NULL)
      { UNITY_TEST_ASSERT_NULL(nonce, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_nonce, nonce, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt,CMockString_nonce_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_nonce_length), (void*)(&nonce_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt,CMockString_additional_data);
    if (cmock_call_instance->Expected_additional_data == NULL)
      { UNITY_TEST_ASSERT_NULL(additional_data, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_additional_data, additional_data, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt,CMockString_additional_data_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_additional_data_length), (void*)(&additional_data_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt,CMockString_ciphertext);
    if (cmock_call_instance->Expected_ciphertext == NULL)
      { UNITY_TEST_ASSERT_NULL(ciphertext, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_ciphertext, ciphertext, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt,CMockString_ciphertext_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ciphertext_length), (void*)(&ciphertext_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt,CMockString_plaintext);
    if (cmock_call_instance->Expected_plaintext == NULL)
      { UNITY_TEST_ASSERT_NULL(plaintext, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_plaintext, plaintext, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt,CMockString_plaintext_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_plaintext_size), (void*)(&plaintext_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt,CMockString_plaintext_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_plaintext_length), (void*)(plaintext_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_aead_decrypt(CMOCK_psa_aead_decrypt_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* nonce, size_t nonce_length, const uint8_t* additional_data, size_t additional_data_length, const uint8_t* ciphertext, size_t ciphertext_length, uint8_t* plaintext, size_t plaintext_size, size_t* plaintext_length);
void CMockExpectParameters_psa_aead_decrypt(CMOCK_psa_aead_decrypt_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* nonce, size_t nonce_length, const uint8_t* additional_data, size_t additional_data_length, const uint8_t* ciphertext, size_t ciphertext_length, uint8_t* plaintext, size_t plaintext_size, size_t* plaintext_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_nonce = nonce;
  memcpy((void*)(&cmock_call_instance->Expected_nonce_length), (void*)(&nonce_length),
         sizeof(size_t[sizeof(nonce_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_additional_data = additional_data;
  memcpy((void*)(&cmock_call_instance->Expected_additional_data_length), (void*)(&additional_data_length),
         sizeof(size_t[sizeof(additional_data_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_ciphertext = ciphertext;
  memcpy((void*)(&cmock_call_instance->Expected_ciphertext_length), (void*)(&ciphertext_length),
         sizeof(size_t[sizeof(ciphertext_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_plaintext = plaintext;
  memcpy((void*)(&cmock_call_instance->Expected_plaintext_size), (void*)(&plaintext_size),
         sizeof(size_t[sizeof(plaintext_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_plaintext_length = plaintext_length;
}

void psa_aead_decrypt_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* nonce, size_t nonce_length, const uint8_t* additional_data, size_t additional_data_length, const uint8_t* ciphertext, size_t ciphertext_length, uint8_t* plaintext, size_t plaintext_size, size_t* plaintext_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_decrypt_CALL_INSTANCE));
  CMOCK_psa_aead_decrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_decrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_decrypt_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_decrypt_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_aead_decrypt(cmock_call_instance, key, alg, nonce, nonce_length, additional_data, additional_data_length, ciphertext, ciphertext_length, plaintext, plaintext_size, plaintext_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_aead_operation_t psa_aead_operation_init(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_operation_init_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_operation_init);
  cmock_call_instance = (CMOCK_psa_aead_operation_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_operation_init_CallInstance);
  Mock.psa_aead_operation_init_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_operation_init_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void psa_aead_operation_init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_aead_operation_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_operation_init_CALL_INSTANCE));
  CMOCK_psa_aead_operation_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_operation_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_operation_init_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_operation_init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_aead_operation_t[sizeof(cmock_to_return) == sizeof(psa_aead_operation_t) ? 1 : -1])); /* add psa_aead_operation_t to :treat_as_array if this causes an error */
}

psa_status_t psa_aead_encrypt_setup(psa_aead_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_encrypt_setup_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_encrypt_setup);
  cmock_call_instance = (CMOCK_psa_aead_encrypt_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_encrypt_setup_CallInstance);
  Mock.psa_aead_encrypt_setup_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_encrypt_setup_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt_setup,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_aead_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt_setup,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt_setup,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_aead_encrypt_setup(CMOCK_psa_aead_encrypt_setup_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg);
void CMockExpectParameters_psa_aead_encrypt_setup(CMOCK_psa_aead_encrypt_setup_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
}

void psa_aead_encrypt_setup_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_aead_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_encrypt_setup_CALL_INSTANCE));
  CMOCK_psa_aead_encrypt_setup_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_encrypt_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_encrypt_setup_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_encrypt_setup_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_aead_encrypt_setup(cmock_call_instance, operation, key, alg);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_aead_decrypt_setup(psa_aead_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_decrypt_setup_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_decrypt_setup);
  cmock_call_instance = (CMOCK_psa_aead_decrypt_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_decrypt_setup_CallInstance);
  Mock.psa_aead_decrypt_setup_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_decrypt_setup_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt_setup,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_aead_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt_setup,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt_setup,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_aead_decrypt_setup(CMOCK_psa_aead_decrypt_setup_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg);
void CMockExpectParameters_psa_aead_decrypt_setup(CMOCK_psa_aead_decrypt_setup_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
}

void psa_aead_decrypt_setup_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_aead_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_decrypt_setup_CALL_INSTANCE));
  CMOCK_psa_aead_decrypt_setup_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_decrypt_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_decrypt_setup_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_decrypt_setup_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_aead_decrypt_setup(cmock_call_instance, operation, key, alg);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_aead_generate_nonce(psa_aead_operation_t* operation, uint8_t* nonce, size_t nonce_size, size_t* nonce_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_generate_nonce_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_generate_nonce);
  cmock_call_instance = (CMOCK_psa_aead_generate_nonce_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_generate_nonce_CallInstance);
  Mock.psa_aead_generate_nonce_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_generate_nonce_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_generate_nonce,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_aead_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_generate_nonce,CMockString_nonce);
    if (cmock_call_instance->Expected_nonce == NULL)
      { UNITY_TEST_ASSERT_NULL(nonce, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_nonce, nonce, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_generate_nonce,CMockString_nonce_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_nonce_size), (void*)(&nonce_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_generate_nonce,CMockString_nonce_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_nonce_length), (void*)(nonce_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_aead_generate_nonce(CMOCK_psa_aead_generate_nonce_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, uint8_t* nonce, size_t nonce_size, size_t* nonce_length);
void CMockExpectParameters_psa_aead_generate_nonce(CMOCK_psa_aead_generate_nonce_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, uint8_t* nonce, size_t nonce_size, size_t* nonce_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_nonce = nonce;
  memcpy((void*)(&cmock_call_instance->Expected_nonce_size), (void*)(&nonce_size),
         sizeof(size_t[sizeof(nonce_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_nonce_length = nonce_length;
}

void psa_aead_generate_nonce_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_aead_operation_t* operation, uint8_t* nonce, size_t nonce_size, size_t* nonce_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_generate_nonce_CALL_INSTANCE));
  CMOCK_psa_aead_generate_nonce_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_generate_nonce_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_generate_nonce_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_generate_nonce_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_aead_generate_nonce(cmock_call_instance, operation, nonce, nonce_size, nonce_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_aead_set_nonce(psa_aead_operation_t* operation, const uint8_t* nonce, size_t nonce_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_set_nonce_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_set_nonce);
  cmock_call_instance = (CMOCK_psa_aead_set_nonce_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_set_nonce_CallInstance);
  Mock.psa_aead_set_nonce_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_set_nonce_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_set_nonce,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_aead_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_set_nonce,CMockString_nonce);
    if (cmock_call_instance->Expected_nonce == NULL)
      { UNITY_TEST_ASSERT_NULL(nonce, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_nonce, nonce, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_set_nonce,CMockString_nonce_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_nonce_length), (void*)(&nonce_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_aead_set_nonce(CMOCK_psa_aead_set_nonce_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, const uint8_t* nonce, size_t nonce_length);
void CMockExpectParameters_psa_aead_set_nonce(CMOCK_psa_aead_set_nonce_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, const uint8_t* nonce, size_t nonce_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_nonce = nonce;
  memcpy((void*)(&cmock_call_instance->Expected_nonce_length), (void*)(&nonce_length),
         sizeof(size_t[sizeof(nonce_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_aead_set_nonce_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_aead_operation_t* operation, const uint8_t* nonce, size_t nonce_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_set_nonce_CALL_INSTANCE));
  CMOCK_psa_aead_set_nonce_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_set_nonce_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_set_nonce_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_set_nonce_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_aead_set_nonce(cmock_call_instance, operation, nonce, nonce_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_aead_set_lengths(psa_aead_operation_t* operation, size_t ad_length, size_t plaintext_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_set_lengths_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_set_lengths);
  cmock_call_instance = (CMOCK_psa_aead_set_lengths_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_set_lengths_CallInstance);
  Mock.psa_aead_set_lengths_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_set_lengths_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_set_lengths,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_aead_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_set_lengths,CMockString_ad_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ad_length), (void*)(&ad_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_set_lengths,CMockString_plaintext_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_plaintext_length), (void*)(&plaintext_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_aead_set_lengths(CMOCK_psa_aead_set_lengths_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, size_t ad_length, size_t plaintext_length);
void CMockExpectParameters_psa_aead_set_lengths(CMOCK_psa_aead_set_lengths_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, size_t ad_length, size_t plaintext_length)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_ad_length), (void*)(&ad_length),
         sizeof(size_t[sizeof(ad_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_plaintext_length), (void*)(&plaintext_length),
         sizeof(size_t[sizeof(plaintext_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_aead_set_lengths_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_aead_operation_t* operation, size_t ad_length, size_t plaintext_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_set_lengths_CALL_INSTANCE));
  CMOCK_psa_aead_set_lengths_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_set_lengths_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_set_lengths_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_set_lengths_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_aead_set_lengths(cmock_call_instance, operation, ad_length, plaintext_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_aead_update_ad(psa_aead_operation_t* operation, const uint8_t* input, size_t input_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_update_ad_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_update_ad);
  cmock_call_instance = (CMOCK_psa_aead_update_ad_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_update_ad_CallInstance);
  Mock.psa_aead_update_ad_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_update_ad_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_update_ad,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_aead_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_update_ad,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_update_ad,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_aead_update_ad(CMOCK_psa_aead_update_ad_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, const uint8_t* input, size_t input_length);
void CMockExpectParameters_psa_aead_update_ad(CMOCK_psa_aead_update_ad_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, const uint8_t* input, size_t input_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_aead_update_ad_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_aead_operation_t* operation, const uint8_t* input, size_t input_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_update_ad_CALL_INSTANCE));
  CMOCK_psa_aead_update_ad_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_update_ad_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_update_ad_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_update_ad_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_aead_update_ad(cmock_call_instance, operation, input, input_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_aead_update(psa_aead_operation_t* operation, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_update_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_update);
  cmock_call_instance = (CMOCK_psa_aead_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_update_CallInstance);
  Mock.psa_aead_update_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_update_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_update,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_aead_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_update,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_update,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_update,CMockString_output);
    if (cmock_call_instance->Expected_output == NULL)
      { UNITY_TEST_ASSERT_NULL(output, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_output, output, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_update,CMockString_output_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_update,CMockString_output_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_output_length), (void*)(output_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_aead_update(CMOCK_psa_aead_update_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length);
void CMockExpectParameters_psa_aead_update(CMOCK_psa_aead_update_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output = output;
  memcpy((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size),
         sizeof(size_t[sizeof(output_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output_length = output_length;
}

void psa_aead_update_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_aead_operation_t* operation, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_update_CALL_INSTANCE));
  CMOCK_psa_aead_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_update_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_update_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_aead_update(cmock_call_instance, operation, input, input_length, output, output_size, output_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_aead_finish(psa_aead_operation_t* operation, uint8_t* ciphertext, size_t ciphertext_size, size_t* ciphertext_length, uint8_t* tag, size_t tag_size, size_t* tag_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_finish_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_finish);
  cmock_call_instance = (CMOCK_psa_aead_finish_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_finish_CallInstance);
  Mock.psa_aead_finish_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_finish_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_finish,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_aead_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_finish,CMockString_ciphertext);
    if (cmock_call_instance->Expected_ciphertext == NULL)
      { UNITY_TEST_ASSERT_NULL(ciphertext, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_ciphertext, ciphertext, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_finish,CMockString_ciphertext_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ciphertext_size), (void*)(&ciphertext_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_finish,CMockString_ciphertext_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_ciphertext_length), (void*)(ciphertext_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_finish,CMockString_tag);
    if (cmock_call_instance->Expected_tag == NULL)
      { UNITY_TEST_ASSERT_NULL(tag, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_tag, tag, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_finish,CMockString_tag_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_tag_size), (void*)(&tag_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_finish,CMockString_tag_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_tag_length), (void*)(tag_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_aead_finish(CMOCK_psa_aead_finish_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, uint8_t* ciphertext, size_t ciphertext_size, size_t* ciphertext_length, uint8_t* tag, size_t tag_size, size_t* tag_length);
void CMockExpectParameters_psa_aead_finish(CMOCK_psa_aead_finish_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, uint8_t* ciphertext, size_t ciphertext_size, size_t* ciphertext_length, uint8_t* tag, size_t tag_size, size_t* tag_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_ciphertext = ciphertext;
  memcpy((void*)(&cmock_call_instance->Expected_ciphertext_size), (void*)(&ciphertext_size),
         sizeof(size_t[sizeof(ciphertext_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_ciphertext_length = ciphertext_length;
  cmock_call_instance->Expected_tag = tag;
  memcpy((void*)(&cmock_call_instance->Expected_tag_size), (void*)(&tag_size),
         sizeof(size_t[sizeof(tag_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_tag_length = tag_length;
}

void psa_aead_finish_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_aead_operation_t* operation, uint8_t* ciphertext, size_t ciphertext_size, size_t* ciphertext_length, uint8_t* tag, size_t tag_size, size_t* tag_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_finish_CALL_INSTANCE));
  CMOCK_psa_aead_finish_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_finish_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_finish_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_finish_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_aead_finish(cmock_call_instance, operation, ciphertext, ciphertext_size, ciphertext_length, tag, tag_size, tag_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_aead_verify(psa_aead_operation_t* operation, uint8_t* plaintext, size_t plaintext_size, size_t* plaintext_length, const uint8_t* tag, size_t tag_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_verify_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_verify);
  cmock_call_instance = (CMOCK_psa_aead_verify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_verify_CallInstance);
  Mock.psa_aead_verify_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_verify_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_verify,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_aead_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_verify,CMockString_plaintext);
    if (cmock_call_instance->Expected_plaintext == NULL)
      { UNITY_TEST_ASSERT_NULL(plaintext, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_plaintext, plaintext, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_verify,CMockString_plaintext_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_plaintext_size), (void*)(&plaintext_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_verify,CMockString_plaintext_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_plaintext_length), (void*)(plaintext_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_verify,CMockString_tag);
    if (cmock_call_instance->Expected_tag == NULL)
      { UNITY_TEST_ASSERT_NULL(tag, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_tag, tag, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_verify,CMockString_tag_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_tag_length), (void*)(&tag_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_aead_verify(CMOCK_psa_aead_verify_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, uint8_t* plaintext, size_t plaintext_size, size_t* plaintext_length, const uint8_t* tag, size_t tag_length);
void CMockExpectParameters_psa_aead_verify(CMOCK_psa_aead_verify_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, uint8_t* plaintext, size_t plaintext_size, size_t* plaintext_length, const uint8_t* tag, size_t tag_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_plaintext = plaintext;
  memcpy((void*)(&cmock_call_instance->Expected_plaintext_size), (void*)(&plaintext_size),
         sizeof(size_t[sizeof(plaintext_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_plaintext_length = plaintext_length;
  cmock_call_instance->Expected_tag = tag;
  memcpy((void*)(&cmock_call_instance->Expected_tag_length), (void*)(&tag_length),
         sizeof(size_t[sizeof(tag_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_aead_verify_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_aead_operation_t* operation, uint8_t* plaintext, size_t plaintext_size, size_t* plaintext_length, const uint8_t* tag, size_t tag_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_verify_CALL_INSTANCE));
  CMOCK_psa_aead_verify_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_verify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_verify_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_verify_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_aead_verify(cmock_call_instance, operation, plaintext, plaintext_size, plaintext_length, tag, tag_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_aead_abort(psa_aead_operation_t* operation)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_abort_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_abort);
  cmock_call_instance = (CMOCK_psa_aead_abort_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_abort_CallInstance);
  Mock.psa_aead_abort_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_abort_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_abort,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_aead_operation_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_aead_abort(CMOCK_psa_aead_abort_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation);
void CMockExpectParameters_psa_aead_abort(CMOCK_psa_aead_abort_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation)
{
  cmock_call_instance->Expected_operation = operation;
}

void psa_aead_abort_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_aead_operation_t* operation, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_abort_CALL_INSTANCE));
  CMOCK_psa_aead_abort_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_abort_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_abort_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_abort_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_aead_abort(cmock_call_instance, operation);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_sign_message(psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* signature, size_t signature_size, size_t* signature_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_sign_message_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_sign_message);
  cmock_call_instance = (CMOCK_psa_sign_message_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_sign_message_CallInstance);
  Mock.psa_sign_message_CallInstance = CMock_Guts_MemNext(Mock.psa_sign_message_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_message,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_message,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_message,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_message,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_message,CMockString_signature);
    if (cmock_call_instance->Expected_signature == NULL)
      { UNITY_TEST_ASSERT_NULL(signature, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_signature, signature, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_message,CMockString_signature_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_signature_size), (void*)(&signature_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_message,CMockString_signature_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_signature_length), (void*)(signature_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_sign_message(CMOCK_psa_sign_message_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* signature, size_t signature_size, size_t* signature_length);
void CMockExpectParameters_psa_sign_message(CMOCK_psa_sign_message_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* signature, size_t signature_size, size_t* signature_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_signature = signature;
  memcpy((void*)(&cmock_call_instance->Expected_signature_size), (void*)(&signature_size),
         sizeof(size_t[sizeof(signature_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_signature_length = signature_length;
}

void psa_sign_message_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* signature, size_t signature_size, size_t* signature_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_sign_message_CALL_INSTANCE));
  CMOCK_psa_sign_message_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_sign_message_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_sign_message_CallInstance = CMock_Guts_MemChain(Mock.psa_sign_message_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_sign_message(cmock_call_instance, key, alg, input, input_length, signature, signature_size, signature_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_verify_message(psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* signature, size_t signature_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_verify_message_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_verify_message);
  cmock_call_instance = (CMOCK_psa_verify_message_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_verify_message_CallInstance);
  Mock.psa_verify_message_CallInstance = CMock_Guts_MemNext(Mock.psa_verify_message_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_verify_message,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_verify_message,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_verify_message,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_verify_message,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_verify_message,CMockString_signature);
    if (cmock_call_instance->Expected_signature == NULL)
      { UNITY_TEST_ASSERT_NULL(signature, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_signature, signature, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_verify_message,CMockString_signature_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_signature_length), (void*)(&signature_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_verify_message(CMOCK_psa_verify_message_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* signature, size_t signature_length);
void CMockExpectParameters_psa_verify_message(CMOCK_psa_verify_message_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* signature, size_t signature_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_signature = signature;
  memcpy((void*)(&cmock_call_instance->Expected_signature_length), (void*)(&signature_length),
         sizeof(size_t[sizeof(signature_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_verify_message_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* signature, size_t signature_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_verify_message_CALL_INSTANCE));
  CMOCK_psa_verify_message_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_verify_message_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_verify_message_CallInstance = CMock_Guts_MemChain(Mock.psa_verify_message_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_verify_message(cmock_call_instance, key, alg, input, input_length, signature, signature_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_sign_hash(psa_key_id_t key, psa_algorithm_t alg, const uint8_t* hash, size_t hash_length, uint8_t* signature, size_t signature_size, size_t* signature_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_sign_hash_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_sign_hash);
  cmock_call_instance = (CMOCK_psa_sign_hash_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_sign_hash_CallInstance);
  Mock.psa_sign_hash_CallInstance = CMock_Guts_MemNext(Mock.psa_sign_hash_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_hash,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_hash,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_hash,CMockString_hash);
    if (cmock_call_instance->Expected_hash == NULL)
      { UNITY_TEST_ASSERT_NULL(hash, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_hash, hash, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_hash,CMockString_hash_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_hash_length), (void*)(&hash_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_hash,CMockString_signature);
    if (cmock_call_instance->Expected_signature == NULL)
      { UNITY_TEST_ASSERT_NULL(signature, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_signature, signature, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_hash,CMockString_signature_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_signature_size), (void*)(&signature_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_hash,CMockString_signature_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_signature_length), (void*)(signature_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_sign_hash(CMOCK_psa_sign_hash_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* hash, size_t hash_length, uint8_t* signature, size_t signature_size, size_t* signature_length);
void CMockExpectParameters_psa_sign_hash(CMOCK_psa_sign_hash_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* hash, size_t hash_length, uint8_t* signature, size_t signature_size, size_t* signature_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_hash = hash;
  memcpy((void*)(&cmock_call_instance->Expected_hash_length), (void*)(&hash_length),
         sizeof(size_t[sizeof(hash_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_signature = signature;
  memcpy((void*)(&cmock_call_instance->Expected_signature_size), (void*)(&signature_size),
         sizeof(size_t[sizeof(signature_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_signature_length = signature_length;
}

void psa_sign_hash_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* hash, size_t hash_length, uint8_t* signature, size_t signature_size, size_t* signature_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_sign_hash_CALL_INSTANCE));
  CMOCK_psa_sign_hash_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_sign_hash_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_sign_hash_CallInstance = CMock_Guts_MemChain(Mock.psa_sign_hash_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_sign_hash(cmock_call_instance, key, alg, hash, hash_length, signature, signature_size, signature_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_verify_hash(psa_key_id_t key, psa_algorithm_t alg, const uint8_t* hash, size_t hash_length, const uint8_t* signature, size_t signature_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_verify_hash_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_verify_hash);
  cmock_call_instance = (CMOCK_psa_verify_hash_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_verify_hash_CallInstance);
  Mock.psa_verify_hash_CallInstance = CMock_Guts_MemNext(Mock.psa_verify_hash_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_verify_hash,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_verify_hash,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_verify_hash,CMockString_hash);
    if (cmock_call_instance->Expected_hash == NULL)
      { UNITY_TEST_ASSERT_NULL(hash, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_hash, hash, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_verify_hash,CMockString_hash_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_hash_length), (void*)(&hash_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_verify_hash,CMockString_signature);
    if (cmock_call_instance->Expected_signature == NULL)
      { UNITY_TEST_ASSERT_NULL(signature, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_signature, signature, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_verify_hash,CMockString_signature_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_signature_length), (void*)(&signature_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_verify_hash(CMOCK_psa_verify_hash_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* hash, size_t hash_length, const uint8_t* signature, size_t signature_length);
void CMockExpectParameters_psa_verify_hash(CMOCK_psa_verify_hash_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* hash, size_t hash_length, const uint8_t* signature, size_t signature_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_hash = hash;
  memcpy((void*)(&cmock_call_instance->Expected_hash_length), (void*)(&hash_length),
         sizeof(size_t[sizeof(hash_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_signature = signature;
  memcpy((void*)(&cmock_call_instance->Expected_signature_length), (void*)(&signature_length),
         sizeof(size_t[sizeof(signature_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_verify_hash_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* hash, size_t hash_length, const uint8_t* signature, size_t signature_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_verify_hash_CALL_INSTANCE));
  CMOCK_psa_verify_hash_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_verify_hash_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_verify_hash_CallInstance = CMock_Guts_MemChain(Mock.psa_verify_hash_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_verify_hash(cmock_call_instance, key, alg, hash, hash_length, signature, signature_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_asymmetric_encrypt(psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* salt, size_t salt_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_asymmetric_encrypt_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_asymmetric_encrypt);
  cmock_call_instance = (CMOCK_psa_asymmetric_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_asymmetric_encrypt_CallInstance);
  Mock.psa_asymmetric_encrypt_CallInstance = CMock_Guts_MemNext(Mock.psa_asymmetric_encrypt_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_encrypt,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_encrypt,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_encrypt,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_encrypt,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_encrypt,CMockString_salt);
    if (cmock_call_instance->Expected_salt == NULL)
      { UNITY_TEST_ASSERT_NULL(salt, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_salt, salt, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_encrypt,CMockString_salt_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_salt_length), (void*)(&salt_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_encrypt,CMockString_output);
    if (cmock_call_instance->Expected_output == NULL)
      { UNITY_TEST_ASSERT_NULL(output, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_output, output, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_encrypt,CMockString_output_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_encrypt,CMockString_output_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_output_length), (void*)(output_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_asymmetric_encrypt(CMOCK_psa_asymmetric_encrypt_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* salt, size_t salt_length, uint8_t* output, size_t output_size, size_t* output_length);
void CMockExpectParameters_psa_asymmetric_encrypt(CMOCK_psa_asymmetric_encrypt_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* salt, size_t salt_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_salt = salt;
  memcpy((void*)(&cmock_call_instance->Expected_salt_length), (void*)(&salt_length),
         sizeof(size_t[sizeof(salt_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output = output;
  memcpy((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size),
         sizeof(size_t[sizeof(output_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output_length = output_length;
}

void psa_asymmetric_encrypt_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* salt, size_t salt_length, uint8_t* output, size_t output_size, size_t* output_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_asymmetric_encrypt_CALL_INSTANCE));
  CMOCK_psa_asymmetric_encrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_asymmetric_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_asymmetric_encrypt_CallInstance = CMock_Guts_MemChain(Mock.psa_asymmetric_encrypt_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_asymmetric_encrypt(cmock_call_instance, key, alg, input, input_length, salt, salt_length, output, output_size, output_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_asymmetric_decrypt(psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* salt, size_t salt_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_asymmetric_decrypt_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_asymmetric_decrypt);
  cmock_call_instance = (CMOCK_psa_asymmetric_decrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_asymmetric_decrypt_CallInstance);
  Mock.psa_asymmetric_decrypt_CallInstance = CMock_Guts_MemNext(Mock.psa_asymmetric_decrypt_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_decrypt,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_decrypt,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_decrypt,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_decrypt,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_decrypt,CMockString_salt);
    if (cmock_call_instance->Expected_salt == NULL)
      { UNITY_TEST_ASSERT_NULL(salt, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_salt, salt, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_decrypt,CMockString_salt_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_salt_length), (void*)(&salt_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_decrypt,CMockString_output);
    if (cmock_call_instance->Expected_output == NULL)
      { UNITY_TEST_ASSERT_NULL(output, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_output, output, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_decrypt,CMockString_output_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_decrypt,CMockString_output_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_output_length), (void*)(output_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_asymmetric_decrypt(CMOCK_psa_asymmetric_decrypt_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* salt, size_t salt_length, uint8_t* output, size_t output_size, size_t* output_length);
void CMockExpectParameters_psa_asymmetric_decrypt(CMOCK_psa_asymmetric_decrypt_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* salt, size_t salt_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_salt = salt;
  memcpy((void*)(&cmock_call_instance->Expected_salt_length), (void*)(&salt_length),
         sizeof(size_t[sizeof(salt_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output = output;
  memcpy((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size),
         sizeof(size_t[sizeof(output_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output_length = output_length;
}

void psa_asymmetric_decrypt_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* salt, size_t salt_length, uint8_t* output, size_t output_size, size_t* output_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_asymmetric_decrypt_CALL_INSTANCE));
  CMOCK_psa_asymmetric_decrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_asymmetric_decrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_asymmetric_decrypt_CallInstance = CMock_Guts_MemChain(Mock.psa_asymmetric_decrypt_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_asymmetric_decrypt(cmock_call_instance, key, alg, input, input_length, salt, salt_length, output, output_size, output_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_key_derivation_operation_t psa_key_derivation_operation_init(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_operation_init_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_operation_init);
  cmock_call_instance = (CMOCK_psa_key_derivation_operation_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_operation_init_CallInstance);
  Mock.psa_key_derivation_operation_init_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_operation_init_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void psa_key_derivation_operation_init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_derivation_operation_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_operation_init_CALL_INSTANCE));
  CMOCK_psa_key_derivation_operation_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_operation_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_operation_init_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_operation_init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_key_derivation_operation_t[sizeof(cmock_to_return) == sizeof(psa_key_derivation_operation_t) ? 1 : -1])); /* add psa_key_derivation_operation_t to :treat_as_array if this causes an error */
}

psa_status_t psa_key_derivation_setup(psa_key_derivation_operation_t* operation, psa_algorithm_t alg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_setup_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_setup);
  cmock_call_instance = (CMOCK_psa_key_derivation_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_setup_CallInstance);
  Mock.psa_key_derivation_setup_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_setup_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_setup,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_key_derivation_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_setup,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_key_derivation_setup(CMOCK_psa_key_derivation_setup_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, psa_algorithm_t alg);
void CMockExpectParameters_psa_key_derivation_setup(CMOCK_psa_key_derivation_setup_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, psa_algorithm_t alg)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_setup_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_derivation_operation_t* operation, psa_algorithm_t alg, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_setup_CALL_INSTANCE));
  CMOCK_psa_key_derivation_setup_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_setup_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_setup_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_key_derivation_setup(cmock_call_instance, operation, alg);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_key_derivation_get_capacity(const psa_key_derivation_operation_t* operation, size_t* capacity)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_get_capacity_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_get_capacity);
  cmock_call_instance = (CMOCK_psa_key_derivation_get_capacity_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_get_capacity_CallInstance);
  Mock.psa_key_derivation_get_capacity_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_get_capacity_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_get_capacity,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(const psa_key_derivation_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_get_capacity,CMockString_capacity);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_capacity), (void*)(capacity), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_key_derivation_get_capacity(CMOCK_psa_key_derivation_get_capacity_CALL_INSTANCE* cmock_call_instance, const psa_key_derivation_operation_t* operation, size_t* capacity);
void CMockExpectParameters_psa_key_derivation_get_capacity(CMOCK_psa_key_derivation_get_capacity_CALL_INSTANCE* cmock_call_instance, const psa_key_derivation_operation_t* operation, size_t* capacity)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_capacity = capacity;
}

void psa_key_derivation_get_capacity_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const psa_key_derivation_operation_t* operation, size_t* capacity, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_get_capacity_CALL_INSTANCE));
  CMOCK_psa_key_derivation_get_capacity_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_get_capacity_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_get_capacity_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_get_capacity_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_key_derivation_get_capacity(cmock_call_instance, operation, capacity);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_key_derivation_set_capacity(psa_key_derivation_operation_t* operation, size_t capacity)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_set_capacity_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_set_capacity);
  cmock_call_instance = (CMOCK_psa_key_derivation_set_capacity_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_set_capacity_CallInstance);
  Mock.psa_key_derivation_set_capacity_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_set_capacity_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_set_capacity,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_key_derivation_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_set_capacity,CMockString_capacity);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_capacity), (void*)(&capacity), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_key_derivation_set_capacity(CMOCK_psa_key_derivation_set_capacity_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, size_t capacity);
void CMockExpectParameters_psa_key_derivation_set_capacity(CMOCK_psa_key_derivation_set_capacity_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, size_t capacity)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_capacity), (void*)(&capacity),
         sizeof(size_t[sizeof(capacity) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_set_capacity_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_derivation_operation_t* operation, size_t capacity, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_set_capacity_CALL_INSTANCE));
  CMOCK_psa_key_derivation_set_capacity_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_set_capacity_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_set_capacity_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_set_capacity_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_key_derivation_set_capacity(cmock_call_instance, operation, capacity);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_key_derivation_input_bytes(psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, const uint8_t* data, size_t data_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_input_bytes_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_input_bytes);
  cmock_call_instance = (CMOCK_psa_key_derivation_input_bytes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_input_bytes_CallInstance);
  Mock.psa_key_derivation_input_bytes_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_input_bytes_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_input_bytes,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_key_derivation_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_input_bytes,CMockString_step);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_step), (void*)(&step), sizeof(psa_key_derivation_step_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_input_bytes,CMockString_data);
    if (cmock_call_instance->Expected_data == NULL)
      { UNITY_TEST_ASSERT_NULL(data, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_data, data, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_input_bytes,CMockString_data_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_data_length), (void*)(&data_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_key_derivation_input_bytes(CMOCK_psa_key_derivation_input_bytes_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, const uint8_t* data, size_t data_length);
void CMockExpectParameters_psa_key_derivation_input_bytes(CMOCK_psa_key_derivation_input_bytes_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, const uint8_t* data, size_t data_length)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_step), (void*)(&step),
         sizeof(psa_key_derivation_step_t[sizeof(step) == sizeof(psa_key_derivation_step_t) ? 1 : -1])); /* add psa_key_derivation_step_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_data = data;
  memcpy((void*)(&cmock_call_instance->Expected_data_length), (void*)(&data_length),
         sizeof(size_t[sizeof(data_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_input_bytes_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, const uint8_t* data, size_t data_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_input_bytes_CALL_INSTANCE));
  CMOCK_psa_key_derivation_input_bytes_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_input_bytes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_input_bytes_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_input_bytes_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_key_derivation_input_bytes(cmock_call_instance, operation, step, data, data_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_key_derivation_input_integer(psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, uint64_t value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_input_integer_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_input_integer);
  cmock_call_instance = (CMOCK_psa_key_derivation_input_integer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_input_integer_CallInstance);
  Mock.psa_key_derivation_input_integer_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_input_integer_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_input_integer,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_key_derivation_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_input_integer,CMockString_step);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_step), (void*)(&step), sizeof(psa_key_derivation_step_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_input_integer,CMockString_value);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_value), (void*)(&value), sizeof(uint64_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_key_derivation_input_integer(CMOCK_psa_key_derivation_input_integer_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, uint64_t value);
void CMockExpectParameters_psa_key_derivation_input_integer(CMOCK_psa_key_derivation_input_integer_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, uint64_t value)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_step), (void*)(&step),
         sizeof(psa_key_derivation_step_t[sizeof(step) == sizeof(psa_key_derivation_step_t) ? 1 : -1])); /* add psa_key_derivation_step_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_value), (void*)(&value),
         sizeof(uint64_t[sizeof(value) == sizeof(uint64_t) ? 1 : -1])); /* add uint64_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_input_integer_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, uint64_t value, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_input_integer_CALL_INSTANCE));
  CMOCK_psa_key_derivation_input_integer_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_input_integer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_input_integer_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_input_integer_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_key_derivation_input_integer(cmock_call_instance, operation, step, value);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_key_derivation_input_key(psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, psa_key_id_t key)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_input_key_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_input_key);
  cmock_call_instance = (CMOCK_psa_key_derivation_input_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_input_key_CallInstance);
  Mock.psa_key_derivation_input_key_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_input_key_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_input_key,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_key_derivation_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_input_key,CMockString_step);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_step), (void*)(&step), sizeof(psa_key_derivation_step_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_input_key,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_key_derivation_input_key(CMOCK_psa_key_derivation_input_key_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, psa_key_id_t key);
void CMockExpectParameters_psa_key_derivation_input_key(CMOCK_psa_key_derivation_input_key_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, psa_key_id_t key)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_step), (void*)(&step),
         sizeof(psa_key_derivation_step_t[sizeof(step) == sizeof(psa_key_derivation_step_t) ? 1 : -1])); /* add psa_key_derivation_step_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_input_key_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, psa_key_id_t key, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_input_key_CALL_INSTANCE));
  CMOCK_psa_key_derivation_input_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_input_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_input_key_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_input_key_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_key_derivation_input_key(cmock_call_instance, operation, step, key);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_key_derivation_key_agreement(psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, psa_key_id_t private_key, const uint8_t* peer_key, size_t peer_key_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_key_agreement_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_key_agreement);
  cmock_call_instance = (CMOCK_psa_key_derivation_key_agreement_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_key_agreement_CallInstance);
  Mock.psa_key_derivation_key_agreement_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_key_agreement_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_key_agreement,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_key_derivation_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_key_agreement,CMockString_step);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_step), (void*)(&step), sizeof(psa_key_derivation_step_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_key_agreement,CMockString_private_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_private_key), (void*)(&private_key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_key_agreement,CMockString_peer_key);
    if (cmock_call_instance->Expected_peer_key == NULL)
      { UNITY_TEST_ASSERT_NULL(peer_key, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_peer_key, peer_key, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_key_agreement,CMockString_peer_key_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_peer_key_length), (void*)(&peer_key_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_key_derivation_key_agreement(CMOCK_psa_key_derivation_key_agreement_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, psa_key_id_t private_key, const uint8_t* peer_key, size_t peer_key_length);
void CMockExpectParameters_psa_key_derivation_key_agreement(CMOCK_psa_key_derivation_key_agreement_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, psa_key_id_t private_key, const uint8_t* peer_key, size_t peer_key_length)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_step), (void*)(&step),
         sizeof(psa_key_derivation_step_t[sizeof(step) == sizeof(psa_key_derivation_step_t) ? 1 : -1])); /* add psa_key_derivation_step_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_private_key), (void*)(&private_key),
         sizeof(psa_key_id_t[sizeof(private_key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_peer_key = peer_key;
  memcpy((void*)(&cmock_call_instance->Expected_peer_key_length), (void*)(&peer_key_length),
         sizeof(size_t[sizeof(peer_key_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_key_agreement_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, psa_key_id_t private_key, const uint8_t* peer_key, size_t peer_key_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_key_agreement_CALL_INSTANCE));
  CMOCK_psa_key_derivation_key_agreement_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_key_agreement_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_key_agreement_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_key_agreement_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_key_derivation_key_agreement(cmock_call_instance, operation, step, private_key, peer_key, peer_key_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_key_derivation_output_bytes(psa_key_derivation_operation_t* operation, uint8_t* output, size_t output_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_output_bytes_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_output_bytes);
  cmock_call_instance = (CMOCK_psa_key_derivation_output_bytes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_output_bytes_CallInstance);
  Mock.psa_key_derivation_output_bytes_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_output_bytes_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_output_bytes,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_key_derivation_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_output_bytes,CMockString_output);
    if (cmock_call_instance->Expected_output == NULL)
      { UNITY_TEST_ASSERT_NULL(output, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_output, output, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_output_bytes,CMockString_output_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_output_length), (void*)(&output_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_key_derivation_output_bytes(CMOCK_psa_key_derivation_output_bytes_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, uint8_t* output, size_t output_length);
void CMockExpectParameters_psa_key_derivation_output_bytes(CMOCK_psa_key_derivation_output_bytes_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, uint8_t* output, size_t output_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_output = output;
  memcpy((void*)(&cmock_call_instance->Expected_output_length), (void*)(&output_length),
         sizeof(size_t[sizeof(output_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_output_bytes_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_derivation_operation_t* operation, uint8_t* output, size_t output_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_output_bytes_CALL_INSTANCE));
  CMOCK_psa_key_derivation_output_bytes_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_output_bytes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_output_bytes_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_output_bytes_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_key_derivation_output_bytes(cmock_call_instance, operation, output, output_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_key_derivation_output_key(const psa_key_attributes_t* attributes, psa_key_derivation_operation_t* operation, psa_key_id_t* key)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_output_key_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_output_key);
  cmock_call_instance = (CMOCK_psa_key_derivation_output_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_output_key_CallInstance);
  Mock.psa_key_derivation_output_key_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_output_key_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_output_key,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(const psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_output_key,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_key_derivation_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_output_key,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_key), (void*)(key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_key_derivation_output_key(CMOCK_psa_key_derivation_output_key_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes, psa_key_derivation_operation_t* operation, psa_key_id_t* key);
void CMockExpectParameters_psa_key_derivation_output_key(CMOCK_psa_key_derivation_output_key_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes, psa_key_derivation_operation_t* operation, psa_key_id_t* key)
{
  cmock_call_instance->Expected_attributes = attributes;
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_key = key;
}

void psa_key_derivation_output_key_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const psa_key_attributes_t* attributes, psa_key_derivation_operation_t* operation, psa_key_id_t* key, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_output_key_CALL_INSTANCE));
  CMOCK_psa_key_derivation_output_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_output_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_output_key_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_output_key_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_key_derivation_output_key(cmock_call_instance, attributes, operation, key);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_key_derivation_verify_bytes(psa_key_derivation_operation_t* operation, const uint8_t* expected_output, size_t output_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_verify_bytes_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_verify_bytes);
  cmock_call_instance = (CMOCK_psa_key_derivation_verify_bytes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_verify_bytes_CallInstance);
  Mock.psa_key_derivation_verify_bytes_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_verify_bytes_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_verify_bytes,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_key_derivation_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_verify_bytes,CMockString_expected_output);
    if (cmock_call_instance->Expected_expected_output == NULL)
      { UNITY_TEST_ASSERT_NULL(expected_output, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_expected_output, expected_output, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_verify_bytes,CMockString_output_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_output_length), (void*)(&output_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_key_derivation_verify_bytes(CMOCK_psa_key_derivation_verify_bytes_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, const uint8_t* expected_output, size_t output_length);
void CMockExpectParameters_psa_key_derivation_verify_bytes(CMOCK_psa_key_derivation_verify_bytes_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, const uint8_t* expected_output, size_t output_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_expected_output = expected_output;
  memcpy((void*)(&cmock_call_instance->Expected_output_length), (void*)(&output_length),
         sizeof(size_t[sizeof(output_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_verify_bytes_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_derivation_operation_t* operation, const uint8_t* expected_output, size_t output_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_verify_bytes_CALL_INSTANCE));
  CMOCK_psa_key_derivation_verify_bytes_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_verify_bytes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_verify_bytes_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_verify_bytes_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_key_derivation_verify_bytes(cmock_call_instance, operation, expected_output, output_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_key_derivation_verify_key(psa_key_derivation_operation_t* operation, psa_key_id_t expected)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_verify_key_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_verify_key);
  cmock_call_instance = (CMOCK_psa_key_derivation_verify_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_verify_key_CallInstance);
  Mock.psa_key_derivation_verify_key_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_verify_key_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_verify_key,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_key_derivation_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_verify_key,CMockString_expected);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_expected), (void*)(&expected), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_key_derivation_verify_key(CMOCK_psa_key_derivation_verify_key_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, psa_key_id_t expected);
void CMockExpectParameters_psa_key_derivation_verify_key(CMOCK_psa_key_derivation_verify_key_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, psa_key_id_t expected)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_expected), (void*)(&expected),
         sizeof(psa_key_id_t[sizeof(expected) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_verify_key_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_derivation_operation_t* operation, psa_key_id_t expected, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_verify_key_CALL_INSTANCE));
  CMOCK_psa_key_derivation_verify_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_verify_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_verify_key_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_verify_key_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_key_derivation_verify_key(cmock_call_instance, operation, expected);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_key_derivation_abort(psa_key_derivation_operation_t* operation)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_abort_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_abort);
  cmock_call_instance = (CMOCK_psa_key_derivation_abort_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_abort_CallInstance);
  Mock.psa_key_derivation_abort_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_abort_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_abort,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_key_derivation_operation_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_key_derivation_abort(CMOCK_psa_key_derivation_abort_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation);
void CMockExpectParameters_psa_key_derivation_abort(CMOCK_psa_key_derivation_abort_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation)
{
  cmock_call_instance->Expected_operation = operation;
}

void psa_key_derivation_abort_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_derivation_operation_t* operation, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_abort_CALL_INSTANCE));
  CMOCK_psa_key_derivation_abort_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_abort_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_abort_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_abort_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_key_derivation_abort(cmock_call_instance, operation);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_raw_key_agreement(psa_algorithm_t alg, psa_key_id_t private_key, const uint8_t* peer_key, size_t peer_key_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_raw_key_agreement_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_raw_key_agreement);
  cmock_call_instance = (CMOCK_psa_raw_key_agreement_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_raw_key_agreement_CallInstance);
  Mock.psa_raw_key_agreement_CallInstance = CMock_Guts_MemNext(Mock.psa_raw_key_agreement_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_raw_key_agreement,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_raw_key_agreement,CMockString_private_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_private_key), (void*)(&private_key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_raw_key_agreement,CMockString_peer_key);
    if (cmock_call_instance->Expected_peer_key == NULL)
      { UNITY_TEST_ASSERT_NULL(peer_key, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_peer_key, peer_key, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_raw_key_agreement,CMockString_peer_key_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_peer_key_length), (void*)(&peer_key_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_raw_key_agreement,CMockString_output);
    if (cmock_call_instance->Expected_output == NULL)
      { UNITY_TEST_ASSERT_NULL(output, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_output, output, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_raw_key_agreement,CMockString_output_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_raw_key_agreement,CMockString_output_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_output_length), (void*)(output_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_raw_key_agreement(CMOCK_psa_raw_key_agreement_CALL_INSTANCE* cmock_call_instance, psa_algorithm_t alg, psa_key_id_t private_key, const uint8_t* peer_key, size_t peer_key_length, uint8_t* output, size_t output_size, size_t* output_length);
void CMockExpectParameters_psa_raw_key_agreement(CMOCK_psa_raw_key_agreement_CALL_INSTANCE* cmock_call_instance, psa_algorithm_t alg, psa_key_id_t private_key, const uint8_t* peer_key, size_t peer_key_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_private_key), (void*)(&private_key),
         sizeof(psa_key_id_t[sizeof(private_key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_peer_key = peer_key;
  memcpy((void*)(&cmock_call_instance->Expected_peer_key_length), (void*)(&peer_key_length),
         sizeof(size_t[sizeof(peer_key_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output = output;
  memcpy((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size),
         sizeof(size_t[sizeof(output_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output_length = output_length;
}

void psa_raw_key_agreement_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_algorithm_t alg, psa_key_id_t private_key, const uint8_t* peer_key, size_t peer_key_length, uint8_t* output, size_t output_size, size_t* output_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_raw_key_agreement_CALL_INSTANCE));
  CMOCK_psa_raw_key_agreement_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_raw_key_agreement_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_raw_key_agreement_CallInstance = CMock_Guts_MemChain(Mock.psa_raw_key_agreement_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_raw_key_agreement(cmock_call_instance, alg, private_key, peer_key, peer_key_length, output, output_size, output_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_generate_random(uint8_t* output, size_t output_size)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_generate_random_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_generate_random);
  cmock_call_instance = (CMOCK_psa_generate_random_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_generate_random_CallInstance);
  Mock.psa_generate_random_CallInstance = CMock_Guts_MemNext(Mock.psa_generate_random_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_generate_random,CMockString_output);
    if (cmock_call_instance->Expected_output == NULL)
      { UNITY_TEST_ASSERT_NULL(output, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_output, output, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_generate_random,CMockString_output_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_generate_random(CMOCK_psa_generate_random_CALL_INSTANCE* cmock_call_instance, uint8_t* output, size_t output_size);
void CMockExpectParameters_psa_generate_random(CMOCK_psa_generate_random_CALL_INSTANCE* cmock_call_instance, uint8_t* output, size_t output_size)
{
  cmock_call_instance->Expected_output = output;
  memcpy((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size),
         sizeof(size_t[sizeof(output_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_generate_random_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* output, size_t output_size, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_generate_random_CALL_INSTANCE));
  CMOCK_psa_generate_random_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_generate_random_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_generate_random_CallInstance = CMock_Guts_MemChain(Mock.psa_generate_random_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_generate_random(cmock_call_instance, output, output_size);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

psa_status_t psa_generate_key(const psa_key_attributes_t* attributes, psa_key_id_t* key)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_generate_key_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_generate_key);
  cmock_call_instance = (CMOCK_psa_generate_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_generate_key_CallInstance);
  Mock.psa_generate_key_CallInstance = CMock_Guts_MemNext(Mock.psa_generate_key_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_generate_key,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(const psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_generate_key,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_key), (void*)(key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_generate_key(CMOCK_psa_generate_key_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes, psa_key_id_t* key);
void CMockExpectParameters_psa_generate_key(CMOCK_psa_generate_key_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes, psa_key_id_t* key)
{
  cmock_call_instance->Expected_attributes = attributes;
  cmock_call_instance->Expected_key = key;
}

void psa_generate_key_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const psa_key_attributes_t* attributes, psa_key_id_t* key, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_generate_key_CALL_INSTANCE));
  CMOCK_psa_generate_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_generate_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_generate_key_CallInstance = CMock_Guts_MemChain(Mock.psa_generate_key_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_generate_key(cmock_call_instance, attributes, key);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

