/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "mock_crypto.h"

static const char* CMockString_ad_length = "ad_length";
static const char* CMockString_additional_data = "additional_data";
static const char* CMockString_additional_data_length = "additional_data_length";
static const char* CMockString_alg = "alg";
static const char* CMockString_attributes = "attributes";
static const char* CMockString_bits = "bits";
static const char* CMockString_capacity = "capacity";
static const char* CMockString_ciphertext = "ciphertext";
static const char* CMockString_ciphertext_length = "ciphertext_length";
static const char* CMockString_ciphertext_size = "ciphertext_size";
static const char* CMockString_data = "data";
static const char* CMockString_data_length = "data_length";
static const char* CMockString_data_size = "data_size";
static const char* CMockString_expected = "expected";
static const char* CMockString_expected_output = "expected_output";
static const char* CMockString_hash = "hash";
static const char* CMockString_hash_length = "hash_length";
static const char* CMockString_hash_size = "hash_size";
static const char* CMockString_input = "input";
static const char* CMockString_input_length = "input_length";
static const char* CMockString_iv = "iv";
static const char* CMockString_iv_length = "iv_length";
static const char* CMockString_iv_size = "iv_size";
static const char* CMockString_key = "key";
static const char* CMockString_lifetime = "lifetime";
static const char* CMockString_mac = "mac";
static const char* CMockString_mac_length = "mac_length";
static const char* CMockString_mac_size = "mac_size";
static const char* CMockString_nonce = "nonce";
static const char* CMockString_nonce_length = "nonce_length";
static const char* CMockString_nonce_size = "nonce_size";
static const char* CMockString_operation = "operation";
static const char* CMockString_output = "output";
static const char* CMockString_output_length = "output_length";
static const char* CMockString_output_size = "output_size";
static const char* CMockString_peer_key = "peer_key";
static const char* CMockString_peer_key_length = "peer_key_length";
static const char* CMockString_plaintext = "plaintext";
static const char* CMockString_plaintext_length = "plaintext_length";
static const char* CMockString_plaintext_size = "plaintext_size";
static const char* CMockString_private_key = "private_key";
static const char* CMockString_psa_aead_abort = "psa_aead_abort";
static const char* CMockString_psa_aead_decrypt = "psa_aead_decrypt";
static const char* CMockString_psa_aead_decrypt_setup = "psa_aead_decrypt_setup";
static const char* CMockString_psa_aead_encrypt = "psa_aead_encrypt";
static const char* CMockString_psa_aead_encrypt_setup = "psa_aead_encrypt_setup";
static const char* CMockString_psa_aead_finish = "psa_aead_finish";
static const char* CMockString_psa_aead_generate_nonce = "psa_aead_generate_nonce";
static const char* CMockString_psa_aead_operation_init = "psa_aead_operation_init";
static const char* CMockString_psa_aead_set_lengths = "psa_aead_set_lengths";
static const char* CMockString_psa_aead_set_nonce = "psa_aead_set_nonce";
static const char* CMockString_psa_aead_update = "psa_aead_update";
static const char* CMockString_psa_aead_update_ad = "psa_aead_update_ad";
static const char* CMockString_psa_aead_verify = "psa_aead_verify";
static const char* CMockString_psa_asymmetric_decrypt = "psa_asymmetric_decrypt";
static const char* CMockString_psa_asymmetric_encrypt = "psa_asymmetric_encrypt";
static const char* CMockString_psa_cipher_abort = "psa_cipher_abort";
static const char* CMockString_psa_cipher_decrypt = "psa_cipher_decrypt";
static const char* CMockString_psa_cipher_decrypt_setup = "psa_cipher_decrypt_setup";
static const char* CMockString_psa_cipher_encrypt = "psa_cipher_encrypt";
static const char* CMockString_psa_cipher_encrypt_setup = "psa_cipher_encrypt_setup";
static const char* CMockString_psa_cipher_finish = "psa_cipher_finish";
static const char* CMockString_psa_cipher_generate_iv = "psa_cipher_generate_iv";
static const char* CMockString_psa_cipher_operation_init = "psa_cipher_operation_init";
static const char* CMockString_psa_cipher_set_iv = "psa_cipher_set_iv";
static const char* CMockString_psa_cipher_update = "psa_cipher_update";
static const char* CMockString_psa_copy_key = "psa_copy_key";
static const char* CMockString_psa_crypto_init = "psa_crypto_init";
static const char* CMockString_psa_destroy_key = "psa_destroy_key";
static const char* CMockString_psa_export_key = "psa_export_key";
static const char* CMockString_psa_export_public_key = "psa_export_public_key";
static const char* CMockString_psa_generate_key = "psa_generate_key";
static const char* CMockString_psa_generate_random = "psa_generate_random";
static const char* CMockString_psa_get_key_algorithm = "psa_get_key_algorithm";
static const char* CMockString_psa_get_key_attributes = "psa_get_key_attributes";
static const char* CMockString_psa_get_key_bits = "psa_get_key_bits";
static const char* CMockString_psa_get_key_id = "psa_get_key_id";
static const char* CMockString_psa_get_key_lifetime = "psa_get_key_lifetime";
static const char* CMockString_psa_get_key_type = "psa_get_key_type";
static const char* CMockString_psa_get_key_usage_flags = "psa_get_key_usage_flags";
static const char* CMockString_psa_hash_abort = "psa_hash_abort";
static const char* CMockString_psa_hash_clone = "psa_hash_clone";
static const char* CMockString_psa_hash_compare = "psa_hash_compare";
static const char* CMockString_psa_hash_compute = "psa_hash_compute";
static const char* CMockString_psa_hash_finish = "psa_hash_finish";
static const char* CMockString_psa_hash_operation_init = "psa_hash_operation_init";
static const char* CMockString_psa_hash_setup = "psa_hash_setup";
static const char* CMockString_psa_hash_update = "psa_hash_update";
static const char* CMockString_psa_hash_verify = "psa_hash_verify";
static const char* CMockString_psa_import_key = "psa_import_key";
static const char* CMockString_psa_key_attributes_init = "psa_key_attributes_init";
static const char* CMockString_psa_key_derivation_abort = "psa_key_derivation_abort";
static const char* CMockString_psa_key_derivation_get_capacity = "psa_key_derivation_get_capacity";
static const char* CMockString_psa_key_derivation_input_bytes = "psa_key_derivation_input_bytes";
static const char* CMockString_psa_key_derivation_input_integer = "psa_key_derivation_input_integer";
static const char* CMockString_psa_key_derivation_input_key = "psa_key_derivation_input_key";
static const char* CMockString_psa_key_derivation_key_agreement = "psa_key_derivation_key_agreement";
static const char* CMockString_psa_key_derivation_operation_init = "psa_key_derivation_operation_init";
static const char* CMockString_psa_key_derivation_output_bytes = "psa_key_derivation_output_bytes";
static const char* CMockString_psa_key_derivation_output_key = "psa_key_derivation_output_key";
static const char* CMockString_psa_key_derivation_set_capacity = "psa_key_derivation_set_capacity";
static const char* CMockString_psa_key_derivation_setup = "psa_key_derivation_setup";
static const char* CMockString_psa_key_derivation_verify_bytes = "psa_key_derivation_verify_bytes";
static const char* CMockString_psa_key_derivation_verify_key = "psa_key_derivation_verify_key";
static const char* CMockString_psa_mac_abort = "psa_mac_abort";
static const char* CMockString_psa_mac_compute = "psa_mac_compute";
static const char* CMockString_psa_mac_operation_init = "psa_mac_operation_init";
static const char* CMockString_psa_mac_sign_finish = "psa_mac_sign_finish";
static const char* CMockString_psa_mac_sign_setup = "psa_mac_sign_setup";
static const char* CMockString_psa_mac_update = "psa_mac_update";
static const char* CMockString_psa_mac_verify = "psa_mac_verify";
static const char* CMockString_psa_mac_verify_finish = "psa_mac_verify_finish";
static const char* CMockString_psa_mac_verify_setup = "psa_mac_verify_setup";
static const char* CMockString_psa_purge_key = "psa_purge_key";
static const char* CMockString_psa_raw_key_agreement = "psa_raw_key_agreement";
static const char* CMockString_psa_reset_key_attributes = "psa_reset_key_attributes";
static const char* CMockString_psa_set_key_algorithm = "psa_set_key_algorithm";
static const char* CMockString_psa_set_key_bits = "psa_set_key_bits";
static const char* CMockString_psa_set_key_id = "psa_set_key_id";
static const char* CMockString_psa_set_key_lifetime = "psa_set_key_lifetime";
static const char* CMockString_psa_set_key_type = "psa_set_key_type";
static const char* CMockString_psa_set_key_usage_flags = "psa_set_key_usage_flags";
static const char* CMockString_psa_sign_hash = "psa_sign_hash";
static const char* CMockString_psa_sign_message = "psa_sign_message";
static const char* CMockString_psa_verify_hash = "psa_verify_hash";
static const char* CMockString_psa_verify_message = "psa_verify_message";
static const char* CMockString_salt = "salt";
static const char* CMockString_salt_length = "salt_length";
static const char* CMockString_signature = "signature";
static const char* CMockString_signature_length = "signature_length";
static const char* CMockString_signature_size = "signature_size";
static const char* CMockString_source_key = "source_key";
static const char* CMockString_source_operation = "source_operation";
static const char* CMockString_step = "step";
static const char* CMockString_tag = "tag";
static const char* CMockString_tag_length = "tag_length";
static const char* CMockString_tag_size = "tag_size";
static const char* CMockString_target_key = "target_key";
static const char* CMockString_target_operation = "target_operation";
static const char* CMockString_type = "type";
static const char* CMockString_usage_flags = "usage_flags";
static const char* CMockString_value = "value";

typedef struct _CMOCK_psa_crypto_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;

} CMOCK_psa_crypto_init_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_attributes_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_attributes_t ReturnVal;

} CMOCK_psa_key_attributes_init_CALL_INSTANCE;

typedef struct _CMOCK_psa_set_key_id_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_attributes_t* Expected_attributes;
  psa_key_id_t Expected_key;

} CMOCK_psa_set_key_id_CALL_INSTANCE;

typedef struct _CMOCK_psa_set_key_lifetime_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_attributes_t* Expected_attributes;
  psa_key_lifetime_t Expected_lifetime;

} CMOCK_psa_set_key_lifetime_CALL_INSTANCE;

typedef struct _CMOCK_psa_get_key_id_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_id_t ReturnVal;
  const psa_key_attributes_t* Expected_attributes;

} CMOCK_psa_get_key_id_CALL_INSTANCE;

typedef struct _CMOCK_psa_get_key_lifetime_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_lifetime_t ReturnVal;
  const psa_key_attributes_t* Expected_attributes;

} CMOCK_psa_get_key_lifetime_CALL_INSTANCE;

typedef struct _CMOCK_psa_set_key_usage_flags_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_attributes_t* Expected_attributes;
  psa_key_usage_t Expected_usage_flags;

} CMOCK_psa_set_key_usage_flags_CALL_INSTANCE;

typedef struct _CMOCK_psa_get_key_usage_flags_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_usage_t ReturnVal;
  const psa_key_attributes_t* Expected_attributes;

} CMOCK_psa_get_key_usage_flags_CALL_INSTANCE;

typedef struct _CMOCK_psa_set_key_algorithm_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_attributes_t* Expected_attributes;
  psa_algorithm_t Expected_alg;

} CMOCK_psa_set_key_algorithm_CALL_INSTANCE;

typedef struct _CMOCK_psa_get_key_algorithm_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_algorithm_t ReturnVal;
  const psa_key_attributes_t* Expected_attributes;

} CMOCK_psa_get_key_algorithm_CALL_INSTANCE;

typedef struct _CMOCK_psa_set_key_type_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_attributes_t* Expected_attributes;
  psa_key_type_t Expected_type;

} CMOCK_psa_set_key_type_CALL_INSTANCE;

typedef struct _CMOCK_psa_set_key_bits_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_attributes_t* Expected_attributes;
  size_t Expected_bits;

} CMOCK_psa_set_key_bits_CALL_INSTANCE;

typedef struct _CMOCK_psa_get_key_type_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_type_t ReturnVal;
  const psa_key_attributes_t* Expected_attributes;

} CMOCK_psa_get_key_type_CALL_INSTANCE;

typedef struct _CMOCK_psa_get_key_bits_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  size_t ReturnVal;
  const psa_key_attributes_t* Expected_attributes;

} CMOCK_psa_get_key_bits_CALL_INSTANCE;

typedef struct _CMOCK_psa_get_key_attributes_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_key_attributes_t* Expected_attributes;

} CMOCK_psa_get_key_attributes_CALL_INSTANCE;

typedef struct _CMOCK_psa_reset_key_attributes_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_attributes_t* Expected_attributes;

} CMOCK_psa_reset_key_attributes_CALL_INSTANCE;

typedef struct _CMOCK_psa_purge_key_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;

} CMOCK_psa_purge_key_CALL_INSTANCE;

typedef struct _CMOCK_psa_copy_key_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_source_key;
  const psa_key_attributes_t* Expected_attributes;
  psa_key_id_t* Expected_target_key;

} CMOCK_psa_copy_key_CALL_INSTANCE;

typedef struct _CMOCK_psa_destroy_key_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;

} CMOCK_psa_destroy_key_CALL_INSTANCE;

typedef struct _CMOCK_psa_import_key_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  const psa_key_attributes_t* Expected_attributes;
  const uint8_t* Expected_data;
  size_t Expected_data_length;
  psa_key_id_t* Expected_key;

} CMOCK_psa_import_key_CALL_INSTANCE;

typedef struct _CMOCK_psa_export_key_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  uint8_t* Expected_data;
  size_t Expected_data_size;
  size_t* Expected_data_length;

} CMOCK_psa_export_key_CALL_INSTANCE;

typedef struct _CMOCK_psa_export_public_key_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  uint8_t* Expected_data;
  size_t Expected_data_size;
  size_t* Expected_data_length;

} CMOCK_psa_export_public_key_CALL_INSTANCE;

typedef struct _CMOCK_psa_hash_compute_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_input;
  size_t Expected_input_length;
  uint8_t* Expected_hash;
  size_t Expected_hash_size;
  size_t* Expected_hash_length;

} CMOCK_psa_hash_compute_CALL_INSTANCE;

typedef struct _CMOCK_psa_hash_compare_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_input;
  size_t Expected_input_length;
  const uint8_t* Expected_hash;
  size_t Expected_hash_length;

} CMOCK_psa_hash_compare_CALL_INSTANCE;

typedef struct _CMOCK_psa_hash_operation_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_hash_operation_t ReturnVal;

} CMOCK_psa_hash_operation_init_CALL_INSTANCE;

typedef struct _CMOCK_psa_hash_setup_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_hash_operation_t* Expected_operation;
  psa_algorithm_t Expected_alg;

} CMOCK_psa_hash_setup_CALL_INSTANCE;

typedef struct _CMOCK_psa_hash_update_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_hash_operation_t* Expected_operation;
  const uint8_t* Expected_input;
  size_t Expected_input_length;

} CMOCK_psa_hash_update_CALL_INSTANCE;

typedef struct _CMOCK_psa_hash_finish_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_hash_operation_t* Expected_operation;
  uint8_t* Expected_hash;
  size_t Expected_hash_size;
  size_t* Expected_hash_length;

} CMOCK_psa_hash_finish_CALL_INSTANCE;

typedef struct _CMOCK_psa_hash_verify_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_hash_operation_t* Expected_operation;
  const uint8_t* Expected_hash;
  size_t Expected_hash_length;

} CMOCK_psa_hash_verify_CALL_INSTANCE;

typedef struct _CMOCK_psa_hash_abort_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_hash_operation_t* Expected_operation;

} CMOCK_psa_hash_abort_CALL_INSTANCE;

typedef struct _CMOCK_psa_hash_clone_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  const psa_hash_operation_t* Expected_source_operation;
  psa_hash_operation_t* Expected_target_operation;

} CMOCK_psa_hash_clone_CALL_INSTANCE;

typedef struct _CMOCK_psa_mac_compute_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_input;
  size_t Expected_input_length;
  uint8_t* Expected_mac;
  size_t Expected_mac_size;
  size_t* Expected_mac_length;

} CMOCK_psa_mac_compute_CALL_INSTANCE;

typedef struct _CMOCK_psa_mac_verify_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_input;
  size_t Expected_input_length;
  const uint8_t* Expected_mac;
  size_t Expected_mac_length;

} CMOCK_psa_mac_verify_CALL_INSTANCE;

typedef struct _CMOCK_psa_mac_operation_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_mac_operation_t ReturnVal;

} CMOCK_psa_mac_operation_init_CALL_INSTANCE;

typedef struct _CMOCK_psa_mac_sign_setup_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_mac_operation_t* Expected_operation;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;

} CMOCK_psa_mac_sign_setup_CALL_INSTANCE;

typedef struct _CMOCK_psa_mac_verify_setup_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_mac_operation_t* Expected_operation;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;

} CMOCK_psa_mac_verify_setup_CALL_INSTANCE;

typedef struct _CMOCK_psa_mac_update_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_mac_operation_t* Expected_operation;
  const uint8_t* Expected_input;
  size_t Expected_input_length;

} CMOCK_psa_mac_update_CALL_INSTANCE;

typedef struct _CMOCK_psa_mac_sign_finish_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_mac_operation_t* Expected_operation;
  uint8_t* Expected_mac;
  size_t Expected_mac_size;
  size_t* Expected_mac_length;

} CMOCK_psa_mac_sign_finish_CALL_INSTANCE;

typedef struct _CMOCK_psa_mac_verify_finish_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_mac_operation_t* Expected_operation;
  const uint8_t* Expected_mac;
  size_t Expected_mac_length;

} CMOCK_psa_mac_verify_finish_CALL_INSTANCE;

typedef struct _CMOCK_psa_mac_abort_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_mac_operation_t* Expected_operation;

} CMOCK_psa_mac_abort_CALL_INSTANCE;

typedef struct _CMOCK_psa_cipher_encrypt_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_input;
  size_t Expected_input_length;
  uint8_t* Expected_output;
  size_t Expected_output_size;
  size_t* Expected_output_length;

} CMOCK_psa_cipher_encrypt_CALL_INSTANCE;

typedef struct _CMOCK_psa_cipher_decrypt_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_input;
  size_t Expected_input_length;
  uint8_t* Expected_output;
  size_t Expected_output_size;
  size_t* Expected_output_length;

} CMOCK_psa_cipher_decrypt_CALL_INSTANCE;

typedef struct _CMOCK_psa_cipher_operation_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_cipher_operation_t ReturnVal;

} CMOCK_psa_cipher_operation_init_CALL_INSTANCE;

typedef struct _CMOCK_psa_cipher_encrypt_setup_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_cipher_operation_t* Expected_operation;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;

} CMOCK_psa_cipher_encrypt_setup_CALL_INSTANCE;

typedef struct _CMOCK_psa_cipher_decrypt_setup_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_cipher_operation_t* Expected_operation;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;

} CMOCK_psa_cipher_decrypt_setup_CALL_INSTANCE;

typedef struct _CMOCK_psa_cipher_generate_iv_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_cipher_operation_t* Expected_operation;
  uint8_t* Expected_iv;
  size_t Expected_iv_size;
  size_t* Expected_iv_length;

} CMOCK_psa_cipher_generate_iv_CALL_INSTANCE;

typedef struct _CMOCK_psa_cipher_set_iv_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_cipher_operation_t* Expected_operation;
  const uint8_t* Expected_iv;
  size_t Expected_iv_length;

} CMOCK_psa_cipher_set_iv_CALL_INSTANCE;

typedef struct _CMOCK_psa_cipher_update_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_cipher_operation_t* Expected_operation;
  const uint8_t* Expected_input;
  size_t Expected_input_length;
  uint8_t* Expected_output;
  size_t Expected_output_size;
  size_t* Expected_output_length;

} CMOCK_psa_cipher_update_CALL_INSTANCE;

typedef struct _CMOCK_psa_cipher_finish_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_cipher_operation_t* Expected_operation;
  uint8_t* Expected_output;
  size_t Expected_output_size;
  size_t* Expected_output_length;

} CMOCK_psa_cipher_finish_CALL_INSTANCE;

typedef struct _CMOCK_psa_cipher_abort_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_cipher_operation_t* Expected_operation;

} CMOCK_psa_cipher_abort_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_encrypt_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_nonce;
  size_t Expected_nonce_length;
  const uint8_t* Expected_additional_data;
  size_t Expected_additional_data_length;
  const uint8_t* Expected_plaintext;
  size_t Expected_plaintext_length;
  uint8_t* Expected_ciphertext;
  size_t Expected_ciphertext_size;
  size_t* Expected_ciphertext_length;

} CMOCK_psa_aead_encrypt_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_decrypt_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_nonce;
  size_t Expected_nonce_length;
  const uint8_t* Expected_additional_data;
  size_t Expected_additional_data_length;
  const uint8_t* Expected_ciphertext;
  size_t Expected_ciphertext_length;
  uint8_t* Expected_plaintext;
  size_t Expected_plaintext_size;
  size_t* Expected_plaintext_length;

} CMOCK_psa_aead_decrypt_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_operation_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_aead_operation_t ReturnVal;

} CMOCK_psa_aead_operation_init_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_encrypt_setup_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_aead_operation_t* Expected_operation;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;

} CMOCK_psa_aead_encrypt_setup_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_decrypt_setup_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_aead_operation_t* Expected_operation;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;

} CMOCK_psa_aead_decrypt_setup_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_generate_nonce_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_aead_operation_t* Expected_operation;
  uint8_t* Expected_nonce;
  size_t Expected_nonce_size;
  size_t* Expected_nonce_length;

} CMOCK_psa_aead_generate_nonce_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_set_nonce_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_aead_operation_t* Expected_operation;
  const uint8_t* Expected_nonce;
  size_t Expected_nonce_length;

} CMOCK_psa_aead_set_nonce_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_set_lengths_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_aead_operation_t* Expected_operation;
  size_t Expected_ad_length;
  size_t Expected_plaintext_length;

} CMOCK_psa_aead_set_lengths_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_update_ad_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_aead_operation_t* Expected_operation;
  const uint8_t* Expected_input;
  size_t Expected_input_length;

} CMOCK_psa_aead_update_ad_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_update_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_aead_operation_t* Expected_operation;
  const uint8_t* Expected_input;
  size_t Expected_input_length;
  uint8_t* Expected_output;
  size_t Expected_output_size;
  size_t* Expected_output_length;

} CMOCK_psa_aead_update_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_finish_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_aead_operation_t* Expected_operation;
  uint8_t* Expected_ciphertext;
  size_t Expected_ciphertext_size;
  size_t* Expected_ciphertext_length;
  uint8_t* Expected_tag;
  size_t Expected_tag_size;
  size_t* Expected_tag_length;

} CMOCK_psa_aead_finish_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_verify_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_aead_operation_t* Expected_operation;
  uint8_t* Expected_plaintext;
  size_t Expected_plaintext_size;
  size_t* Expected_plaintext_length;
  const uint8_t* Expected_tag;
  size_t Expected_tag_length;

} CMOCK_psa_aead_verify_CALL_INSTANCE;

typedef struct _CMOCK_psa_aead_abort_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_aead_operation_t* Expected_operation;

} CMOCK_psa_aead_abort_CALL_INSTANCE;

typedef struct _CMOCK_psa_sign_message_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_input;
  size_t Expected_input_length;
  uint8_t* Expected_signature;
  size_t Expected_signature_size;
  size_t* Expected_signature_length;

} CMOCK_psa_sign_message_CALL_INSTANCE;

typedef struct _CMOCK_psa_verify_message_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_input;
  size_t Expected_input_length;
  const uint8_t* Expected_signature;
  size_t Expected_signature_length;

} CMOCK_psa_verify_message_CALL_INSTANCE;

typedef struct _CMOCK_psa_sign_hash_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_hash;
  size_t Expected_hash_length;
  uint8_t* Expected_signature;
  size_t Expected_signature_size;
  size_t* Expected_signature_length;

} CMOCK_psa_sign_hash_CALL_INSTANCE;

typedef struct _CMOCK_psa_verify_hash_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_hash;
  size_t Expected_hash_length;
  const uint8_t* Expected_signature;
  size_t Expected_signature_length;

} CMOCK_psa_verify_hash_CALL_INSTANCE;

typedef struct _CMOCK_psa_asymmetric_encrypt_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_input;
  size_t Expected_input_length;
  const uint8_t* Expected_salt;
  size_t Expected_salt_length;
  uint8_t* Expected_output;
  size_t Expected_output_size;
  size_t* Expected_output_length;

} CMOCK_psa_asymmetric_encrypt_CALL_INSTANCE;

typedef struct _CMOCK_psa_asymmetric_decrypt_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_id_t Expected_key;
  psa_algorithm_t Expected_alg;
  const uint8_t* Expected_input;
  size_t Expected_input_length;
  const uint8_t* Expected_salt;
  size_t Expected_salt_length;
  uint8_t* Expected_output;
  size_t Expected_output_size;
  size_t* Expected_output_length;

} CMOCK_psa_asymmetric_decrypt_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_operation_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_key_derivation_operation_t ReturnVal;

} CMOCK_psa_key_derivation_operation_init_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_setup_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_derivation_operation_t* Expected_operation;
  psa_algorithm_t Expected_alg;

} CMOCK_psa_key_derivation_setup_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_get_capacity_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  const psa_key_derivation_operation_t* Expected_operation;
  size_t* Expected_capacity;

} CMOCK_psa_key_derivation_get_capacity_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_set_capacity_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_derivation_operation_t* Expected_operation;
  size_t Expected_capacity;

} CMOCK_psa_key_derivation_set_capacity_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_input_bytes_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_derivation_operation_t* Expected_operation;
  psa_key_derivation_step_t Expected_step;
  const uint8_t* Expected_data;
  size_t Expected_data_length;

} CMOCK_psa_key_derivation_input_bytes_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_input_integer_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_derivation_operation_t* Expected_operation;
  psa_key_derivation_step_t Expected_step;
  uint64_t Expected_value;

} CMOCK_psa_key_derivation_input_integer_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_input_key_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_derivation_operation_t* Expected_operation;
  psa_key_derivation_step_t Expected_step;
  psa_key_id_t Expected_key;

} CMOCK_psa_key_derivation_input_key_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_key_agreement_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_derivation_operation_t* Expected_operation;
  psa_key_derivation_step_t Expected_step;
  psa_key_id_t Expected_private_key;
  const uint8_t* Expected_peer_key;
  size_t Expected_peer_key_length;

} CMOCK_psa_key_derivation_key_agreement_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_output_bytes_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_derivation_operation_t* Expected_operation;
  uint8_t* Expected_output;
  size_t Expected_output_length;

} CMOCK_psa_key_derivation_output_bytes_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_output_key_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  const psa_key_attributes_t* Expected_attributes;
  psa_key_derivation_operation_t* Expected_operation;
  psa_key_id_t* Expected_key;

} CMOCK_psa_key_derivation_output_key_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_verify_bytes_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_derivation_operation_t* Expected_operation;
  const uint8_t* Expected_expected_output;
  size_t Expected_output_length;

} CMOCK_psa_key_derivation_verify_bytes_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_verify_key_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_derivation_operation_t* Expected_operation;
  psa_key_id_t Expected_expected;

} CMOCK_psa_key_derivation_verify_key_CALL_INSTANCE;

typedef struct _CMOCK_psa_key_derivation_abort_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_key_derivation_operation_t* Expected_operation;

} CMOCK_psa_key_derivation_abort_CALL_INSTANCE;

typedef struct _CMOCK_psa_raw_key_agreement_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  psa_algorithm_t Expected_alg;
  psa_key_id_t Expected_private_key;
  const uint8_t* Expected_peer_key;
  size_t Expected_peer_key_length;
  uint8_t* Expected_output;
  size_t Expected_output_size;
  size_t* Expected_output_length;

} CMOCK_psa_raw_key_agreement_CALL_INSTANCE;

typedef struct _CMOCK_psa_generate_random_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  uint8_t* Expected_output;
  size_t Expected_output_size;

} CMOCK_psa_generate_random_CALL_INSTANCE;

typedef struct _CMOCK_psa_generate_key_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  psa_status_t ReturnVal;
  const psa_key_attributes_t* Expected_attributes;
  psa_key_id_t* Expected_key;

} CMOCK_psa_generate_key_CALL_INSTANCE;

static struct mock_cryptoInstance
{
  char psa_crypto_init_IgnoreBool;
  psa_status_t psa_crypto_init_FinalReturn;
  char psa_crypto_init_CallbackBool;
  CMOCK_psa_crypto_init_CALLBACK psa_crypto_init_CallbackFunctionPointer;
  int psa_crypto_init_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_crypto_init_CallInstance;
  char psa_key_attributes_init_IgnoreBool;
  psa_key_attributes_t psa_key_attributes_init_FinalReturn;
  char psa_key_attributes_init_CallbackBool;
  CMOCK_psa_key_attributes_init_CALLBACK psa_key_attributes_init_CallbackFunctionPointer;
  int psa_key_attributes_init_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_key_attributes_init_CallInstance;
  char psa_set_key_id_IgnoreBool;
  char psa_set_key_id_CallbackBool;
  CMOCK_psa_set_key_id_CALLBACK psa_set_key_id_CallbackFunctionPointer;
  int psa_set_key_id_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_set_key_id_CallInstance;
  char psa_set_key_lifetime_IgnoreBool;
  char psa_set_key_lifetime_CallbackBool;
  CMOCK_psa_set_key_lifetime_CALLBACK psa_set_key_lifetime_CallbackFunctionPointer;
  int psa_set_key_lifetime_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_set_key_lifetime_CallInstance;
  char psa_get_key_id_IgnoreBool;
  psa_key_id_t psa_get_key_id_FinalReturn;
  char psa_get_key_id_CallbackBool;
  CMOCK_psa_get_key_id_CALLBACK psa_get_key_id_CallbackFunctionPointer;
  int psa_get_key_id_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_get_key_id_CallInstance;
  char psa_get_key_lifetime_IgnoreBool;
  psa_key_lifetime_t psa_get_key_lifetime_FinalReturn;
  char psa_get_key_lifetime_CallbackBool;
  CMOCK_psa_get_key_lifetime_CALLBACK psa_get_key_lifetime_CallbackFunctionPointer;
  int psa_get_key_lifetime_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_get_key_lifetime_CallInstance;
  char psa_set_key_usage_flags_IgnoreBool;
  char psa_set_key_usage_flags_CallbackBool;
  CMOCK_psa_set_key_usage_flags_CALLBACK psa_set_key_usage_flags_CallbackFunctionPointer;
  int psa_set_key_usage_flags_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_set_key_usage_flags_CallInstance;
  char psa_get_key_usage_flags_IgnoreBool;
  psa_key_usage_t psa_get_key_usage_flags_FinalReturn;
  char psa_get_key_usage_flags_CallbackBool;
  CMOCK_psa_get_key_usage_flags_CALLBACK psa_get_key_usage_flags_CallbackFunctionPointer;
  int psa_get_key_usage_flags_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_get_key_usage_flags_CallInstance;
  char psa_set_key_algorithm_IgnoreBool;
  char psa_set_key_algorithm_CallbackBool;
  CMOCK_psa_set_key_algorithm_CALLBACK psa_set_key_algorithm_CallbackFunctionPointer;
  int psa_set_key_algorithm_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_set_key_algorithm_CallInstance;
  char psa_get_key_algorithm_IgnoreBool;
  psa_algorithm_t psa_get_key_algorithm_FinalReturn;
  char psa_get_key_algorithm_CallbackBool;
  CMOCK_psa_get_key_algorithm_CALLBACK psa_get_key_algorithm_CallbackFunctionPointer;
  int psa_get_key_algorithm_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_get_key_algorithm_CallInstance;
  char psa_set_key_type_IgnoreBool;
  char psa_set_key_type_CallbackBool;
  CMOCK_psa_set_key_type_CALLBACK psa_set_key_type_CallbackFunctionPointer;
  int psa_set_key_type_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_set_key_type_CallInstance;
  char psa_set_key_bits_IgnoreBool;
  char psa_set_key_bits_CallbackBool;
  CMOCK_psa_set_key_bits_CALLBACK psa_set_key_bits_CallbackFunctionPointer;
  int psa_set_key_bits_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_set_key_bits_CallInstance;
  char psa_get_key_type_IgnoreBool;
  psa_key_type_t psa_get_key_type_FinalReturn;
  char psa_get_key_type_CallbackBool;
  CMOCK_psa_get_key_type_CALLBACK psa_get_key_type_CallbackFunctionPointer;
  int psa_get_key_type_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_get_key_type_CallInstance;
  char psa_get_key_bits_IgnoreBool;
  size_t psa_get_key_bits_FinalReturn;
  char psa_get_key_bits_CallbackBool;
  CMOCK_psa_get_key_bits_CALLBACK psa_get_key_bits_CallbackFunctionPointer;
  int psa_get_key_bits_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_get_key_bits_CallInstance;
  char psa_get_key_attributes_IgnoreBool;
  psa_status_t psa_get_key_attributes_FinalReturn;
  char psa_get_key_attributes_CallbackBool;
  CMOCK_psa_get_key_attributes_CALLBACK psa_get_key_attributes_CallbackFunctionPointer;
  int psa_get_key_attributes_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_get_key_attributes_CallInstance;
  char psa_reset_key_attributes_IgnoreBool;
  char psa_reset_key_attributes_CallbackBool;
  CMOCK_psa_reset_key_attributes_CALLBACK psa_reset_key_attributes_CallbackFunctionPointer;
  int psa_reset_key_attributes_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_reset_key_attributes_CallInstance;
  char psa_purge_key_IgnoreBool;
  psa_status_t psa_purge_key_FinalReturn;
  char psa_purge_key_CallbackBool;
  CMOCK_psa_purge_key_CALLBACK psa_purge_key_CallbackFunctionPointer;
  int psa_purge_key_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_purge_key_CallInstance;
  char psa_copy_key_IgnoreBool;
  psa_status_t psa_copy_key_FinalReturn;
  char psa_copy_key_CallbackBool;
  CMOCK_psa_copy_key_CALLBACK psa_copy_key_CallbackFunctionPointer;
  int psa_copy_key_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_copy_key_CallInstance;
  char psa_destroy_key_IgnoreBool;
  psa_status_t psa_destroy_key_FinalReturn;
  char psa_destroy_key_CallbackBool;
  CMOCK_psa_destroy_key_CALLBACK psa_destroy_key_CallbackFunctionPointer;
  int psa_destroy_key_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_destroy_key_CallInstance;
  char psa_import_key_IgnoreBool;
  psa_status_t psa_import_key_FinalReturn;
  char psa_import_key_CallbackBool;
  CMOCK_psa_import_key_CALLBACK psa_import_key_CallbackFunctionPointer;
  int psa_import_key_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_import_key_CallInstance;
  char psa_export_key_IgnoreBool;
  psa_status_t psa_export_key_FinalReturn;
  char psa_export_key_CallbackBool;
  CMOCK_psa_export_key_CALLBACK psa_export_key_CallbackFunctionPointer;
  int psa_export_key_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_export_key_CallInstance;
  char psa_export_public_key_IgnoreBool;
  psa_status_t psa_export_public_key_FinalReturn;
  char psa_export_public_key_CallbackBool;
  CMOCK_psa_export_public_key_CALLBACK psa_export_public_key_CallbackFunctionPointer;
  int psa_export_public_key_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_export_public_key_CallInstance;
  char psa_hash_compute_IgnoreBool;
  psa_status_t psa_hash_compute_FinalReturn;
  char psa_hash_compute_CallbackBool;
  CMOCK_psa_hash_compute_CALLBACK psa_hash_compute_CallbackFunctionPointer;
  int psa_hash_compute_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_hash_compute_CallInstance;
  char psa_hash_compare_IgnoreBool;
  psa_status_t psa_hash_compare_FinalReturn;
  char psa_hash_compare_CallbackBool;
  CMOCK_psa_hash_compare_CALLBACK psa_hash_compare_CallbackFunctionPointer;
  int psa_hash_compare_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_hash_compare_CallInstance;
  char psa_hash_operation_init_IgnoreBool;
  psa_hash_operation_t psa_hash_operation_init_FinalReturn;
  char psa_hash_operation_init_CallbackBool;
  CMOCK_psa_hash_operation_init_CALLBACK psa_hash_operation_init_CallbackFunctionPointer;
  int psa_hash_operation_init_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_hash_operation_init_CallInstance;
  char psa_hash_setup_IgnoreBool;
  psa_status_t psa_hash_setup_FinalReturn;
  char psa_hash_setup_CallbackBool;
  CMOCK_psa_hash_setup_CALLBACK psa_hash_setup_CallbackFunctionPointer;
  int psa_hash_setup_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_hash_setup_CallInstance;
  char psa_hash_update_IgnoreBool;
  psa_status_t psa_hash_update_FinalReturn;
  char psa_hash_update_CallbackBool;
  CMOCK_psa_hash_update_CALLBACK psa_hash_update_CallbackFunctionPointer;
  int psa_hash_update_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_hash_update_CallInstance;
  char psa_hash_finish_IgnoreBool;
  psa_status_t psa_hash_finish_FinalReturn;
  char psa_hash_finish_CallbackBool;
  CMOCK_psa_hash_finish_CALLBACK psa_hash_finish_CallbackFunctionPointer;
  int psa_hash_finish_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_hash_finish_CallInstance;
  char psa_hash_verify_IgnoreBool;
  psa_status_t psa_hash_verify_FinalReturn;
  char psa_hash_verify_CallbackBool;
  CMOCK_psa_hash_verify_CALLBACK psa_hash_verify_CallbackFunctionPointer;
  int psa_hash_verify_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_hash_verify_CallInstance;
  char psa_hash_abort_IgnoreBool;
  psa_status_t psa_hash_abort_FinalReturn;
  char psa_hash_abort_CallbackBool;
  CMOCK_psa_hash_abort_CALLBACK psa_hash_abort_CallbackFunctionPointer;
  int psa_hash_abort_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_hash_abort_CallInstance;
  char psa_hash_clone_IgnoreBool;
  psa_status_t psa_hash_clone_FinalReturn;
  char psa_hash_clone_CallbackBool;
  CMOCK_psa_hash_clone_CALLBACK psa_hash_clone_CallbackFunctionPointer;
  int psa_hash_clone_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_hash_clone_CallInstance;
  char psa_mac_compute_IgnoreBool;
  psa_status_t psa_mac_compute_FinalReturn;
  char psa_mac_compute_CallbackBool;
  CMOCK_psa_mac_compute_CALLBACK psa_mac_compute_CallbackFunctionPointer;
  int psa_mac_compute_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_mac_compute_CallInstance;
  char psa_mac_verify_IgnoreBool;
  psa_status_t psa_mac_verify_FinalReturn;
  char psa_mac_verify_CallbackBool;
  CMOCK_psa_mac_verify_CALLBACK psa_mac_verify_CallbackFunctionPointer;
  int psa_mac_verify_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_mac_verify_CallInstance;
  char psa_mac_operation_init_IgnoreBool;
  psa_mac_operation_t psa_mac_operation_init_FinalReturn;
  char psa_mac_operation_init_CallbackBool;
  CMOCK_psa_mac_operation_init_CALLBACK psa_mac_operation_init_CallbackFunctionPointer;
  int psa_mac_operation_init_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_mac_operation_init_CallInstance;
  char psa_mac_sign_setup_IgnoreBool;
  psa_status_t psa_mac_sign_setup_FinalReturn;
  char psa_mac_sign_setup_CallbackBool;
  CMOCK_psa_mac_sign_setup_CALLBACK psa_mac_sign_setup_CallbackFunctionPointer;
  int psa_mac_sign_setup_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_mac_sign_setup_CallInstance;
  char psa_mac_verify_setup_IgnoreBool;
  psa_status_t psa_mac_verify_setup_FinalReturn;
  char psa_mac_verify_setup_CallbackBool;
  CMOCK_psa_mac_verify_setup_CALLBACK psa_mac_verify_setup_CallbackFunctionPointer;
  int psa_mac_verify_setup_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_mac_verify_setup_CallInstance;
  char psa_mac_update_IgnoreBool;
  psa_status_t psa_mac_update_FinalReturn;
  char psa_mac_update_CallbackBool;
  CMOCK_psa_mac_update_CALLBACK psa_mac_update_CallbackFunctionPointer;
  int psa_mac_update_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_mac_update_CallInstance;
  char psa_mac_sign_finish_IgnoreBool;
  psa_status_t psa_mac_sign_finish_FinalReturn;
  char psa_mac_sign_finish_CallbackBool;
  CMOCK_psa_mac_sign_finish_CALLBACK psa_mac_sign_finish_CallbackFunctionPointer;
  int psa_mac_sign_finish_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_mac_sign_finish_CallInstance;
  char psa_mac_verify_finish_IgnoreBool;
  psa_status_t psa_mac_verify_finish_FinalReturn;
  char psa_mac_verify_finish_CallbackBool;
  CMOCK_psa_mac_verify_finish_CALLBACK psa_mac_verify_finish_CallbackFunctionPointer;
  int psa_mac_verify_finish_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_mac_verify_finish_CallInstance;
  char psa_mac_abort_IgnoreBool;
  psa_status_t psa_mac_abort_FinalReturn;
  char psa_mac_abort_CallbackBool;
  CMOCK_psa_mac_abort_CALLBACK psa_mac_abort_CallbackFunctionPointer;
  int psa_mac_abort_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_mac_abort_CallInstance;
  char psa_cipher_encrypt_IgnoreBool;
  psa_status_t psa_cipher_encrypt_FinalReturn;
  char psa_cipher_encrypt_CallbackBool;
  CMOCK_psa_cipher_encrypt_CALLBACK psa_cipher_encrypt_CallbackFunctionPointer;
  int psa_cipher_encrypt_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_cipher_encrypt_CallInstance;
  char psa_cipher_decrypt_IgnoreBool;
  psa_status_t psa_cipher_decrypt_FinalReturn;
  char psa_cipher_decrypt_CallbackBool;
  CMOCK_psa_cipher_decrypt_CALLBACK psa_cipher_decrypt_CallbackFunctionPointer;
  int psa_cipher_decrypt_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_cipher_decrypt_CallInstance;
  char psa_cipher_operation_init_IgnoreBool;
  psa_cipher_operation_t psa_cipher_operation_init_FinalReturn;
  char psa_cipher_operation_init_CallbackBool;
  CMOCK_psa_cipher_operation_init_CALLBACK psa_cipher_operation_init_CallbackFunctionPointer;
  int psa_cipher_operation_init_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_cipher_operation_init_CallInstance;
  char psa_cipher_encrypt_setup_IgnoreBool;
  psa_status_t psa_cipher_encrypt_setup_FinalReturn;
  char psa_cipher_encrypt_setup_CallbackBool;
  CMOCK_psa_cipher_encrypt_setup_CALLBACK psa_cipher_encrypt_setup_CallbackFunctionPointer;
  int psa_cipher_encrypt_setup_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_cipher_encrypt_setup_CallInstance;
  char psa_cipher_decrypt_setup_IgnoreBool;
  psa_status_t psa_cipher_decrypt_setup_FinalReturn;
  char psa_cipher_decrypt_setup_CallbackBool;
  CMOCK_psa_cipher_decrypt_setup_CALLBACK psa_cipher_decrypt_setup_CallbackFunctionPointer;
  int psa_cipher_decrypt_setup_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_cipher_decrypt_setup_CallInstance;
  char psa_cipher_generate_iv_IgnoreBool;
  psa_status_t psa_cipher_generate_iv_FinalReturn;
  char psa_cipher_generate_iv_CallbackBool;
  CMOCK_psa_cipher_generate_iv_CALLBACK psa_cipher_generate_iv_CallbackFunctionPointer;
  int psa_cipher_generate_iv_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_cipher_generate_iv_CallInstance;
  char psa_cipher_set_iv_IgnoreBool;
  psa_status_t psa_cipher_set_iv_FinalReturn;
  char psa_cipher_set_iv_CallbackBool;
  CMOCK_psa_cipher_set_iv_CALLBACK psa_cipher_set_iv_CallbackFunctionPointer;
  int psa_cipher_set_iv_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_cipher_set_iv_CallInstance;
  char psa_cipher_update_IgnoreBool;
  psa_status_t psa_cipher_update_FinalReturn;
  char psa_cipher_update_CallbackBool;
  CMOCK_psa_cipher_update_CALLBACK psa_cipher_update_CallbackFunctionPointer;
  int psa_cipher_update_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_cipher_update_CallInstance;
  char psa_cipher_finish_IgnoreBool;
  psa_status_t psa_cipher_finish_FinalReturn;
  char psa_cipher_finish_CallbackBool;
  CMOCK_psa_cipher_finish_CALLBACK psa_cipher_finish_CallbackFunctionPointer;
  int psa_cipher_finish_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_cipher_finish_CallInstance;
  char psa_cipher_abort_IgnoreBool;
  psa_status_t psa_cipher_abort_FinalReturn;
  char psa_cipher_abort_CallbackBool;
  CMOCK_psa_cipher_abort_CALLBACK psa_cipher_abort_CallbackFunctionPointer;
  int psa_cipher_abort_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_cipher_abort_CallInstance;
  char psa_aead_encrypt_IgnoreBool;
  psa_status_t psa_aead_encrypt_FinalReturn;
  char psa_aead_encrypt_CallbackBool;
  CMOCK_psa_aead_encrypt_CALLBACK psa_aead_encrypt_CallbackFunctionPointer;
  int psa_aead_encrypt_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_aead_encrypt_CallInstance;
  char psa_aead_decrypt_IgnoreBool;
  psa_status_t psa_aead_decrypt_FinalReturn;
  char psa_aead_decrypt_CallbackBool;
  CMOCK_psa_aead_decrypt_CALLBACK psa_aead_decrypt_CallbackFunctionPointer;
  int psa_aead_decrypt_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_aead_decrypt_CallInstance;
  char psa_aead_operation_init_IgnoreBool;
  psa_aead_operation_t psa_aead_operation_init_FinalReturn;
  char psa_aead_operation_init_CallbackBool;
  CMOCK_psa_aead_operation_init_CALLBACK psa_aead_operation_init_CallbackFunctionPointer;
  int psa_aead_operation_init_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_aead_operation_init_CallInstance;
  char psa_aead_encrypt_setup_IgnoreBool;
  psa_status_t psa_aead_encrypt_setup_FinalReturn;
  char psa_aead_encrypt_setup_CallbackBool;
  CMOCK_psa_aead_encrypt_setup_CALLBACK psa_aead_encrypt_setup_CallbackFunctionPointer;
  int psa_aead_encrypt_setup_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_aead_encrypt_setup_CallInstance;
  char psa_aead_decrypt_setup_IgnoreBool;
  psa_status_t psa_aead_decrypt_setup_FinalReturn;
  char psa_aead_decrypt_setup_CallbackBool;
  CMOCK_psa_aead_decrypt_setup_CALLBACK psa_aead_decrypt_setup_CallbackFunctionPointer;
  int psa_aead_decrypt_setup_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_aead_decrypt_setup_CallInstance;
  char psa_aead_generate_nonce_IgnoreBool;
  psa_status_t psa_aead_generate_nonce_FinalReturn;
  char psa_aead_generate_nonce_CallbackBool;
  CMOCK_psa_aead_generate_nonce_CALLBACK psa_aead_generate_nonce_CallbackFunctionPointer;
  int psa_aead_generate_nonce_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_aead_generate_nonce_CallInstance;
  char psa_aead_set_nonce_IgnoreBool;
  psa_status_t psa_aead_set_nonce_FinalReturn;
  char psa_aead_set_nonce_CallbackBool;
  CMOCK_psa_aead_set_nonce_CALLBACK psa_aead_set_nonce_CallbackFunctionPointer;
  int psa_aead_set_nonce_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_aead_set_nonce_CallInstance;
  char psa_aead_set_lengths_IgnoreBool;
  psa_status_t psa_aead_set_lengths_FinalReturn;
  char psa_aead_set_lengths_CallbackBool;
  CMOCK_psa_aead_set_lengths_CALLBACK psa_aead_set_lengths_CallbackFunctionPointer;
  int psa_aead_set_lengths_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_aead_set_lengths_CallInstance;
  char psa_aead_update_ad_IgnoreBool;
  psa_status_t psa_aead_update_ad_FinalReturn;
  char psa_aead_update_ad_CallbackBool;
  CMOCK_psa_aead_update_ad_CALLBACK psa_aead_update_ad_CallbackFunctionPointer;
  int psa_aead_update_ad_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_aead_update_ad_CallInstance;
  char psa_aead_update_IgnoreBool;
  psa_status_t psa_aead_update_FinalReturn;
  char psa_aead_update_CallbackBool;
  CMOCK_psa_aead_update_CALLBACK psa_aead_update_CallbackFunctionPointer;
  int psa_aead_update_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_aead_update_CallInstance;
  char psa_aead_finish_IgnoreBool;
  psa_status_t psa_aead_finish_FinalReturn;
  char psa_aead_finish_CallbackBool;
  CMOCK_psa_aead_finish_CALLBACK psa_aead_finish_CallbackFunctionPointer;
  int psa_aead_finish_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_aead_finish_CallInstance;
  char psa_aead_verify_IgnoreBool;
  psa_status_t psa_aead_verify_FinalReturn;
  char psa_aead_verify_CallbackBool;
  CMOCK_psa_aead_verify_CALLBACK psa_aead_verify_CallbackFunctionPointer;
  int psa_aead_verify_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_aead_verify_CallInstance;
  char psa_aead_abort_IgnoreBool;
  psa_status_t psa_aead_abort_FinalReturn;
  char psa_aead_abort_CallbackBool;
  CMOCK_psa_aead_abort_CALLBACK psa_aead_abort_CallbackFunctionPointer;
  int psa_aead_abort_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_aead_abort_CallInstance;
  char psa_sign_message_IgnoreBool;
  psa_status_t psa_sign_message_FinalReturn;
  char psa_sign_message_CallbackBool;
  CMOCK_psa_sign_message_CALLBACK psa_sign_message_CallbackFunctionPointer;
  int psa_sign_message_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_sign_message_CallInstance;
  char psa_verify_message_IgnoreBool;
  psa_status_t psa_verify_message_FinalReturn;
  char psa_verify_message_CallbackBool;
  CMOCK_psa_verify_message_CALLBACK psa_verify_message_CallbackFunctionPointer;
  int psa_verify_message_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_verify_message_CallInstance;
  char psa_sign_hash_IgnoreBool;
  psa_status_t psa_sign_hash_FinalReturn;
  char psa_sign_hash_CallbackBool;
  CMOCK_psa_sign_hash_CALLBACK psa_sign_hash_CallbackFunctionPointer;
  int psa_sign_hash_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_sign_hash_CallInstance;
  char psa_verify_hash_IgnoreBool;
  psa_status_t psa_verify_hash_FinalReturn;
  char psa_verify_hash_CallbackBool;
  CMOCK_psa_verify_hash_CALLBACK psa_verify_hash_CallbackFunctionPointer;
  int psa_verify_hash_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_verify_hash_CallInstance;
  char psa_asymmetric_encrypt_IgnoreBool;
  psa_status_t psa_asymmetric_encrypt_FinalReturn;
  char psa_asymmetric_encrypt_CallbackBool;
  CMOCK_psa_asymmetric_encrypt_CALLBACK psa_asymmetric_encrypt_CallbackFunctionPointer;
  int psa_asymmetric_encrypt_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_asymmetric_encrypt_CallInstance;
  char psa_asymmetric_decrypt_IgnoreBool;
  psa_status_t psa_asymmetric_decrypt_FinalReturn;
  char psa_asymmetric_decrypt_CallbackBool;
  CMOCK_psa_asymmetric_decrypt_CALLBACK psa_asymmetric_decrypt_CallbackFunctionPointer;
  int psa_asymmetric_decrypt_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_asymmetric_decrypt_CallInstance;
  char psa_key_derivation_operation_init_IgnoreBool;
  psa_key_derivation_operation_t psa_key_derivation_operation_init_FinalReturn;
  char psa_key_derivation_operation_init_CallbackBool;
  CMOCK_psa_key_derivation_operation_init_CALLBACK psa_key_derivation_operation_init_CallbackFunctionPointer;
  int psa_key_derivation_operation_init_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_operation_init_CallInstance;
  char psa_key_derivation_setup_IgnoreBool;
  psa_status_t psa_key_derivation_setup_FinalReturn;
  char psa_key_derivation_setup_CallbackBool;
  CMOCK_psa_key_derivation_setup_CALLBACK psa_key_derivation_setup_CallbackFunctionPointer;
  int psa_key_derivation_setup_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_setup_CallInstance;
  char psa_key_derivation_get_capacity_IgnoreBool;
  psa_status_t psa_key_derivation_get_capacity_FinalReturn;
  char psa_key_derivation_get_capacity_CallbackBool;
  CMOCK_psa_key_derivation_get_capacity_CALLBACK psa_key_derivation_get_capacity_CallbackFunctionPointer;
  int psa_key_derivation_get_capacity_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_get_capacity_CallInstance;
  char psa_key_derivation_set_capacity_IgnoreBool;
  psa_status_t psa_key_derivation_set_capacity_FinalReturn;
  char psa_key_derivation_set_capacity_CallbackBool;
  CMOCK_psa_key_derivation_set_capacity_CALLBACK psa_key_derivation_set_capacity_CallbackFunctionPointer;
  int psa_key_derivation_set_capacity_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_set_capacity_CallInstance;
  char psa_key_derivation_input_bytes_IgnoreBool;
  psa_status_t psa_key_derivation_input_bytes_FinalReturn;
  char psa_key_derivation_input_bytes_CallbackBool;
  CMOCK_psa_key_derivation_input_bytes_CALLBACK psa_key_derivation_input_bytes_CallbackFunctionPointer;
  int psa_key_derivation_input_bytes_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_input_bytes_CallInstance;
  char psa_key_derivation_input_integer_IgnoreBool;
  psa_status_t psa_key_derivation_input_integer_FinalReturn;
  char psa_key_derivation_input_integer_CallbackBool;
  CMOCK_psa_key_derivation_input_integer_CALLBACK psa_key_derivation_input_integer_CallbackFunctionPointer;
  int psa_key_derivation_input_integer_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_input_integer_CallInstance;
  char psa_key_derivation_input_key_IgnoreBool;
  psa_status_t psa_key_derivation_input_key_FinalReturn;
  char psa_key_derivation_input_key_CallbackBool;
  CMOCK_psa_key_derivation_input_key_CALLBACK psa_key_derivation_input_key_CallbackFunctionPointer;
  int psa_key_derivation_input_key_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_input_key_CallInstance;
  char psa_key_derivation_key_agreement_IgnoreBool;
  psa_status_t psa_key_derivation_key_agreement_FinalReturn;
  char psa_key_derivation_key_agreement_CallbackBool;
  CMOCK_psa_key_derivation_key_agreement_CALLBACK psa_key_derivation_key_agreement_CallbackFunctionPointer;
  int psa_key_derivation_key_agreement_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_key_agreement_CallInstance;
  char psa_key_derivation_output_bytes_IgnoreBool;
  psa_status_t psa_key_derivation_output_bytes_FinalReturn;
  char psa_key_derivation_output_bytes_CallbackBool;
  CMOCK_psa_key_derivation_output_bytes_CALLBACK psa_key_derivation_output_bytes_CallbackFunctionPointer;
  int psa_key_derivation_output_bytes_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_output_bytes_CallInstance;
  char psa_key_derivation_output_key_IgnoreBool;
  psa_status_t psa_key_derivation_output_key_FinalReturn;
  char psa_key_derivation_output_key_CallbackBool;
  CMOCK_psa_key_derivation_output_key_CALLBACK psa_key_derivation_output_key_CallbackFunctionPointer;
  int psa_key_derivation_output_key_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_output_key_CallInstance;
  char psa_key_derivation_verify_bytes_IgnoreBool;
  psa_status_t psa_key_derivation_verify_bytes_FinalReturn;
  char psa_key_derivation_verify_bytes_CallbackBool;
  CMOCK_psa_key_derivation_verify_bytes_CALLBACK psa_key_derivation_verify_bytes_CallbackFunctionPointer;
  int psa_key_derivation_verify_bytes_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_verify_bytes_CallInstance;
  char psa_key_derivation_verify_key_IgnoreBool;
  psa_status_t psa_key_derivation_verify_key_FinalReturn;
  char psa_key_derivation_verify_key_CallbackBool;
  CMOCK_psa_key_derivation_verify_key_CALLBACK psa_key_derivation_verify_key_CallbackFunctionPointer;
  int psa_key_derivation_verify_key_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_verify_key_CallInstance;
  char psa_key_derivation_abort_IgnoreBool;
  psa_status_t psa_key_derivation_abort_FinalReturn;
  char psa_key_derivation_abort_CallbackBool;
  CMOCK_psa_key_derivation_abort_CALLBACK psa_key_derivation_abort_CallbackFunctionPointer;
  int psa_key_derivation_abort_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_key_derivation_abort_CallInstance;
  char psa_raw_key_agreement_IgnoreBool;
  psa_status_t psa_raw_key_agreement_FinalReturn;
  char psa_raw_key_agreement_CallbackBool;
  CMOCK_psa_raw_key_agreement_CALLBACK psa_raw_key_agreement_CallbackFunctionPointer;
  int psa_raw_key_agreement_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_raw_key_agreement_CallInstance;
  char psa_generate_random_IgnoreBool;
  psa_status_t psa_generate_random_FinalReturn;
  char psa_generate_random_CallbackBool;
  CMOCK_psa_generate_random_CALLBACK psa_generate_random_CallbackFunctionPointer;
  int psa_generate_random_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_generate_random_CallInstance;
  char psa_generate_key_IgnoreBool;
  psa_status_t psa_generate_key_FinalReturn;
  char psa_generate_key_CallbackBool;
  CMOCK_psa_generate_key_CALLBACK psa_generate_key_CallbackFunctionPointer;
  int psa_generate_key_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE psa_generate_key_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void mock_crypto_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.psa_crypto_init_CallInstance;
  if (Mock.psa_crypto_init_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_crypto_init);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_crypto_init_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_key_attributes_init_CallInstance;
  if (Mock.psa_key_attributes_init_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_attributes_init);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_key_attributes_init_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_set_key_id_CallInstance;
  if (Mock.psa_set_key_id_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_set_key_id);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_set_key_id_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_set_key_lifetime_CallInstance;
  if (Mock.psa_set_key_lifetime_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_set_key_lifetime);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_set_key_lifetime_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_get_key_id_CallInstance;
  if (Mock.psa_get_key_id_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_get_key_id);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_get_key_id_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_get_key_lifetime_CallInstance;
  if (Mock.psa_get_key_lifetime_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_get_key_lifetime);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_get_key_lifetime_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_set_key_usage_flags_CallInstance;
  if (Mock.psa_set_key_usage_flags_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_set_key_usage_flags);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_set_key_usage_flags_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_get_key_usage_flags_CallInstance;
  if (Mock.psa_get_key_usage_flags_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_get_key_usage_flags);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_get_key_usage_flags_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_set_key_algorithm_CallInstance;
  if (Mock.psa_set_key_algorithm_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_set_key_algorithm);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_set_key_algorithm_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_get_key_algorithm_CallInstance;
  if (Mock.psa_get_key_algorithm_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_get_key_algorithm);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_get_key_algorithm_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_set_key_type_CallInstance;
  if (Mock.psa_set_key_type_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_set_key_type);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_set_key_type_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_set_key_bits_CallInstance;
  if (Mock.psa_set_key_bits_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_set_key_bits);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_set_key_bits_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_get_key_type_CallInstance;
  if (Mock.psa_get_key_type_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_get_key_type);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_get_key_type_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_get_key_bits_CallInstance;
  if (Mock.psa_get_key_bits_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_get_key_bits);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_get_key_bits_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_get_key_attributes_CallInstance;
  if (Mock.psa_get_key_attributes_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_get_key_attributes);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_get_key_attributes_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_reset_key_attributes_CallInstance;
  if (Mock.psa_reset_key_attributes_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_reset_key_attributes);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_reset_key_attributes_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_purge_key_CallInstance;
  if (Mock.psa_purge_key_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_purge_key);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_purge_key_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_copy_key_CallInstance;
  if (Mock.psa_copy_key_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_copy_key);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_copy_key_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_destroy_key_CallInstance;
  if (Mock.psa_destroy_key_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_destroy_key);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_destroy_key_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_import_key_CallInstance;
  if (Mock.psa_import_key_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_import_key);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_import_key_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_export_key_CallInstance;
  if (Mock.psa_export_key_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_export_key);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_export_key_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_export_public_key_CallInstance;
  if (Mock.psa_export_public_key_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_export_public_key);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_export_public_key_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_hash_compute_CallInstance;
  if (Mock.psa_hash_compute_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_hash_compute);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_hash_compute_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_hash_compare_CallInstance;
  if (Mock.psa_hash_compare_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_hash_compare);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_hash_compare_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_hash_operation_init_CallInstance;
  if (Mock.psa_hash_operation_init_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_hash_operation_init);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_hash_operation_init_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_hash_setup_CallInstance;
  if (Mock.psa_hash_setup_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_hash_setup);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_hash_setup_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_hash_update_CallInstance;
  if (Mock.psa_hash_update_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_hash_update);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_hash_update_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_hash_finish_CallInstance;
  if (Mock.psa_hash_finish_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_hash_finish);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_hash_finish_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_hash_verify_CallInstance;
  if (Mock.psa_hash_verify_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_hash_verify);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_hash_verify_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_hash_abort_CallInstance;
  if (Mock.psa_hash_abort_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_hash_abort);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_hash_abort_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_hash_clone_CallInstance;
  if (Mock.psa_hash_clone_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_hash_clone);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_hash_clone_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_mac_compute_CallInstance;
  if (Mock.psa_mac_compute_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_mac_compute);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_mac_compute_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_mac_verify_CallInstance;
  if (Mock.psa_mac_verify_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_mac_verify);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_mac_verify_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_mac_operation_init_CallInstance;
  if (Mock.psa_mac_operation_init_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_mac_operation_init);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_mac_operation_init_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_mac_sign_setup_CallInstance;
  if (Mock.psa_mac_sign_setup_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_mac_sign_setup);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_mac_sign_setup_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_mac_verify_setup_CallInstance;
  if (Mock.psa_mac_verify_setup_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_mac_verify_setup);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_mac_verify_setup_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_mac_update_CallInstance;
  if (Mock.psa_mac_update_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_mac_update);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_mac_update_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_mac_sign_finish_CallInstance;
  if (Mock.psa_mac_sign_finish_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_mac_sign_finish);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_mac_sign_finish_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_mac_verify_finish_CallInstance;
  if (Mock.psa_mac_verify_finish_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_mac_verify_finish);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_mac_verify_finish_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_mac_abort_CallInstance;
  if (Mock.psa_mac_abort_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_mac_abort);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_mac_abort_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_cipher_encrypt_CallInstance;
  if (Mock.psa_cipher_encrypt_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_cipher_encrypt);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_cipher_encrypt_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_cipher_decrypt_CallInstance;
  if (Mock.psa_cipher_decrypt_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_cipher_decrypt);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_cipher_decrypt_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_cipher_operation_init_CallInstance;
  if (Mock.psa_cipher_operation_init_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_cipher_operation_init);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_cipher_operation_init_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_cipher_encrypt_setup_CallInstance;
  if (Mock.psa_cipher_encrypt_setup_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_cipher_encrypt_setup);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_cipher_encrypt_setup_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_cipher_decrypt_setup_CallInstance;
  if (Mock.psa_cipher_decrypt_setup_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_cipher_decrypt_setup);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_cipher_decrypt_setup_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_cipher_generate_iv_CallInstance;
  if (Mock.psa_cipher_generate_iv_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_cipher_generate_iv);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_cipher_generate_iv_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_cipher_set_iv_CallInstance;
  if (Mock.psa_cipher_set_iv_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_cipher_set_iv);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_cipher_set_iv_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_cipher_update_CallInstance;
  if (Mock.psa_cipher_update_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_cipher_update);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_cipher_update_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_cipher_finish_CallInstance;
  if (Mock.psa_cipher_finish_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_cipher_finish);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_cipher_finish_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_cipher_abort_CallInstance;
  if (Mock.psa_cipher_abort_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_cipher_abort);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_cipher_abort_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_aead_encrypt_CallInstance;
  if (Mock.psa_aead_encrypt_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_encrypt);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_aead_encrypt_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_aead_decrypt_CallInstance;
  if (Mock.psa_aead_decrypt_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_decrypt);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_aead_decrypt_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_aead_operation_init_CallInstance;
  if (Mock.psa_aead_operation_init_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_operation_init);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_aead_operation_init_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_aead_encrypt_setup_CallInstance;
  if (Mock.psa_aead_encrypt_setup_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_encrypt_setup);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_aead_encrypt_setup_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_aead_decrypt_setup_CallInstance;
  if (Mock.psa_aead_decrypt_setup_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_decrypt_setup);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_aead_decrypt_setup_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_aead_generate_nonce_CallInstance;
  if (Mock.psa_aead_generate_nonce_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_generate_nonce);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_aead_generate_nonce_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_aead_set_nonce_CallInstance;
  if (Mock.psa_aead_set_nonce_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_set_nonce);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_aead_set_nonce_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_aead_set_lengths_CallInstance;
  if (Mock.psa_aead_set_lengths_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_set_lengths);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_aead_set_lengths_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_aead_update_ad_CallInstance;
  if (Mock.psa_aead_update_ad_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_update_ad);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_aead_update_ad_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_aead_update_CallInstance;
  if (Mock.psa_aead_update_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_update);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_aead_update_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_aead_finish_CallInstance;
  if (Mock.psa_aead_finish_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_finish);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_aead_finish_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_aead_verify_CallInstance;
  if (Mock.psa_aead_verify_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_verify);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_aead_verify_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_aead_abort_CallInstance;
  if (Mock.psa_aead_abort_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_aead_abort);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_aead_abort_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_sign_message_CallInstance;
  if (Mock.psa_sign_message_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_sign_message);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_sign_message_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_verify_message_CallInstance;
  if (Mock.psa_verify_message_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_verify_message);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_verify_message_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_sign_hash_CallInstance;
  if (Mock.psa_sign_hash_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_sign_hash);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_sign_hash_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_verify_hash_CallInstance;
  if (Mock.psa_verify_hash_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_verify_hash);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_verify_hash_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_asymmetric_encrypt_CallInstance;
  if (Mock.psa_asymmetric_encrypt_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_asymmetric_encrypt);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_asymmetric_encrypt_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_asymmetric_decrypt_CallInstance;
  if (Mock.psa_asymmetric_decrypt_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_asymmetric_decrypt);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_asymmetric_decrypt_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_key_derivation_operation_init_CallInstance;
  if (Mock.psa_key_derivation_operation_init_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_operation_init);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_key_derivation_operation_init_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_key_derivation_setup_CallInstance;
  if (Mock.psa_key_derivation_setup_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_setup);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_key_derivation_setup_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_key_derivation_get_capacity_CallInstance;
  if (Mock.psa_key_derivation_get_capacity_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_get_capacity);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_key_derivation_get_capacity_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_key_derivation_set_capacity_CallInstance;
  if (Mock.psa_key_derivation_set_capacity_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_set_capacity);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_key_derivation_set_capacity_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_key_derivation_input_bytes_CallInstance;
  if (Mock.psa_key_derivation_input_bytes_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_input_bytes);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_key_derivation_input_bytes_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_key_derivation_input_integer_CallInstance;
  if (Mock.psa_key_derivation_input_integer_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_input_integer);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_key_derivation_input_integer_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_key_derivation_input_key_CallInstance;
  if (Mock.psa_key_derivation_input_key_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_input_key);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_key_derivation_input_key_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_key_derivation_key_agreement_CallInstance;
  if (Mock.psa_key_derivation_key_agreement_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_key_agreement);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_key_derivation_key_agreement_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_key_derivation_output_bytes_CallInstance;
  if (Mock.psa_key_derivation_output_bytes_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_output_bytes);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_key_derivation_output_bytes_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_key_derivation_output_key_CallInstance;
  if (Mock.psa_key_derivation_output_key_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_output_key);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_key_derivation_output_key_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_key_derivation_verify_bytes_CallInstance;
  if (Mock.psa_key_derivation_verify_bytes_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_verify_bytes);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_key_derivation_verify_bytes_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_key_derivation_verify_key_CallInstance;
  if (Mock.psa_key_derivation_verify_key_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_verify_key);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_key_derivation_verify_key_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_key_derivation_abort_CallInstance;
  if (Mock.psa_key_derivation_abort_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_key_derivation_abort);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_key_derivation_abort_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_raw_key_agreement_CallInstance;
  if (Mock.psa_raw_key_agreement_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_raw_key_agreement);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_raw_key_agreement_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_generate_random_CallInstance;
  if (Mock.psa_generate_random_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_generate_random);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_generate_random_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.psa_generate_key_CallInstance;
  if (Mock.psa_generate_key_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_psa_generate_key);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.psa_generate_key_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
}

void mock_crypto_Init(void)
{
  mock_crypto_Destroy();
}

void mock_crypto_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

psa_status_t psa_crypto_init(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_crypto_init_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_crypto_init);
  cmock_call_instance = (CMOCK_psa_crypto_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_crypto_init_CallInstance);
  Mock.psa_crypto_init_CallInstance = CMock_Guts_MemNext(Mock.psa_crypto_init_CallInstance);
  if (Mock.psa_crypto_init_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_crypto_init_FinalReturn;
    memcpy((void*)(&Mock.psa_crypto_init_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_crypto_init_CallbackBool &&
      Mock.psa_crypto_init_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_crypto_init_CallbackFunctionPointer(Mock.psa_crypto_init_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.psa_crypto_init_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_crypto_init_CallbackFunctionPointer(Mock.psa_crypto_init_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void psa_crypto_init_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_crypto_init_CALL_INSTANCE));
  CMOCK_psa_crypto_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_crypto_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_crypto_init_CallInstance = CMock_Guts_MemChain(Mock.psa_crypto_init_CallInstance, cmock_guts_index);
  Mock.psa_crypto_init_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_crypto_init_IgnoreBool = (char)1;
}

void psa_crypto_init_CMockStopIgnore(void)
{
  if(Mock.psa_crypto_init_IgnoreBool)
    Mock.psa_crypto_init_CallInstance = CMock_Guts_MemNext(Mock.psa_crypto_init_CallInstance);
  Mock.psa_crypto_init_IgnoreBool = (char)0;
}

void psa_crypto_init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_crypto_init_CALL_INSTANCE));
  CMOCK_psa_crypto_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_crypto_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_crypto_init_CallInstance = CMock_Guts_MemChain(Mock.psa_crypto_init_CallInstance, cmock_guts_index);
  Mock.psa_crypto_init_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_crypto_init_AddCallback(CMOCK_psa_crypto_init_CALLBACK Callback)
{
  Mock.psa_crypto_init_IgnoreBool = (char)0;
  Mock.psa_crypto_init_CallbackBool = (char)1;
  Mock.psa_crypto_init_CallbackFunctionPointer = Callback;
}

void psa_crypto_init_Stub(CMOCK_psa_crypto_init_CALLBACK Callback)
{
  Mock.psa_crypto_init_IgnoreBool = (char)0;
  Mock.psa_crypto_init_CallbackBool = (char)0;
  Mock.psa_crypto_init_CallbackFunctionPointer = Callback;
}

psa_key_attributes_t psa_key_attributes_init(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_attributes_init_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_attributes_init);
  cmock_call_instance = (CMOCK_psa_key_attributes_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_attributes_init_CallInstance);
  Mock.psa_key_attributes_init_CallInstance = CMock_Guts_MemNext(Mock.psa_key_attributes_init_CallInstance);
  if (Mock.psa_key_attributes_init_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_key_attributes_init_FinalReturn;
    memcpy((void*)(&Mock.psa_key_attributes_init_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_key_attributes_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_key_attributes_t) ? 1 : -1])); /* add psa_key_attributes_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_key_attributes_init_CallbackBool &&
      Mock.psa_key_attributes_init_CallbackFunctionPointer != NULL)
  {
    psa_key_attributes_t cmock_cb_ret = Mock.psa_key_attributes_init_CallbackFunctionPointer(Mock.psa_key_attributes_init_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.psa_key_attributes_init_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_key_attributes_init_CallbackFunctionPointer(Mock.psa_key_attributes_init_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void psa_key_attributes_init_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_attributes_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_attributes_init_CALL_INSTANCE));
  CMOCK_psa_key_attributes_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_attributes_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_attributes_init_CallInstance = CMock_Guts_MemChain(Mock.psa_key_attributes_init_CallInstance, cmock_guts_index);
  Mock.psa_key_attributes_init_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_key_attributes_init_IgnoreBool = (char)1;
}

void psa_key_attributes_init_CMockStopIgnore(void)
{
  if(Mock.psa_key_attributes_init_IgnoreBool)
    Mock.psa_key_attributes_init_CallInstance = CMock_Guts_MemNext(Mock.psa_key_attributes_init_CallInstance);
  Mock.psa_key_attributes_init_IgnoreBool = (char)0;
}

void psa_key_attributes_init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_attributes_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_attributes_init_CALL_INSTANCE));
  CMOCK_psa_key_attributes_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_attributes_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_attributes_init_CallInstance = CMock_Guts_MemChain(Mock.psa_key_attributes_init_CallInstance, cmock_guts_index);
  Mock.psa_key_attributes_init_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_key_attributes_t[sizeof(cmock_to_return) == sizeof(psa_key_attributes_t) ? 1 : -1])); /* add psa_key_attributes_t to :treat_as_array if this causes an error */
}

void psa_key_attributes_init_AddCallback(CMOCK_psa_key_attributes_init_CALLBACK Callback)
{
  Mock.psa_key_attributes_init_IgnoreBool = (char)0;
  Mock.psa_key_attributes_init_CallbackBool = (char)1;
  Mock.psa_key_attributes_init_CallbackFunctionPointer = Callback;
}

void psa_key_attributes_init_Stub(CMOCK_psa_key_attributes_init_CALLBACK Callback)
{
  Mock.psa_key_attributes_init_IgnoreBool = (char)0;
  Mock.psa_key_attributes_init_CallbackBool = (char)0;
  Mock.psa_key_attributes_init_CallbackFunctionPointer = Callback;
}

void psa_set_key_id(psa_key_attributes_t* attributes, psa_key_id_t key)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_set_key_id_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_set_key_id);
  cmock_call_instance = (CMOCK_psa_set_key_id_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_set_key_id_CallInstance);
  Mock.psa_set_key_id_CallInstance = CMock_Guts_MemNext(Mock.psa_set_key_id_CallInstance);
  if (Mock.psa_set_key_id_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.psa_set_key_id_CallbackBool &&
      Mock.psa_set_key_id_CallbackFunctionPointer != NULL)
  {
    Mock.psa_set_key_id_CallbackFunctionPointer(attributes, key, Mock.psa_set_key_id_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_set_key_id,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_set_key_id,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_set_key_id_CallbackFunctionPointer != NULL)
  {
    Mock.psa_set_key_id_CallbackFunctionPointer(attributes, key, Mock.psa_set_key_id_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_psa_set_key_id(CMOCK_psa_set_key_id_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes, psa_key_id_t key);
void CMockExpectParameters_psa_set_key_id(CMOCK_psa_set_key_id_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes, psa_key_id_t key)
{
  cmock_call_instance->Expected_attributes = attributes;
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
}

void psa_set_key_id_CMockIgnore(void)
{
  Mock.psa_set_key_id_IgnoreBool = (char)1;
}

void psa_set_key_id_CMockStopIgnore(void)
{
  Mock.psa_set_key_id_IgnoreBool = (char)0;
}

void psa_set_key_id_CMockExpect(UNITY_LINE_TYPE cmock_line, psa_key_attributes_t* attributes, psa_key_id_t key)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_set_key_id_CALL_INSTANCE));
  CMOCK_psa_set_key_id_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_set_key_id_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_set_key_id_CallInstance = CMock_Guts_MemChain(Mock.psa_set_key_id_CallInstance, cmock_guts_index);
  Mock.psa_set_key_id_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_set_key_id(cmock_call_instance, attributes, key);
}

void psa_set_key_id_AddCallback(CMOCK_psa_set_key_id_CALLBACK Callback)
{
  Mock.psa_set_key_id_IgnoreBool = (char)0;
  Mock.psa_set_key_id_CallbackBool = (char)1;
  Mock.psa_set_key_id_CallbackFunctionPointer = Callback;
}

void psa_set_key_id_Stub(CMOCK_psa_set_key_id_CALLBACK Callback)
{
  Mock.psa_set_key_id_IgnoreBool = (char)0;
  Mock.psa_set_key_id_CallbackBool = (char)0;
  Mock.psa_set_key_id_CallbackFunctionPointer = Callback;
}

void psa_set_key_lifetime(psa_key_attributes_t* attributes, psa_key_lifetime_t lifetime)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_set_key_lifetime_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_set_key_lifetime);
  cmock_call_instance = (CMOCK_psa_set_key_lifetime_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_set_key_lifetime_CallInstance);
  Mock.psa_set_key_lifetime_CallInstance = CMock_Guts_MemNext(Mock.psa_set_key_lifetime_CallInstance);
  if (Mock.psa_set_key_lifetime_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.psa_set_key_lifetime_CallbackBool &&
      Mock.psa_set_key_lifetime_CallbackFunctionPointer != NULL)
  {
    Mock.psa_set_key_lifetime_CallbackFunctionPointer(attributes, lifetime, Mock.psa_set_key_lifetime_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_set_key_lifetime,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_set_key_lifetime,CMockString_lifetime);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_lifetime), (void*)(&lifetime), sizeof(psa_key_lifetime_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_set_key_lifetime_CallbackFunctionPointer != NULL)
  {
    Mock.psa_set_key_lifetime_CallbackFunctionPointer(attributes, lifetime, Mock.psa_set_key_lifetime_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_psa_set_key_lifetime(CMOCK_psa_set_key_lifetime_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes, psa_key_lifetime_t lifetime);
void CMockExpectParameters_psa_set_key_lifetime(CMOCK_psa_set_key_lifetime_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes, psa_key_lifetime_t lifetime)
{
  cmock_call_instance->Expected_attributes = attributes;
  memcpy((void*)(&cmock_call_instance->Expected_lifetime), (void*)(&lifetime),
         sizeof(psa_key_lifetime_t[sizeof(lifetime) == sizeof(psa_key_lifetime_t) ? 1 : -1])); /* add psa_key_lifetime_t to :treat_as_array if this causes an error */
}

void psa_set_key_lifetime_CMockIgnore(void)
{
  Mock.psa_set_key_lifetime_IgnoreBool = (char)1;
}

void psa_set_key_lifetime_CMockStopIgnore(void)
{
  Mock.psa_set_key_lifetime_IgnoreBool = (char)0;
}

void psa_set_key_lifetime_CMockExpect(UNITY_LINE_TYPE cmock_line, psa_key_attributes_t* attributes, psa_key_lifetime_t lifetime)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_set_key_lifetime_CALL_INSTANCE));
  CMOCK_psa_set_key_lifetime_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_set_key_lifetime_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_set_key_lifetime_CallInstance = CMock_Guts_MemChain(Mock.psa_set_key_lifetime_CallInstance, cmock_guts_index);
  Mock.psa_set_key_lifetime_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_set_key_lifetime(cmock_call_instance, attributes, lifetime);
}

void psa_set_key_lifetime_AddCallback(CMOCK_psa_set_key_lifetime_CALLBACK Callback)
{
  Mock.psa_set_key_lifetime_IgnoreBool = (char)0;
  Mock.psa_set_key_lifetime_CallbackBool = (char)1;
  Mock.psa_set_key_lifetime_CallbackFunctionPointer = Callback;
}

void psa_set_key_lifetime_Stub(CMOCK_psa_set_key_lifetime_CALLBACK Callback)
{
  Mock.psa_set_key_lifetime_IgnoreBool = (char)0;
  Mock.psa_set_key_lifetime_CallbackBool = (char)0;
  Mock.psa_set_key_lifetime_CallbackFunctionPointer = Callback;
}

psa_key_id_t psa_get_key_id(const psa_key_attributes_t* attributes)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_get_key_id_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_get_key_id);
  cmock_call_instance = (CMOCK_psa_get_key_id_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_get_key_id_CallInstance);
  Mock.psa_get_key_id_CallInstance = CMock_Guts_MemNext(Mock.psa_get_key_id_CallInstance);
  if (Mock.psa_get_key_id_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_get_key_id_FinalReturn;
    memcpy((void*)(&Mock.psa_get_key_id_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_key_id_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_get_key_id_CallbackBool &&
      Mock.psa_get_key_id_CallbackFunctionPointer != NULL)
  {
    psa_key_id_t cmock_cb_ret = Mock.psa_get_key_id_CallbackFunctionPointer(attributes, Mock.psa_get_key_id_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_get_key_id,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(const psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_get_key_id_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_get_key_id_CallbackFunctionPointer(attributes, Mock.psa_get_key_id_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_get_key_id(CMOCK_psa_get_key_id_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes);
void CMockExpectParameters_psa_get_key_id(CMOCK_psa_get_key_id_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes)
{
  cmock_call_instance->Expected_attributes = attributes;
}

void psa_get_key_id_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_get_key_id_CALL_INSTANCE));
  CMOCK_psa_get_key_id_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_get_key_id_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_get_key_id_CallInstance = CMock_Guts_MemChain(Mock.psa_get_key_id_CallInstance, cmock_guts_index);
  Mock.psa_get_key_id_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_get_key_id_IgnoreBool = (char)1;
}

void psa_get_key_id_CMockStopIgnore(void)
{
  if(Mock.psa_get_key_id_IgnoreBool)
    Mock.psa_get_key_id_CallInstance = CMock_Guts_MemNext(Mock.psa_get_key_id_CallInstance);
  Mock.psa_get_key_id_IgnoreBool = (char)0;
}

void psa_get_key_id_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const psa_key_attributes_t* attributes, psa_key_id_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_get_key_id_CALL_INSTANCE));
  CMOCK_psa_get_key_id_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_get_key_id_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_get_key_id_CallInstance = CMock_Guts_MemChain(Mock.psa_get_key_id_CallInstance, cmock_guts_index);
  Mock.psa_get_key_id_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_get_key_id(cmock_call_instance, attributes);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_key_id_t[sizeof(cmock_to_return) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
}

void psa_get_key_id_AddCallback(CMOCK_psa_get_key_id_CALLBACK Callback)
{
  Mock.psa_get_key_id_IgnoreBool = (char)0;
  Mock.psa_get_key_id_CallbackBool = (char)1;
  Mock.psa_get_key_id_CallbackFunctionPointer = Callback;
}

void psa_get_key_id_Stub(CMOCK_psa_get_key_id_CALLBACK Callback)
{
  Mock.psa_get_key_id_IgnoreBool = (char)0;
  Mock.psa_get_key_id_CallbackBool = (char)0;
  Mock.psa_get_key_id_CallbackFunctionPointer = Callback;
}

psa_key_lifetime_t psa_get_key_lifetime(const psa_key_attributes_t* attributes)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_get_key_lifetime_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_get_key_lifetime);
  cmock_call_instance = (CMOCK_psa_get_key_lifetime_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_get_key_lifetime_CallInstance);
  Mock.psa_get_key_lifetime_CallInstance = CMock_Guts_MemNext(Mock.psa_get_key_lifetime_CallInstance);
  if (Mock.psa_get_key_lifetime_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_get_key_lifetime_FinalReturn;
    memcpy((void*)(&Mock.psa_get_key_lifetime_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_key_lifetime_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_key_lifetime_t) ? 1 : -1])); /* add psa_key_lifetime_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_get_key_lifetime_CallbackBool &&
      Mock.psa_get_key_lifetime_CallbackFunctionPointer != NULL)
  {
    psa_key_lifetime_t cmock_cb_ret = Mock.psa_get_key_lifetime_CallbackFunctionPointer(attributes, Mock.psa_get_key_lifetime_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_get_key_lifetime,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(const psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_get_key_lifetime_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_get_key_lifetime_CallbackFunctionPointer(attributes, Mock.psa_get_key_lifetime_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_get_key_lifetime(CMOCK_psa_get_key_lifetime_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes);
void CMockExpectParameters_psa_get_key_lifetime(CMOCK_psa_get_key_lifetime_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes)
{
  cmock_call_instance->Expected_attributes = attributes;
}

void psa_get_key_lifetime_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_lifetime_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_get_key_lifetime_CALL_INSTANCE));
  CMOCK_psa_get_key_lifetime_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_get_key_lifetime_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_get_key_lifetime_CallInstance = CMock_Guts_MemChain(Mock.psa_get_key_lifetime_CallInstance, cmock_guts_index);
  Mock.psa_get_key_lifetime_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_get_key_lifetime_IgnoreBool = (char)1;
}

void psa_get_key_lifetime_CMockStopIgnore(void)
{
  if(Mock.psa_get_key_lifetime_IgnoreBool)
    Mock.psa_get_key_lifetime_CallInstance = CMock_Guts_MemNext(Mock.psa_get_key_lifetime_CallInstance);
  Mock.psa_get_key_lifetime_IgnoreBool = (char)0;
}

void psa_get_key_lifetime_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const psa_key_attributes_t* attributes, psa_key_lifetime_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_get_key_lifetime_CALL_INSTANCE));
  CMOCK_psa_get_key_lifetime_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_get_key_lifetime_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_get_key_lifetime_CallInstance = CMock_Guts_MemChain(Mock.psa_get_key_lifetime_CallInstance, cmock_guts_index);
  Mock.psa_get_key_lifetime_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_get_key_lifetime(cmock_call_instance, attributes);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_key_lifetime_t[sizeof(cmock_to_return) == sizeof(psa_key_lifetime_t) ? 1 : -1])); /* add psa_key_lifetime_t to :treat_as_array if this causes an error */
}

void psa_get_key_lifetime_AddCallback(CMOCK_psa_get_key_lifetime_CALLBACK Callback)
{
  Mock.psa_get_key_lifetime_IgnoreBool = (char)0;
  Mock.psa_get_key_lifetime_CallbackBool = (char)1;
  Mock.psa_get_key_lifetime_CallbackFunctionPointer = Callback;
}

void psa_get_key_lifetime_Stub(CMOCK_psa_get_key_lifetime_CALLBACK Callback)
{
  Mock.psa_get_key_lifetime_IgnoreBool = (char)0;
  Mock.psa_get_key_lifetime_CallbackBool = (char)0;
  Mock.psa_get_key_lifetime_CallbackFunctionPointer = Callback;
}

void psa_set_key_usage_flags(psa_key_attributes_t* attributes, psa_key_usage_t usage_flags)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_set_key_usage_flags_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_set_key_usage_flags);
  cmock_call_instance = (CMOCK_psa_set_key_usage_flags_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_set_key_usage_flags_CallInstance);
  Mock.psa_set_key_usage_flags_CallInstance = CMock_Guts_MemNext(Mock.psa_set_key_usage_flags_CallInstance);
  if (Mock.psa_set_key_usage_flags_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.psa_set_key_usage_flags_CallbackBool &&
      Mock.psa_set_key_usage_flags_CallbackFunctionPointer != NULL)
  {
    Mock.psa_set_key_usage_flags_CallbackFunctionPointer(attributes, usage_flags, Mock.psa_set_key_usage_flags_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_set_key_usage_flags,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_set_key_usage_flags,CMockString_usage_flags);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_usage_flags), (void*)(&usage_flags), sizeof(psa_key_usage_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_set_key_usage_flags_CallbackFunctionPointer != NULL)
  {
    Mock.psa_set_key_usage_flags_CallbackFunctionPointer(attributes, usage_flags, Mock.psa_set_key_usage_flags_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_psa_set_key_usage_flags(CMOCK_psa_set_key_usage_flags_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes, psa_key_usage_t usage_flags);
void CMockExpectParameters_psa_set_key_usage_flags(CMOCK_psa_set_key_usage_flags_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes, psa_key_usage_t usage_flags)
{
  cmock_call_instance->Expected_attributes = attributes;
  memcpy((void*)(&cmock_call_instance->Expected_usage_flags), (void*)(&usage_flags),
         sizeof(psa_key_usage_t[sizeof(usage_flags) == sizeof(psa_key_usage_t) ? 1 : -1])); /* add psa_key_usage_t to :treat_as_array if this causes an error */
}

void psa_set_key_usage_flags_CMockIgnore(void)
{
  Mock.psa_set_key_usage_flags_IgnoreBool = (char)1;
}

void psa_set_key_usage_flags_CMockStopIgnore(void)
{
  Mock.psa_set_key_usage_flags_IgnoreBool = (char)0;
}

void psa_set_key_usage_flags_CMockExpect(UNITY_LINE_TYPE cmock_line, psa_key_attributes_t* attributes, psa_key_usage_t usage_flags)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_set_key_usage_flags_CALL_INSTANCE));
  CMOCK_psa_set_key_usage_flags_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_set_key_usage_flags_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_set_key_usage_flags_CallInstance = CMock_Guts_MemChain(Mock.psa_set_key_usage_flags_CallInstance, cmock_guts_index);
  Mock.psa_set_key_usage_flags_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_set_key_usage_flags(cmock_call_instance, attributes, usage_flags);
}

void psa_set_key_usage_flags_AddCallback(CMOCK_psa_set_key_usage_flags_CALLBACK Callback)
{
  Mock.psa_set_key_usage_flags_IgnoreBool = (char)0;
  Mock.psa_set_key_usage_flags_CallbackBool = (char)1;
  Mock.psa_set_key_usage_flags_CallbackFunctionPointer = Callback;
}

void psa_set_key_usage_flags_Stub(CMOCK_psa_set_key_usage_flags_CALLBACK Callback)
{
  Mock.psa_set_key_usage_flags_IgnoreBool = (char)0;
  Mock.psa_set_key_usage_flags_CallbackBool = (char)0;
  Mock.psa_set_key_usage_flags_CallbackFunctionPointer = Callback;
}

psa_key_usage_t psa_get_key_usage_flags(const psa_key_attributes_t* attributes)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_get_key_usage_flags_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_get_key_usage_flags);
  cmock_call_instance = (CMOCK_psa_get_key_usage_flags_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_get_key_usage_flags_CallInstance);
  Mock.psa_get_key_usage_flags_CallInstance = CMock_Guts_MemNext(Mock.psa_get_key_usage_flags_CallInstance);
  if (Mock.psa_get_key_usage_flags_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_get_key_usage_flags_FinalReturn;
    memcpy((void*)(&Mock.psa_get_key_usage_flags_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_key_usage_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_key_usage_t) ? 1 : -1])); /* add psa_key_usage_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_get_key_usage_flags_CallbackBool &&
      Mock.psa_get_key_usage_flags_CallbackFunctionPointer != NULL)
  {
    psa_key_usage_t cmock_cb_ret = Mock.psa_get_key_usage_flags_CallbackFunctionPointer(attributes, Mock.psa_get_key_usage_flags_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_get_key_usage_flags,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(const psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_get_key_usage_flags_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_get_key_usage_flags_CallbackFunctionPointer(attributes, Mock.psa_get_key_usage_flags_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_get_key_usage_flags(CMOCK_psa_get_key_usage_flags_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes);
void CMockExpectParameters_psa_get_key_usage_flags(CMOCK_psa_get_key_usage_flags_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes)
{
  cmock_call_instance->Expected_attributes = attributes;
}

void psa_get_key_usage_flags_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_usage_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_get_key_usage_flags_CALL_INSTANCE));
  CMOCK_psa_get_key_usage_flags_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_get_key_usage_flags_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_get_key_usage_flags_CallInstance = CMock_Guts_MemChain(Mock.psa_get_key_usage_flags_CallInstance, cmock_guts_index);
  Mock.psa_get_key_usage_flags_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_get_key_usage_flags_IgnoreBool = (char)1;
}

void psa_get_key_usage_flags_CMockStopIgnore(void)
{
  if(Mock.psa_get_key_usage_flags_IgnoreBool)
    Mock.psa_get_key_usage_flags_CallInstance = CMock_Guts_MemNext(Mock.psa_get_key_usage_flags_CallInstance);
  Mock.psa_get_key_usage_flags_IgnoreBool = (char)0;
}

void psa_get_key_usage_flags_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const psa_key_attributes_t* attributes, psa_key_usage_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_get_key_usage_flags_CALL_INSTANCE));
  CMOCK_psa_get_key_usage_flags_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_get_key_usage_flags_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_get_key_usage_flags_CallInstance = CMock_Guts_MemChain(Mock.psa_get_key_usage_flags_CallInstance, cmock_guts_index);
  Mock.psa_get_key_usage_flags_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_get_key_usage_flags(cmock_call_instance, attributes);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_key_usage_t[sizeof(cmock_to_return) == sizeof(psa_key_usage_t) ? 1 : -1])); /* add psa_key_usage_t to :treat_as_array if this causes an error */
}

void psa_get_key_usage_flags_AddCallback(CMOCK_psa_get_key_usage_flags_CALLBACK Callback)
{
  Mock.psa_get_key_usage_flags_IgnoreBool = (char)0;
  Mock.psa_get_key_usage_flags_CallbackBool = (char)1;
  Mock.psa_get_key_usage_flags_CallbackFunctionPointer = Callback;
}

void psa_get_key_usage_flags_Stub(CMOCK_psa_get_key_usage_flags_CALLBACK Callback)
{
  Mock.psa_get_key_usage_flags_IgnoreBool = (char)0;
  Mock.psa_get_key_usage_flags_CallbackBool = (char)0;
  Mock.psa_get_key_usage_flags_CallbackFunctionPointer = Callback;
}

void psa_set_key_algorithm(psa_key_attributes_t* attributes, psa_algorithm_t alg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_set_key_algorithm_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_set_key_algorithm);
  cmock_call_instance = (CMOCK_psa_set_key_algorithm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_set_key_algorithm_CallInstance);
  Mock.psa_set_key_algorithm_CallInstance = CMock_Guts_MemNext(Mock.psa_set_key_algorithm_CallInstance);
  if (Mock.psa_set_key_algorithm_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.psa_set_key_algorithm_CallbackBool &&
      Mock.psa_set_key_algorithm_CallbackFunctionPointer != NULL)
  {
    Mock.psa_set_key_algorithm_CallbackFunctionPointer(attributes, alg, Mock.psa_set_key_algorithm_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_set_key_algorithm,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_set_key_algorithm,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_set_key_algorithm_CallbackFunctionPointer != NULL)
  {
    Mock.psa_set_key_algorithm_CallbackFunctionPointer(attributes, alg, Mock.psa_set_key_algorithm_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_psa_set_key_algorithm(CMOCK_psa_set_key_algorithm_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes, psa_algorithm_t alg);
void CMockExpectParameters_psa_set_key_algorithm(CMOCK_psa_set_key_algorithm_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes, psa_algorithm_t alg)
{
  cmock_call_instance->Expected_attributes = attributes;
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
}

void psa_set_key_algorithm_CMockIgnore(void)
{
  Mock.psa_set_key_algorithm_IgnoreBool = (char)1;
}

void psa_set_key_algorithm_CMockStopIgnore(void)
{
  Mock.psa_set_key_algorithm_IgnoreBool = (char)0;
}

void psa_set_key_algorithm_CMockExpect(UNITY_LINE_TYPE cmock_line, psa_key_attributes_t* attributes, psa_algorithm_t alg)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_set_key_algorithm_CALL_INSTANCE));
  CMOCK_psa_set_key_algorithm_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_set_key_algorithm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_set_key_algorithm_CallInstance = CMock_Guts_MemChain(Mock.psa_set_key_algorithm_CallInstance, cmock_guts_index);
  Mock.psa_set_key_algorithm_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_set_key_algorithm(cmock_call_instance, attributes, alg);
}

void psa_set_key_algorithm_AddCallback(CMOCK_psa_set_key_algorithm_CALLBACK Callback)
{
  Mock.psa_set_key_algorithm_IgnoreBool = (char)0;
  Mock.psa_set_key_algorithm_CallbackBool = (char)1;
  Mock.psa_set_key_algorithm_CallbackFunctionPointer = Callback;
}

void psa_set_key_algorithm_Stub(CMOCK_psa_set_key_algorithm_CALLBACK Callback)
{
  Mock.psa_set_key_algorithm_IgnoreBool = (char)0;
  Mock.psa_set_key_algorithm_CallbackBool = (char)0;
  Mock.psa_set_key_algorithm_CallbackFunctionPointer = Callback;
}

psa_algorithm_t psa_get_key_algorithm(const psa_key_attributes_t* attributes)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_get_key_algorithm_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_get_key_algorithm);
  cmock_call_instance = (CMOCK_psa_get_key_algorithm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_get_key_algorithm_CallInstance);
  Mock.psa_get_key_algorithm_CallInstance = CMock_Guts_MemNext(Mock.psa_get_key_algorithm_CallInstance);
  if (Mock.psa_get_key_algorithm_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_get_key_algorithm_FinalReturn;
    memcpy((void*)(&Mock.psa_get_key_algorithm_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_algorithm_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_get_key_algorithm_CallbackBool &&
      Mock.psa_get_key_algorithm_CallbackFunctionPointer != NULL)
  {
    psa_algorithm_t cmock_cb_ret = Mock.psa_get_key_algorithm_CallbackFunctionPointer(attributes, Mock.psa_get_key_algorithm_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_get_key_algorithm,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(const psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_get_key_algorithm_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_get_key_algorithm_CallbackFunctionPointer(attributes, Mock.psa_get_key_algorithm_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_get_key_algorithm(CMOCK_psa_get_key_algorithm_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes);
void CMockExpectParameters_psa_get_key_algorithm(CMOCK_psa_get_key_algorithm_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes)
{
  cmock_call_instance->Expected_attributes = attributes;
}

void psa_get_key_algorithm_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_algorithm_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_get_key_algorithm_CALL_INSTANCE));
  CMOCK_psa_get_key_algorithm_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_get_key_algorithm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_get_key_algorithm_CallInstance = CMock_Guts_MemChain(Mock.psa_get_key_algorithm_CallInstance, cmock_guts_index);
  Mock.psa_get_key_algorithm_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_get_key_algorithm_IgnoreBool = (char)1;
}

void psa_get_key_algorithm_CMockStopIgnore(void)
{
  if(Mock.psa_get_key_algorithm_IgnoreBool)
    Mock.psa_get_key_algorithm_CallInstance = CMock_Guts_MemNext(Mock.psa_get_key_algorithm_CallInstance);
  Mock.psa_get_key_algorithm_IgnoreBool = (char)0;
}

void psa_get_key_algorithm_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const psa_key_attributes_t* attributes, psa_algorithm_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_get_key_algorithm_CALL_INSTANCE));
  CMOCK_psa_get_key_algorithm_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_get_key_algorithm_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_get_key_algorithm_CallInstance = CMock_Guts_MemChain(Mock.psa_get_key_algorithm_CallInstance, cmock_guts_index);
  Mock.psa_get_key_algorithm_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_get_key_algorithm(cmock_call_instance, attributes);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_algorithm_t[sizeof(cmock_to_return) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
}

void psa_get_key_algorithm_AddCallback(CMOCK_psa_get_key_algorithm_CALLBACK Callback)
{
  Mock.psa_get_key_algorithm_IgnoreBool = (char)0;
  Mock.psa_get_key_algorithm_CallbackBool = (char)1;
  Mock.psa_get_key_algorithm_CallbackFunctionPointer = Callback;
}

void psa_get_key_algorithm_Stub(CMOCK_psa_get_key_algorithm_CALLBACK Callback)
{
  Mock.psa_get_key_algorithm_IgnoreBool = (char)0;
  Mock.psa_get_key_algorithm_CallbackBool = (char)0;
  Mock.psa_get_key_algorithm_CallbackFunctionPointer = Callback;
}

void psa_set_key_type(psa_key_attributes_t* attributes, psa_key_type_t type)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_set_key_type_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_set_key_type);
  cmock_call_instance = (CMOCK_psa_set_key_type_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_set_key_type_CallInstance);
  Mock.psa_set_key_type_CallInstance = CMock_Guts_MemNext(Mock.psa_set_key_type_CallInstance);
  if (Mock.psa_set_key_type_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.psa_set_key_type_CallbackBool &&
      Mock.psa_set_key_type_CallbackFunctionPointer != NULL)
  {
    Mock.psa_set_key_type_CallbackFunctionPointer(attributes, type, Mock.psa_set_key_type_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_set_key_type,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_set_key_type,CMockString_type);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_type), (void*)(&type), sizeof(psa_key_type_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_set_key_type_CallbackFunctionPointer != NULL)
  {
    Mock.psa_set_key_type_CallbackFunctionPointer(attributes, type, Mock.psa_set_key_type_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_psa_set_key_type(CMOCK_psa_set_key_type_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes, psa_key_type_t type);
void CMockExpectParameters_psa_set_key_type(CMOCK_psa_set_key_type_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes, psa_key_type_t type)
{
  cmock_call_instance->Expected_attributes = attributes;
  memcpy((void*)(&cmock_call_instance->Expected_type), (void*)(&type),
         sizeof(psa_key_type_t[sizeof(type) == sizeof(psa_key_type_t) ? 1 : -1])); /* add psa_key_type_t to :treat_as_array if this causes an error */
}

void psa_set_key_type_CMockIgnore(void)
{
  Mock.psa_set_key_type_IgnoreBool = (char)1;
}

void psa_set_key_type_CMockStopIgnore(void)
{
  Mock.psa_set_key_type_IgnoreBool = (char)0;
}

void psa_set_key_type_CMockExpect(UNITY_LINE_TYPE cmock_line, psa_key_attributes_t* attributes, psa_key_type_t type)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_set_key_type_CALL_INSTANCE));
  CMOCK_psa_set_key_type_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_set_key_type_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_set_key_type_CallInstance = CMock_Guts_MemChain(Mock.psa_set_key_type_CallInstance, cmock_guts_index);
  Mock.psa_set_key_type_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_set_key_type(cmock_call_instance, attributes, type);
}

void psa_set_key_type_AddCallback(CMOCK_psa_set_key_type_CALLBACK Callback)
{
  Mock.psa_set_key_type_IgnoreBool = (char)0;
  Mock.psa_set_key_type_CallbackBool = (char)1;
  Mock.psa_set_key_type_CallbackFunctionPointer = Callback;
}

void psa_set_key_type_Stub(CMOCK_psa_set_key_type_CALLBACK Callback)
{
  Mock.psa_set_key_type_IgnoreBool = (char)0;
  Mock.psa_set_key_type_CallbackBool = (char)0;
  Mock.psa_set_key_type_CallbackFunctionPointer = Callback;
}

void psa_set_key_bits(psa_key_attributes_t* attributes, size_t bits)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_set_key_bits_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_set_key_bits);
  cmock_call_instance = (CMOCK_psa_set_key_bits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_set_key_bits_CallInstance);
  Mock.psa_set_key_bits_CallInstance = CMock_Guts_MemNext(Mock.psa_set_key_bits_CallInstance);
  if (Mock.psa_set_key_bits_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.psa_set_key_bits_CallbackBool &&
      Mock.psa_set_key_bits_CallbackFunctionPointer != NULL)
  {
    Mock.psa_set_key_bits_CallbackFunctionPointer(attributes, bits, Mock.psa_set_key_bits_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_set_key_bits,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_set_key_bits,CMockString_bits);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_bits), (void*)(&bits), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_set_key_bits_CallbackFunctionPointer != NULL)
  {
    Mock.psa_set_key_bits_CallbackFunctionPointer(attributes, bits, Mock.psa_set_key_bits_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_psa_set_key_bits(CMOCK_psa_set_key_bits_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes, size_t bits);
void CMockExpectParameters_psa_set_key_bits(CMOCK_psa_set_key_bits_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes, size_t bits)
{
  cmock_call_instance->Expected_attributes = attributes;
  memcpy((void*)(&cmock_call_instance->Expected_bits), (void*)(&bits),
         sizeof(size_t[sizeof(bits) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_set_key_bits_CMockIgnore(void)
{
  Mock.psa_set_key_bits_IgnoreBool = (char)1;
}

void psa_set_key_bits_CMockStopIgnore(void)
{
  Mock.psa_set_key_bits_IgnoreBool = (char)0;
}

void psa_set_key_bits_CMockExpect(UNITY_LINE_TYPE cmock_line, psa_key_attributes_t* attributes, size_t bits)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_set_key_bits_CALL_INSTANCE));
  CMOCK_psa_set_key_bits_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_set_key_bits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_set_key_bits_CallInstance = CMock_Guts_MemChain(Mock.psa_set_key_bits_CallInstance, cmock_guts_index);
  Mock.psa_set_key_bits_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_set_key_bits(cmock_call_instance, attributes, bits);
}

void psa_set_key_bits_AddCallback(CMOCK_psa_set_key_bits_CALLBACK Callback)
{
  Mock.psa_set_key_bits_IgnoreBool = (char)0;
  Mock.psa_set_key_bits_CallbackBool = (char)1;
  Mock.psa_set_key_bits_CallbackFunctionPointer = Callback;
}

void psa_set_key_bits_Stub(CMOCK_psa_set_key_bits_CALLBACK Callback)
{
  Mock.psa_set_key_bits_IgnoreBool = (char)0;
  Mock.psa_set_key_bits_CallbackBool = (char)0;
  Mock.psa_set_key_bits_CallbackFunctionPointer = Callback;
}

psa_key_type_t psa_get_key_type(const psa_key_attributes_t* attributes)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_get_key_type_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_get_key_type);
  cmock_call_instance = (CMOCK_psa_get_key_type_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_get_key_type_CallInstance);
  Mock.psa_get_key_type_CallInstance = CMock_Guts_MemNext(Mock.psa_get_key_type_CallInstance);
  if (Mock.psa_get_key_type_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_get_key_type_FinalReturn;
    memcpy((void*)(&Mock.psa_get_key_type_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_key_type_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_key_type_t) ? 1 : -1])); /* add psa_key_type_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_get_key_type_CallbackBool &&
      Mock.psa_get_key_type_CallbackFunctionPointer != NULL)
  {
    psa_key_type_t cmock_cb_ret = Mock.psa_get_key_type_CallbackFunctionPointer(attributes, Mock.psa_get_key_type_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_get_key_type,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(const psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_get_key_type_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_get_key_type_CallbackFunctionPointer(attributes, Mock.psa_get_key_type_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_get_key_type(CMOCK_psa_get_key_type_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes);
void CMockExpectParameters_psa_get_key_type(CMOCK_psa_get_key_type_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes)
{
  cmock_call_instance->Expected_attributes = attributes;
}

void psa_get_key_type_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_type_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_get_key_type_CALL_INSTANCE));
  CMOCK_psa_get_key_type_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_get_key_type_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_get_key_type_CallInstance = CMock_Guts_MemChain(Mock.psa_get_key_type_CallInstance, cmock_guts_index);
  Mock.psa_get_key_type_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_get_key_type_IgnoreBool = (char)1;
}

void psa_get_key_type_CMockStopIgnore(void)
{
  if(Mock.psa_get_key_type_IgnoreBool)
    Mock.psa_get_key_type_CallInstance = CMock_Guts_MemNext(Mock.psa_get_key_type_CallInstance);
  Mock.psa_get_key_type_IgnoreBool = (char)0;
}

void psa_get_key_type_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const psa_key_attributes_t* attributes, psa_key_type_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_get_key_type_CALL_INSTANCE));
  CMOCK_psa_get_key_type_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_get_key_type_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_get_key_type_CallInstance = CMock_Guts_MemChain(Mock.psa_get_key_type_CallInstance, cmock_guts_index);
  Mock.psa_get_key_type_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_get_key_type(cmock_call_instance, attributes);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_key_type_t[sizeof(cmock_to_return) == sizeof(psa_key_type_t) ? 1 : -1])); /* add psa_key_type_t to :treat_as_array if this causes an error */
}

void psa_get_key_type_AddCallback(CMOCK_psa_get_key_type_CALLBACK Callback)
{
  Mock.psa_get_key_type_IgnoreBool = (char)0;
  Mock.psa_get_key_type_CallbackBool = (char)1;
  Mock.psa_get_key_type_CallbackFunctionPointer = Callback;
}

void psa_get_key_type_Stub(CMOCK_psa_get_key_type_CALLBACK Callback)
{
  Mock.psa_get_key_type_IgnoreBool = (char)0;
  Mock.psa_get_key_type_CallbackBool = (char)0;
  Mock.psa_get_key_type_CallbackFunctionPointer = Callback;
}

size_t psa_get_key_bits(const psa_key_attributes_t* attributes)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_get_key_bits_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_get_key_bits);
  cmock_call_instance = (CMOCK_psa_get_key_bits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_get_key_bits_CallInstance);
  Mock.psa_get_key_bits_CallInstance = CMock_Guts_MemNext(Mock.psa_get_key_bits_CallInstance);
  if (Mock.psa_get_key_bits_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_get_key_bits_FinalReturn;
    memcpy((void*)(&Mock.psa_get_key_bits_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(size_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_get_key_bits_CallbackBool &&
      Mock.psa_get_key_bits_CallbackFunctionPointer != NULL)
  {
    size_t cmock_cb_ret = Mock.psa_get_key_bits_CallbackFunctionPointer(attributes, Mock.psa_get_key_bits_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_get_key_bits,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(const psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_get_key_bits_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_get_key_bits_CallbackFunctionPointer(attributes, Mock.psa_get_key_bits_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_get_key_bits(CMOCK_psa_get_key_bits_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes);
void CMockExpectParameters_psa_get_key_bits(CMOCK_psa_get_key_bits_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes)
{
  cmock_call_instance->Expected_attributes = attributes;
}

void psa_get_key_bits_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_get_key_bits_CALL_INSTANCE));
  CMOCK_psa_get_key_bits_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_get_key_bits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_get_key_bits_CallInstance = CMock_Guts_MemChain(Mock.psa_get_key_bits_CallInstance, cmock_guts_index);
  Mock.psa_get_key_bits_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_get_key_bits_IgnoreBool = (char)1;
}

void psa_get_key_bits_CMockStopIgnore(void)
{
  if(Mock.psa_get_key_bits_IgnoreBool)
    Mock.psa_get_key_bits_CallInstance = CMock_Guts_MemNext(Mock.psa_get_key_bits_CallInstance);
  Mock.psa_get_key_bits_IgnoreBool = (char)0;
}

void psa_get_key_bits_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const psa_key_attributes_t* attributes, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_get_key_bits_CALL_INSTANCE));
  CMOCK_psa_get_key_bits_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_get_key_bits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_get_key_bits_CallInstance = CMock_Guts_MemChain(Mock.psa_get_key_bits_CallInstance, cmock_guts_index);
  Mock.psa_get_key_bits_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_get_key_bits(cmock_call_instance, attributes);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_get_key_bits_AddCallback(CMOCK_psa_get_key_bits_CALLBACK Callback)
{
  Mock.psa_get_key_bits_IgnoreBool = (char)0;
  Mock.psa_get_key_bits_CallbackBool = (char)1;
  Mock.psa_get_key_bits_CallbackFunctionPointer = Callback;
}

void psa_get_key_bits_Stub(CMOCK_psa_get_key_bits_CALLBACK Callback)
{
  Mock.psa_get_key_bits_IgnoreBool = (char)0;
  Mock.psa_get_key_bits_CallbackBool = (char)0;
  Mock.psa_get_key_bits_CallbackFunctionPointer = Callback;
}

psa_status_t psa_get_key_attributes(psa_key_id_t key, psa_key_attributes_t* attributes)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_get_key_attributes_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_get_key_attributes);
  cmock_call_instance = (CMOCK_psa_get_key_attributes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_get_key_attributes_CallInstance);
  Mock.psa_get_key_attributes_CallInstance = CMock_Guts_MemNext(Mock.psa_get_key_attributes_CallInstance);
  if (Mock.psa_get_key_attributes_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_get_key_attributes_FinalReturn;
    memcpy((void*)(&Mock.psa_get_key_attributes_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_get_key_attributes_CallbackBool &&
      Mock.psa_get_key_attributes_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_get_key_attributes_CallbackFunctionPointer(key, attributes, Mock.psa_get_key_attributes_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_get_key_attributes,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_get_key_attributes,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_get_key_attributes_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_get_key_attributes_CallbackFunctionPointer(key, attributes, Mock.psa_get_key_attributes_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_get_key_attributes(CMOCK_psa_get_key_attributes_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_key_attributes_t* attributes);
void CMockExpectParameters_psa_get_key_attributes(CMOCK_psa_get_key_attributes_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_key_attributes_t* attributes)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_attributes = attributes;
}

void psa_get_key_attributes_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_get_key_attributes_CALL_INSTANCE));
  CMOCK_psa_get_key_attributes_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_get_key_attributes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_get_key_attributes_CallInstance = CMock_Guts_MemChain(Mock.psa_get_key_attributes_CallInstance, cmock_guts_index);
  Mock.psa_get_key_attributes_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_get_key_attributes_IgnoreBool = (char)1;
}

void psa_get_key_attributes_CMockStopIgnore(void)
{
  if(Mock.psa_get_key_attributes_IgnoreBool)
    Mock.psa_get_key_attributes_CallInstance = CMock_Guts_MemNext(Mock.psa_get_key_attributes_CallInstance);
  Mock.psa_get_key_attributes_IgnoreBool = (char)0;
}

void psa_get_key_attributes_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_key_attributes_t* attributes, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_get_key_attributes_CALL_INSTANCE));
  CMOCK_psa_get_key_attributes_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_get_key_attributes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_get_key_attributes_CallInstance = CMock_Guts_MemChain(Mock.psa_get_key_attributes_CallInstance, cmock_guts_index);
  Mock.psa_get_key_attributes_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_get_key_attributes(cmock_call_instance, key, attributes);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_get_key_attributes_AddCallback(CMOCK_psa_get_key_attributes_CALLBACK Callback)
{
  Mock.psa_get_key_attributes_IgnoreBool = (char)0;
  Mock.psa_get_key_attributes_CallbackBool = (char)1;
  Mock.psa_get_key_attributes_CallbackFunctionPointer = Callback;
}

void psa_get_key_attributes_Stub(CMOCK_psa_get_key_attributes_CALLBACK Callback)
{
  Mock.psa_get_key_attributes_IgnoreBool = (char)0;
  Mock.psa_get_key_attributes_CallbackBool = (char)0;
  Mock.psa_get_key_attributes_CallbackFunctionPointer = Callback;
}

void psa_reset_key_attributes(psa_key_attributes_t* attributes)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_reset_key_attributes_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_reset_key_attributes);
  cmock_call_instance = (CMOCK_psa_reset_key_attributes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_reset_key_attributes_CallInstance);
  Mock.psa_reset_key_attributes_CallInstance = CMock_Guts_MemNext(Mock.psa_reset_key_attributes_CallInstance);
  if (Mock.psa_reset_key_attributes_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.psa_reset_key_attributes_CallbackBool &&
      Mock.psa_reset_key_attributes_CallbackFunctionPointer != NULL)
  {
    Mock.psa_reset_key_attributes_CallbackFunctionPointer(attributes, Mock.psa_reset_key_attributes_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_reset_key_attributes,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_reset_key_attributes_CallbackFunctionPointer != NULL)
  {
    Mock.psa_reset_key_attributes_CallbackFunctionPointer(attributes, Mock.psa_reset_key_attributes_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_psa_reset_key_attributes(CMOCK_psa_reset_key_attributes_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes);
void CMockExpectParameters_psa_reset_key_attributes(CMOCK_psa_reset_key_attributes_CALL_INSTANCE* cmock_call_instance, psa_key_attributes_t* attributes)
{
  cmock_call_instance->Expected_attributes = attributes;
}

void psa_reset_key_attributes_CMockIgnore(void)
{
  Mock.psa_reset_key_attributes_IgnoreBool = (char)1;
}

void psa_reset_key_attributes_CMockStopIgnore(void)
{
  Mock.psa_reset_key_attributes_IgnoreBool = (char)0;
}

void psa_reset_key_attributes_CMockExpect(UNITY_LINE_TYPE cmock_line, psa_key_attributes_t* attributes)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_reset_key_attributes_CALL_INSTANCE));
  CMOCK_psa_reset_key_attributes_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_reset_key_attributes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_reset_key_attributes_CallInstance = CMock_Guts_MemChain(Mock.psa_reset_key_attributes_CallInstance, cmock_guts_index);
  Mock.psa_reset_key_attributes_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_reset_key_attributes(cmock_call_instance, attributes);
}

void psa_reset_key_attributes_AddCallback(CMOCK_psa_reset_key_attributes_CALLBACK Callback)
{
  Mock.psa_reset_key_attributes_IgnoreBool = (char)0;
  Mock.psa_reset_key_attributes_CallbackBool = (char)1;
  Mock.psa_reset_key_attributes_CallbackFunctionPointer = Callback;
}

void psa_reset_key_attributes_Stub(CMOCK_psa_reset_key_attributes_CALLBACK Callback)
{
  Mock.psa_reset_key_attributes_IgnoreBool = (char)0;
  Mock.psa_reset_key_attributes_CallbackBool = (char)0;
  Mock.psa_reset_key_attributes_CallbackFunctionPointer = Callback;
}

psa_status_t psa_purge_key(psa_key_id_t key)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_purge_key_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_purge_key);
  cmock_call_instance = (CMOCK_psa_purge_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_purge_key_CallInstance);
  Mock.psa_purge_key_CallInstance = CMock_Guts_MemNext(Mock.psa_purge_key_CallInstance);
  if (Mock.psa_purge_key_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_purge_key_FinalReturn;
    memcpy((void*)(&Mock.psa_purge_key_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_purge_key_CallbackBool &&
      Mock.psa_purge_key_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_purge_key_CallbackFunctionPointer(key, Mock.psa_purge_key_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_purge_key,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_purge_key_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_purge_key_CallbackFunctionPointer(key, Mock.psa_purge_key_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_purge_key(CMOCK_psa_purge_key_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key);
void CMockExpectParameters_psa_purge_key(CMOCK_psa_purge_key_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
}

void psa_purge_key_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_purge_key_CALL_INSTANCE));
  CMOCK_psa_purge_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_purge_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_purge_key_CallInstance = CMock_Guts_MemChain(Mock.psa_purge_key_CallInstance, cmock_guts_index);
  Mock.psa_purge_key_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_purge_key_IgnoreBool = (char)1;
}

void psa_purge_key_CMockStopIgnore(void)
{
  if(Mock.psa_purge_key_IgnoreBool)
    Mock.psa_purge_key_CallInstance = CMock_Guts_MemNext(Mock.psa_purge_key_CallInstance);
  Mock.psa_purge_key_IgnoreBool = (char)0;
}

void psa_purge_key_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_purge_key_CALL_INSTANCE));
  CMOCK_psa_purge_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_purge_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_purge_key_CallInstance = CMock_Guts_MemChain(Mock.psa_purge_key_CallInstance, cmock_guts_index);
  Mock.psa_purge_key_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_purge_key(cmock_call_instance, key);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_purge_key_AddCallback(CMOCK_psa_purge_key_CALLBACK Callback)
{
  Mock.psa_purge_key_IgnoreBool = (char)0;
  Mock.psa_purge_key_CallbackBool = (char)1;
  Mock.psa_purge_key_CallbackFunctionPointer = Callback;
}

void psa_purge_key_Stub(CMOCK_psa_purge_key_CALLBACK Callback)
{
  Mock.psa_purge_key_IgnoreBool = (char)0;
  Mock.psa_purge_key_CallbackBool = (char)0;
  Mock.psa_purge_key_CallbackFunctionPointer = Callback;
}

psa_status_t psa_copy_key(psa_key_id_t source_key, const psa_key_attributes_t* attributes, psa_key_id_t* target_key)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_copy_key_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_copy_key);
  cmock_call_instance = (CMOCK_psa_copy_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_copy_key_CallInstance);
  Mock.psa_copy_key_CallInstance = CMock_Guts_MemNext(Mock.psa_copy_key_CallInstance);
  if (Mock.psa_copy_key_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_copy_key_FinalReturn;
    memcpy((void*)(&Mock.psa_copy_key_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_copy_key_CallbackBool &&
      Mock.psa_copy_key_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_copy_key_CallbackFunctionPointer(source_key, attributes, target_key, Mock.psa_copy_key_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_copy_key,CMockString_source_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_source_key), (void*)(&source_key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_copy_key,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(const psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_copy_key,CMockString_target_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_target_key), (void*)(target_key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_copy_key_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_copy_key_CallbackFunctionPointer(source_key, attributes, target_key, Mock.psa_copy_key_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_copy_key(CMOCK_psa_copy_key_CALL_INSTANCE* cmock_call_instance, psa_key_id_t source_key, const psa_key_attributes_t* attributes, psa_key_id_t* target_key);
void CMockExpectParameters_psa_copy_key(CMOCK_psa_copy_key_CALL_INSTANCE* cmock_call_instance, psa_key_id_t source_key, const psa_key_attributes_t* attributes, psa_key_id_t* target_key)
{
  memcpy((void*)(&cmock_call_instance->Expected_source_key), (void*)(&source_key),
         sizeof(psa_key_id_t[sizeof(source_key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_attributes = attributes;
  cmock_call_instance->Expected_target_key = target_key;
}

void psa_copy_key_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_copy_key_CALL_INSTANCE));
  CMOCK_psa_copy_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_copy_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_copy_key_CallInstance = CMock_Guts_MemChain(Mock.psa_copy_key_CallInstance, cmock_guts_index);
  Mock.psa_copy_key_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_copy_key_IgnoreBool = (char)1;
}

void psa_copy_key_CMockStopIgnore(void)
{
  if(Mock.psa_copy_key_IgnoreBool)
    Mock.psa_copy_key_CallInstance = CMock_Guts_MemNext(Mock.psa_copy_key_CallInstance);
  Mock.psa_copy_key_IgnoreBool = (char)0;
}

void psa_copy_key_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t source_key, const psa_key_attributes_t* attributes, psa_key_id_t* target_key, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_copy_key_CALL_INSTANCE));
  CMOCK_psa_copy_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_copy_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_copy_key_CallInstance = CMock_Guts_MemChain(Mock.psa_copy_key_CallInstance, cmock_guts_index);
  Mock.psa_copy_key_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_copy_key(cmock_call_instance, source_key, attributes, target_key);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_copy_key_AddCallback(CMOCK_psa_copy_key_CALLBACK Callback)
{
  Mock.psa_copy_key_IgnoreBool = (char)0;
  Mock.psa_copy_key_CallbackBool = (char)1;
  Mock.psa_copy_key_CallbackFunctionPointer = Callback;
}

void psa_copy_key_Stub(CMOCK_psa_copy_key_CALLBACK Callback)
{
  Mock.psa_copy_key_IgnoreBool = (char)0;
  Mock.psa_copy_key_CallbackBool = (char)0;
  Mock.psa_copy_key_CallbackFunctionPointer = Callback;
}

psa_status_t psa_destroy_key(psa_key_id_t key)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_destroy_key_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_destroy_key);
  cmock_call_instance = (CMOCK_psa_destroy_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_destroy_key_CallInstance);
  Mock.psa_destroy_key_CallInstance = CMock_Guts_MemNext(Mock.psa_destroy_key_CallInstance);
  if (Mock.psa_destroy_key_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_destroy_key_FinalReturn;
    memcpy((void*)(&Mock.psa_destroy_key_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_destroy_key_CallbackBool &&
      Mock.psa_destroy_key_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_destroy_key_CallbackFunctionPointer(key, Mock.psa_destroy_key_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_destroy_key,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_destroy_key_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_destroy_key_CallbackFunctionPointer(key, Mock.psa_destroy_key_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_destroy_key(CMOCK_psa_destroy_key_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key);
void CMockExpectParameters_psa_destroy_key(CMOCK_psa_destroy_key_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
}

void psa_destroy_key_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_destroy_key_CALL_INSTANCE));
  CMOCK_psa_destroy_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_destroy_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_destroy_key_CallInstance = CMock_Guts_MemChain(Mock.psa_destroy_key_CallInstance, cmock_guts_index);
  Mock.psa_destroy_key_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_destroy_key_IgnoreBool = (char)1;
}

void psa_destroy_key_CMockStopIgnore(void)
{
  if(Mock.psa_destroy_key_IgnoreBool)
    Mock.psa_destroy_key_CallInstance = CMock_Guts_MemNext(Mock.psa_destroy_key_CallInstance);
  Mock.psa_destroy_key_IgnoreBool = (char)0;
}

void psa_destroy_key_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_destroy_key_CALL_INSTANCE));
  CMOCK_psa_destroy_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_destroy_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_destroy_key_CallInstance = CMock_Guts_MemChain(Mock.psa_destroy_key_CallInstance, cmock_guts_index);
  Mock.psa_destroy_key_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_destroy_key(cmock_call_instance, key);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_destroy_key_AddCallback(CMOCK_psa_destroy_key_CALLBACK Callback)
{
  Mock.psa_destroy_key_IgnoreBool = (char)0;
  Mock.psa_destroy_key_CallbackBool = (char)1;
  Mock.psa_destroy_key_CallbackFunctionPointer = Callback;
}

void psa_destroy_key_Stub(CMOCK_psa_destroy_key_CALLBACK Callback)
{
  Mock.psa_destroy_key_IgnoreBool = (char)0;
  Mock.psa_destroy_key_CallbackBool = (char)0;
  Mock.psa_destroy_key_CallbackFunctionPointer = Callback;
}

psa_status_t psa_import_key(const psa_key_attributes_t* attributes, const uint8_t* data, size_t data_length, psa_key_id_t* key)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_import_key_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_import_key);
  cmock_call_instance = (CMOCK_psa_import_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_import_key_CallInstance);
  Mock.psa_import_key_CallInstance = CMock_Guts_MemNext(Mock.psa_import_key_CallInstance);
  if (Mock.psa_import_key_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_import_key_FinalReturn;
    memcpy((void*)(&Mock.psa_import_key_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_import_key_CallbackBool &&
      Mock.psa_import_key_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_import_key_CallbackFunctionPointer(attributes, data, data_length, key, Mock.psa_import_key_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_import_key,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(const psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_import_key,CMockString_data);
    if (cmock_call_instance->Expected_data == NULL)
      { UNITY_TEST_ASSERT_NULL(data, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_data, data, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_import_key,CMockString_data_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_data_length), (void*)(&data_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_import_key,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_key), (void*)(key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_import_key_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_import_key_CallbackFunctionPointer(attributes, data, data_length, key, Mock.psa_import_key_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_import_key(CMOCK_psa_import_key_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes, const uint8_t* data, size_t data_length, psa_key_id_t* key);
void CMockExpectParameters_psa_import_key(CMOCK_psa_import_key_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes, const uint8_t* data, size_t data_length, psa_key_id_t* key)
{
  cmock_call_instance->Expected_attributes = attributes;
  cmock_call_instance->Expected_data = data;
  memcpy((void*)(&cmock_call_instance->Expected_data_length), (void*)(&data_length),
         sizeof(size_t[sizeof(data_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_key = key;
}

void psa_import_key_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_import_key_CALL_INSTANCE));
  CMOCK_psa_import_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_import_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_import_key_CallInstance = CMock_Guts_MemChain(Mock.psa_import_key_CallInstance, cmock_guts_index);
  Mock.psa_import_key_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_import_key_IgnoreBool = (char)1;
}

void psa_import_key_CMockStopIgnore(void)
{
  if(Mock.psa_import_key_IgnoreBool)
    Mock.psa_import_key_CallInstance = CMock_Guts_MemNext(Mock.psa_import_key_CallInstance);
  Mock.psa_import_key_IgnoreBool = (char)0;
}

void psa_import_key_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const psa_key_attributes_t* attributes, const uint8_t* data, size_t data_length, psa_key_id_t* key, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_import_key_CALL_INSTANCE));
  CMOCK_psa_import_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_import_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_import_key_CallInstance = CMock_Guts_MemChain(Mock.psa_import_key_CallInstance, cmock_guts_index);
  Mock.psa_import_key_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_import_key(cmock_call_instance, attributes, data, data_length, key);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_import_key_AddCallback(CMOCK_psa_import_key_CALLBACK Callback)
{
  Mock.psa_import_key_IgnoreBool = (char)0;
  Mock.psa_import_key_CallbackBool = (char)1;
  Mock.psa_import_key_CallbackFunctionPointer = Callback;
}

void psa_import_key_Stub(CMOCK_psa_import_key_CALLBACK Callback)
{
  Mock.psa_import_key_IgnoreBool = (char)0;
  Mock.psa_import_key_CallbackBool = (char)0;
  Mock.psa_import_key_CallbackFunctionPointer = Callback;
}

psa_status_t psa_export_key(psa_key_id_t key, uint8_t* data, size_t data_size, size_t* data_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_export_key_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_export_key);
  cmock_call_instance = (CMOCK_psa_export_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_export_key_CallInstance);
  Mock.psa_export_key_CallInstance = CMock_Guts_MemNext(Mock.psa_export_key_CallInstance);
  if (Mock.psa_export_key_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_export_key_FinalReturn;
    memcpy((void*)(&Mock.psa_export_key_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_export_key_CallbackBool &&
      Mock.psa_export_key_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_export_key_CallbackFunctionPointer(key, data, data_size, data_length, Mock.psa_export_key_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_export_key,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_export_key,CMockString_data);
    if (cmock_call_instance->Expected_data == NULL)
      { UNITY_TEST_ASSERT_NULL(data, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_data, data, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_export_key,CMockString_data_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_data_size), (void*)(&data_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_export_key,CMockString_data_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_data_length), (void*)(data_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_export_key_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_export_key_CallbackFunctionPointer(key, data, data_size, data_length, Mock.psa_export_key_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_export_key(CMOCK_psa_export_key_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, uint8_t* data, size_t data_size, size_t* data_length);
void CMockExpectParameters_psa_export_key(CMOCK_psa_export_key_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, uint8_t* data, size_t data_size, size_t* data_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_data = data;
  memcpy((void*)(&cmock_call_instance->Expected_data_size), (void*)(&data_size),
         sizeof(size_t[sizeof(data_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_data_length = data_length;
}

void psa_export_key_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_export_key_CALL_INSTANCE));
  CMOCK_psa_export_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_export_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_export_key_CallInstance = CMock_Guts_MemChain(Mock.psa_export_key_CallInstance, cmock_guts_index);
  Mock.psa_export_key_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_export_key_IgnoreBool = (char)1;
}

void psa_export_key_CMockStopIgnore(void)
{
  if(Mock.psa_export_key_IgnoreBool)
    Mock.psa_export_key_CallInstance = CMock_Guts_MemNext(Mock.psa_export_key_CallInstance);
  Mock.psa_export_key_IgnoreBool = (char)0;
}

void psa_export_key_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, uint8_t* data, size_t data_size, size_t* data_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_export_key_CALL_INSTANCE));
  CMOCK_psa_export_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_export_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_export_key_CallInstance = CMock_Guts_MemChain(Mock.psa_export_key_CallInstance, cmock_guts_index);
  Mock.psa_export_key_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_export_key(cmock_call_instance, key, data, data_size, data_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_export_key_AddCallback(CMOCK_psa_export_key_CALLBACK Callback)
{
  Mock.psa_export_key_IgnoreBool = (char)0;
  Mock.psa_export_key_CallbackBool = (char)1;
  Mock.psa_export_key_CallbackFunctionPointer = Callback;
}

void psa_export_key_Stub(CMOCK_psa_export_key_CALLBACK Callback)
{
  Mock.psa_export_key_IgnoreBool = (char)0;
  Mock.psa_export_key_CallbackBool = (char)0;
  Mock.psa_export_key_CallbackFunctionPointer = Callback;
}

psa_status_t psa_export_public_key(psa_key_id_t key, uint8_t* data, size_t data_size, size_t* data_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_export_public_key_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_export_public_key);
  cmock_call_instance = (CMOCK_psa_export_public_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_export_public_key_CallInstance);
  Mock.psa_export_public_key_CallInstance = CMock_Guts_MemNext(Mock.psa_export_public_key_CallInstance);
  if (Mock.psa_export_public_key_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_export_public_key_FinalReturn;
    memcpy((void*)(&Mock.psa_export_public_key_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_export_public_key_CallbackBool &&
      Mock.psa_export_public_key_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_export_public_key_CallbackFunctionPointer(key, data, data_size, data_length, Mock.psa_export_public_key_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_export_public_key,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_export_public_key,CMockString_data);
    if (cmock_call_instance->Expected_data == NULL)
      { UNITY_TEST_ASSERT_NULL(data, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_data, data, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_export_public_key,CMockString_data_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_data_size), (void*)(&data_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_export_public_key,CMockString_data_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_data_length), (void*)(data_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_export_public_key_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_export_public_key_CallbackFunctionPointer(key, data, data_size, data_length, Mock.psa_export_public_key_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_export_public_key(CMOCK_psa_export_public_key_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, uint8_t* data, size_t data_size, size_t* data_length);
void CMockExpectParameters_psa_export_public_key(CMOCK_psa_export_public_key_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, uint8_t* data, size_t data_size, size_t* data_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_data = data;
  memcpy((void*)(&cmock_call_instance->Expected_data_size), (void*)(&data_size),
         sizeof(size_t[sizeof(data_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_data_length = data_length;
}

void psa_export_public_key_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_export_public_key_CALL_INSTANCE));
  CMOCK_psa_export_public_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_export_public_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_export_public_key_CallInstance = CMock_Guts_MemChain(Mock.psa_export_public_key_CallInstance, cmock_guts_index);
  Mock.psa_export_public_key_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_export_public_key_IgnoreBool = (char)1;
}

void psa_export_public_key_CMockStopIgnore(void)
{
  if(Mock.psa_export_public_key_IgnoreBool)
    Mock.psa_export_public_key_CallInstance = CMock_Guts_MemNext(Mock.psa_export_public_key_CallInstance);
  Mock.psa_export_public_key_IgnoreBool = (char)0;
}

void psa_export_public_key_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, uint8_t* data, size_t data_size, size_t* data_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_export_public_key_CALL_INSTANCE));
  CMOCK_psa_export_public_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_export_public_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_export_public_key_CallInstance = CMock_Guts_MemChain(Mock.psa_export_public_key_CallInstance, cmock_guts_index);
  Mock.psa_export_public_key_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_export_public_key(cmock_call_instance, key, data, data_size, data_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_export_public_key_AddCallback(CMOCK_psa_export_public_key_CALLBACK Callback)
{
  Mock.psa_export_public_key_IgnoreBool = (char)0;
  Mock.psa_export_public_key_CallbackBool = (char)1;
  Mock.psa_export_public_key_CallbackFunctionPointer = Callback;
}

void psa_export_public_key_Stub(CMOCK_psa_export_public_key_CALLBACK Callback)
{
  Mock.psa_export_public_key_IgnoreBool = (char)0;
  Mock.psa_export_public_key_CallbackBool = (char)0;
  Mock.psa_export_public_key_CallbackFunctionPointer = Callback;
}

psa_status_t psa_hash_compute(psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* hash, size_t hash_size, size_t* hash_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_hash_compute_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_hash_compute);
  cmock_call_instance = (CMOCK_psa_hash_compute_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_hash_compute_CallInstance);
  Mock.psa_hash_compute_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_compute_CallInstance);
  if (Mock.psa_hash_compute_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_hash_compute_FinalReturn;
    memcpy((void*)(&Mock.psa_hash_compute_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_hash_compute_CallbackBool &&
      Mock.psa_hash_compute_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_hash_compute_CallbackFunctionPointer(alg, input, input_length, hash, hash_size, hash_length, Mock.psa_hash_compute_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_compute,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_compute,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_compute,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_compute,CMockString_hash);
    if (cmock_call_instance->Expected_hash == NULL)
      { UNITY_TEST_ASSERT_NULL(hash, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_hash, hash, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_compute,CMockString_hash_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_hash_size), (void*)(&hash_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_compute,CMockString_hash_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hash_length), (void*)(hash_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_hash_compute_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_hash_compute_CallbackFunctionPointer(alg, input, input_length, hash, hash_size, hash_length, Mock.psa_hash_compute_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_hash_compute(CMOCK_psa_hash_compute_CALL_INSTANCE* cmock_call_instance, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* hash, size_t hash_size, size_t* hash_length);
void CMockExpectParameters_psa_hash_compute(CMOCK_psa_hash_compute_CALL_INSTANCE* cmock_call_instance, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* hash, size_t hash_size, size_t* hash_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_hash = hash;
  memcpy((void*)(&cmock_call_instance->Expected_hash_size), (void*)(&hash_size),
         sizeof(size_t[sizeof(hash_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_hash_length = hash_length;
}

void psa_hash_compute_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_compute_CALL_INSTANCE));
  CMOCK_psa_hash_compute_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_compute_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_compute_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_compute_CallInstance, cmock_guts_index);
  Mock.psa_hash_compute_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_hash_compute_IgnoreBool = (char)1;
}

void psa_hash_compute_CMockStopIgnore(void)
{
  if(Mock.psa_hash_compute_IgnoreBool)
    Mock.psa_hash_compute_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_compute_CallInstance);
  Mock.psa_hash_compute_IgnoreBool = (char)0;
}

void psa_hash_compute_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* hash, size_t hash_size, size_t* hash_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_compute_CALL_INSTANCE));
  CMOCK_psa_hash_compute_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_compute_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_compute_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_compute_CallInstance, cmock_guts_index);
  Mock.psa_hash_compute_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_hash_compute(cmock_call_instance, alg, input, input_length, hash, hash_size, hash_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_hash_compute_AddCallback(CMOCK_psa_hash_compute_CALLBACK Callback)
{
  Mock.psa_hash_compute_IgnoreBool = (char)0;
  Mock.psa_hash_compute_CallbackBool = (char)1;
  Mock.psa_hash_compute_CallbackFunctionPointer = Callback;
}

void psa_hash_compute_Stub(CMOCK_psa_hash_compute_CALLBACK Callback)
{
  Mock.psa_hash_compute_IgnoreBool = (char)0;
  Mock.psa_hash_compute_CallbackBool = (char)0;
  Mock.psa_hash_compute_CallbackFunctionPointer = Callback;
}

psa_status_t psa_hash_compare(psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* hash, size_t hash_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_hash_compare_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_hash_compare);
  cmock_call_instance = (CMOCK_psa_hash_compare_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_hash_compare_CallInstance);
  Mock.psa_hash_compare_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_compare_CallInstance);
  if (Mock.psa_hash_compare_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_hash_compare_FinalReturn;
    memcpy((void*)(&Mock.psa_hash_compare_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_hash_compare_CallbackBool &&
      Mock.psa_hash_compare_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_hash_compare_CallbackFunctionPointer(alg, input, input_length, hash, hash_length, Mock.psa_hash_compare_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_compare,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_compare,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_compare,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_compare,CMockString_hash);
    if (cmock_call_instance->Expected_hash == NULL)
      { UNITY_TEST_ASSERT_NULL(hash, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_hash, hash, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_compare,CMockString_hash_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_hash_length), (void*)(&hash_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_hash_compare_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_hash_compare_CallbackFunctionPointer(alg, input, input_length, hash, hash_length, Mock.psa_hash_compare_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_hash_compare(CMOCK_psa_hash_compare_CALL_INSTANCE* cmock_call_instance, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* hash, size_t hash_length);
void CMockExpectParameters_psa_hash_compare(CMOCK_psa_hash_compare_CALL_INSTANCE* cmock_call_instance, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* hash, size_t hash_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_hash = hash;
  memcpy((void*)(&cmock_call_instance->Expected_hash_length), (void*)(&hash_length),
         sizeof(size_t[sizeof(hash_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_hash_compare_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_compare_CALL_INSTANCE));
  CMOCK_psa_hash_compare_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_compare_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_compare_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_compare_CallInstance, cmock_guts_index);
  Mock.psa_hash_compare_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_hash_compare_IgnoreBool = (char)1;
}

void psa_hash_compare_CMockStopIgnore(void)
{
  if(Mock.psa_hash_compare_IgnoreBool)
    Mock.psa_hash_compare_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_compare_CallInstance);
  Mock.psa_hash_compare_IgnoreBool = (char)0;
}

void psa_hash_compare_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* hash, size_t hash_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_compare_CALL_INSTANCE));
  CMOCK_psa_hash_compare_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_compare_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_compare_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_compare_CallInstance, cmock_guts_index);
  Mock.psa_hash_compare_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_hash_compare(cmock_call_instance, alg, input, input_length, hash, hash_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_hash_compare_AddCallback(CMOCK_psa_hash_compare_CALLBACK Callback)
{
  Mock.psa_hash_compare_IgnoreBool = (char)0;
  Mock.psa_hash_compare_CallbackBool = (char)1;
  Mock.psa_hash_compare_CallbackFunctionPointer = Callback;
}

void psa_hash_compare_Stub(CMOCK_psa_hash_compare_CALLBACK Callback)
{
  Mock.psa_hash_compare_IgnoreBool = (char)0;
  Mock.psa_hash_compare_CallbackBool = (char)0;
  Mock.psa_hash_compare_CallbackFunctionPointer = Callback;
}

psa_hash_operation_t psa_hash_operation_init(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_hash_operation_init_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_hash_operation_init);
  cmock_call_instance = (CMOCK_psa_hash_operation_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_hash_operation_init_CallInstance);
  Mock.psa_hash_operation_init_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_operation_init_CallInstance);
  if (Mock.psa_hash_operation_init_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_hash_operation_init_FinalReturn;
    memcpy((void*)(&Mock.psa_hash_operation_init_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_hash_operation_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_hash_operation_t) ? 1 : -1])); /* add psa_hash_operation_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_hash_operation_init_CallbackBool &&
      Mock.psa_hash_operation_init_CallbackFunctionPointer != NULL)
  {
    psa_hash_operation_t cmock_cb_ret = Mock.psa_hash_operation_init_CallbackFunctionPointer(Mock.psa_hash_operation_init_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.psa_hash_operation_init_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_hash_operation_init_CallbackFunctionPointer(Mock.psa_hash_operation_init_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void psa_hash_operation_init_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_hash_operation_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_operation_init_CALL_INSTANCE));
  CMOCK_psa_hash_operation_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_operation_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_operation_init_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_operation_init_CallInstance, cmock_guts_index);
  Mock.psa_hash_operation_init_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_hash_operation_init_IgnoreBool = (char)1;
}

void psa_hash_operation_init_CMockStopIgnore(void)
{
  if(Mock.psa_hash_operation_init_IgnoreBool)
    Mock.psa_hash_operation_init_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_operation_init_CallInstance);
  Mock.psa_hash_operation_init_IgnoreBool = (char)0;
}

void psa_hash_operation_init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_hash_operation_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_operation_init_CALL_INSTANCE));
  CMOCK_psa_hash_operation_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_operation_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_operation_init_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_operation_init_CallInstance, cmock_guts_index);
  Mock.psa_hash_operation_init_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_hash_operation_t[sizeof(cmock_to_return) == sizeof(psa_hash_operation_t) ? 1 : -1])); /* add psa_hash_operation_t to :treat_as_array if this causes an error */
}

void psa_hash_operation_init_AddCallback(CMOCK_psa_hash_operation_init_CALLBACK Callback)
{
  Mock.psa_hash_operation_init_IgnoreBool = (char)0;
  Mock.psa_hash_operation_init_CallbackBool = (char)1;
  Mock.psa_hash_operation_init_CallbackFunctionPointer = Callback;
}

void psa_hash_operation_init_Stub(CMOCK_psa_hash_operation_init_CALLBACK Callback)
{
  Mock.psa_hash_operation_init_IgnoreBool = (char)0;
  Mock.psa_hash_operation_init_CallbackBool = (char)0;
  Mock.psa_hash_operation_init_CallbackFunctionPointer = Callback;
}

psa_status_t psa_hash_setup(psa_hash_operation_t* operation, psa_algorithm_t alg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_hash_setup_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_hash_setup);
  cmock_call_instance = (CMOCK_psa_hash_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_hash_setup_CallInstance);
  Mock.psa_hash_setup_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_setup_CallInstance);
  if (Mock.psa_hash_setup_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_hash_setup_FinalReturn;
    memcpy((void*)(&Mock.psa_hash_setup_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_hash_setup_CallbackBool &&
      Mock.psa_hash_setup_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_hash_setup_CallbackFunctionPointer(operation, alg, Mock.psa_hash_setup_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_setup,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_hash_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_setup,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_hash_setup_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_hash_setup_CallbackFunctionPointer(operation, alg, Mock.psa_hash_setup_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_hash_setup(CMOCK_psa_hash_setup_CALL_INSTANCE* cmock_call_instance, psa_hash_operation_t* operation, psa_algorithm_t alg);
void CMockExpectParameters_psa_hash_setup(CMOCK_psa_hash_setup_CALL_INSTANCE* cmock_call_instance, psa_hash_operation_t* operation, psa_algorithm_t alg)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
}

void psa_hash_setup_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_setup_CALL_INSTANCE));
  CMOCK_psa_hash_setup_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_setup_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_setup_CallInstance, cmock_guts_index);
  Mock.psa_hash_setup_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_hash_setup_IgnoreBool = (char)1;
}

void psa_hash_setup_CMockStopIgnore(void)
{
  if(Mock.psa_hash_setup_IgnoreBool)
    Mock.psa_hash_setup_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_setup_CallInstance);
  Mock.psa_hash_setup_IgnoreBool = (char)0;
}

void psa_hash_setup_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_hash_operation_t* operation, psa_algorithm_t alg, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_setup_CALL_INSTANCE));
  CMOCK_psa_hash_setup_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_setup_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_setup_CallInstance, cmock_guts_index);
  Mock.psa_hash_setup_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_hash_setup(cmock_call_instance, operation, alg);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_hash_setup_AddCallback(CMOCK_psa_hash_setup_CALLBACK Callback)
{
  Mock.psa_hash_setup_IgnoreBool = (char)0;
  Mock.psa_hash_setup_CallbackBool = (char)1;
  Mock.psa_hash_setup_CallbackFunctionPointer = Callback;
}

void psa_hash_setup_Stub(CMOCK_psa_hash_setup_CALLBACK Callback)
{
  Mock.psa_hash_setup_IgnoreBool = (char)0;
  Mock.psa_hash_setup_CallbackBool = (char)0;
  Mock.psa_hash_setup_CallbackFunctionPointer = Callback;
}

psa_status_t psa_hash_update(psa_hash_operation_t* operation, const uint8_t* input, size_t input_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_hash_update_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_hash_update);
  cmock_call_instance = (CMOCK_psa_hash_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_hash_update_CallInstance);
  Mock.psa_hash_update_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_update_CallInstance);
  if (Mock.psa_hash_update_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_hash_update_FinalReturn;
    memcpy((void*)(&Mock.psa_hash_update_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_hash_update_CallbackBool &&
      Mock.psa_hash_update_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_hash_update_CallbackFunctionPointer(operation, input, input_length, Mock.psa_hash_update_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_update,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_hash_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_update,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_update,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_hash_update_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_hash_update_CallbackFunctionPointer(operation, input, input_length, Mock.psa_hash_update_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_hash_update(CMOCK_psa_hash_update_CALL_INSTANCE* cmock_call_instance, psa_hash_operation_t* operation, const uint8_t* input, size_t input_length);
void CMockExpectParameters_psa_hash_update(CMOCK_psa_hash_update_CALL_INSTANCE* cmock_call_instance, psa_hash_operation_t* operation, const uint8_t* input, size_t input_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_hash_update_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_update_CALL_INSTANCE));
  CMOCK_psa_hash_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_update_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_update_CallInstance, cmock_guts_index);
  Mock.psa_hash_update_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_hash_update_IgnoreBool = (char)1;
}

void psa_hash_update_CMockStopIgnore(void)
{
  if(Mock.psa_hash_update_IgnoreBool)
    Mock.psa_hash_update_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_update_CallInstance);
  Mock.psa_hash_update_IgnoreBool = (char)0;
}

void psa_hash_update_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_hash_operation_t* operation, const uint8_t* input, size_t input_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_update_CALL_INSTANCE));
  CMOCK_psa_hash_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_update_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_update_CallInstance, cmock_guts_index);
  Mock.psa_hash_update_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_hash_update(cmock_call_instance, operation, input, input_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_hash_update_AddCallback(CMOCK_psa_hash_update_CALLBACK Callback)
{
  Mock.psa_hash_update_IgnoreBool = (char)0;
  Mock.psa_hash_update_CallbackBool = (char)1;
  Mock.psa_hash_update_CallbackFunctionPointer = Callback;
}

void psa_hash_update_Stub(CMOCK_psa_hash_update_CALLBACK Callback)
{
  Mock.psa_hash_update_IgnoreBool = (char)0;
  Mock.psa_hash_update_CallbackBool = (char)0;
  Mock.psa_hash_update_CallbackFunctionPointer = Callback;
}

psa_status_t psa_hash_finish(psa_hash_operation_t* operation, uint8_t* hash, size_t hash_size, size_t* hash_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_hash_finish_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_hash_finish);
  cmock_call_instance = (CMOCK_psa_hash_finish_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_hash_finish_CallInstance);
  Mock.psa_hash_finish_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_finish_CallInstance);
  if (Mock.psa_hash_finish_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_hash_finish_FinalReturn;
    memcpy((void*)(&Mock.psa_hash_finish_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_hash_finish_CallbackBool &&
      Mock.psa_hash_finish_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_hash_finish_CallbackFunctionPointer(operation, hash, hash_size, hash_length, Mock.psa_hash_finish_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_finish,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_hash_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_finish,CMockString_hash);
    if (cmock_call_instance->Expected_hash == NULL)
      { UNITY_TEST_ASSERT_NULL(hash, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_hash, hash, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_finish,CMockString_hash_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_hash_size), (void*)(&hash_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_finish,CMockString_hash_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_hash_length), (void*)(hash_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_hash_finish_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_hash_finish_CallbackFunctionPointer(operation, hash, hash_size, hash_length, Mock.psa_hash_finish_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_hash_finish(CMOCK_psa_hash_finish_CALL_INSTANCE* cmock_call_instance, psa_hash_operation_t* operation, uint8_t* hash, size_t hash_size, size_t* hash_length);
void CMockExpectParameters_psa_hash_finish(CMOCK_psa_hash_finish_CALL_INSTANCE* cmock_call_instance, psa_hash_operation_t* operation, uint8_t* hash, size_t hash_size, size_t* hash_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_hash = hash;
  memcpy((void*)(&cmock_call_instance->Expected_hash_size), (void*)(&hash_size),
         sizeof(size_t[sizeof(hash_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_hash_length = hash_length;
}

void psa_hash_finish_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_finish_CALL_INSTANCE));
  CMOCK_psa_hash_finish_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_finish_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_finish_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_finish_CallInstance, cmock_guts_index);
  Mock.psa_hash_finish_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_hash_finish_IgnoreBool = (char)1;
}

void psa_hash_finish_CMockStopIgnore(void)
{
  if(Mock.psa_hash_finish_IgnoreBool)
    Mock.psa_hash_finish_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_finish_CallInstance);
  Mock.psa_hash_finish_IgnoreBool = (char)0;
}

void psa_hash_finish_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_hash_operation_t* operation, uint8_t* hash, size_t hash_size, size_t* hash_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_finish_CALL_INSTANCE));
  CMOCK_psa_hash_finish_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_finish_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_finish_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_finish_CallInstance, cmock_guts_index);
  Mock.psa_hash_finish_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_hash_finish(cmock_call_instance, operation, hash, hash_size, hash_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_hash_finish_AddCallback(CMOCK_psa_hash_finish_CALLBACK Callback)
{
  Mock.psa_hash_finish_IgnoreBool = (char)0;
  Mock.psa_hash_finish_CallbackBool = (char)1;
  Mock.psa_hash_finish_CallbackFunctionPointer = Callback;
}

void psa_hash_finish_Stub(CMOCK_psa_hash_finish_CALLBACK Callback)
{
  Mock.psa_hash_finish_IgnoreBool = (char)0;
  Mock.psa_hash_finish_CallbackBool = (char)0;
  Mock.psa_hash_finish_CallbackFunctionPointer = Callback;
}

psa_status_t psa_hash_verify(psa_hash_operation_t* operation, const uint8_t* hash, size_t hash_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_hash_verify_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_hash_verify);
  cmock_call_instance = (CMOCK_psa_hash_verify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_hash_verify_CallInstance);
  Mock.psa_hash_verify_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_verify_CallInstance);
  if (Mock.psa_hash_verify_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_hash_verify_FinalReturn;
    memcpy((void*)(&Mock.psa_hash_verify_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_hash_verify_CallbackBool &&
      Mock.psa_hash_verify_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_hash_verify_CallbackFunctionPointer(operation, hash, hash_length, Mock.psa_hash_verify_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_verify,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_hash_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_verify,CMockString_hash);
    if (cmock_call_instance->Expected_hash == NULL)
      { UNITY_TEST_ASSERT_NULL(hash, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_hash, hash, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_verify,CMockString_hash_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_hash_length), (void*)(&hash_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_hash_verify_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_hash_verify_CallbackFunctionPointer(operation, hash, hash_length, Mock.psa_hash_verify_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_hash_verify(CMOCK_psa_hash_verify_CALL_INSTANCE* cmock_call_instance, psa_hash_operation_t* operation, const uint8_t* hash, size_t hash_length);
void CMockExpectParameters_psa_hash_verify(CMOCK_psa_hash_verify_CALL_INSTANCE* cmock_call_instance, psa_hash_operation_t* operation, const uint8_t* hash, size_t hash_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_hash = hash;
  memcpy((void*)(&cmock_call_instance->Expected_hash_length), (void*)(&hash_length),
         sizeof(size_t[sizeof(hash_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_hash_verify_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_verify_CALL_INSTANCE));
  CMOCK_psa_hash_verify_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_verify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_verify_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_verify_CallInstance, cmock_guts_index);
  Mock.psa_hash_verify_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_hash_verify_IgnoreBool = (char)1;
}

void psa_hash_verify_CMockStopIgnore(void)
{
  if(Mock.psa_hash_verify_IgnoreBool)
    Mock.psa_hash_verify_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_verify_CallInstance);
  Mock.psa_hash_verify_IgnoreBool = (char)0;
}

void psa_hash_verify_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_hash_operation_t* operation, const uint8_t* hash, size_t hash_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_verify_CALL_INSTANCE));
  CMOCK_psa_hash_verify_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_verify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_verify_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_verify_CallInstance, cmock_guts_index);
  Mock.psa_hash_verify_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_hash_verify(cmock_call_instance, operation, hash, hash_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_hash_verify_AddCallback(CMOCK_psa_hash_verify_CALLBACK Callback)
{
  Mock.psa_hash_verify_IgnoreBool = (char)0;
  Mock.psa_hash_verify_CallbackBool = (char)1;
  Mock.psa_hash_verify_CallbackFunctionPointer = Callback;
}

void psa_hash_verify_Stub(CMOCK_psa_hash_verify_CALLBACK Callback)
{
  Mock.psa_hash_verify_IgnoreBool = (char)0;
  Mock.psa_hash_verify_CallbackBool = (char)0;
  Mock.psa_hash_verify_CallbackFunctionPointer = Callback;
}

psa_status_t psa_hash_abort(psa_hash_operation_t* operation)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_hash_abort_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_hash_abort);
  cmock_call_instance = (CMOCK_psa_hash_abort_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_hash_abort_CallInstance);
  Mock.psa_hash_abort_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_abort_CallInstance);
  if (Mock.psa_hash_abort_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_hash_abort_FinalReturn;
    memcpy((void*)(&Mock.psa_hash_abort_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_hash_abort_CallbackBool &&
      Mock.psa_hash_abort_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_hash_abort_CallbackFunctionPointer(operation, Mock.psa_hash_abort_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_abort,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_hash_operation_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_hash_abort_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_hash_abort_CallbackFunctionPointer(operation, Mock.psa_hash_abort_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_hash_abort(CMOCK_psa_hash_abort_CALL_INSTANCE* cmock_call_instance, psa_hash_operation_t* operation);
void CMockExpectParameters_psa_hash_abort(CMOCK_psa_hash_abort_CALL_INSTANCE* cmock_call_instance, psa_hash_operation_t* operation)
{
  cmock_call_instance->Expected_operation = operation;
}

void psa_hash_abort_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_abort_CALL_INSTANCE));
  CMOCK_psa_hash_abort_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_abort_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_abort_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_abort_CallInstance, cmock_guts_index);
  Mock.psa_hash_abort_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_hash_abort_IgnoreBool = (char)1;
}

void psa_hash_abort_CMockStopIgnore(void)
{
  if(Mock.psa_hash_abort_IgnoreBool)
    Mock.psa_hash_abort_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_abort_CallInstance);
  Mock.psa_hash_abort_IgnoreBool = (char)0;
}

void psa_hash_abort_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_hash_operation_t* operation, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_abort_CALL_INSTANCE));
  CMOCK_psa_hash_abort_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_abort_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_abort_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_abort_CallInstance, cmock_guts_index);
  Mock.psa_hash_abort_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_hash_abort(cmock_call_instance, operation);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_hash_abort_AddCallback(CMOCK_psa_hash_abort_CALLBACK Callback)
{
  Mock.psa_hash_abort_IgnoreBool = (char)0;
  Mock.psa_hash_abort_CallbackBool = (char)1;
  Mock.psa_hash_abort_CallbackFunctionPointer = Callback;
}

void psa_hash_abort_Stub(CMOCK_psa_hash_abort_CALLBACK Callback)
{
  Mock.psa_hash_abort_IgnoreBool = (char)0;
  Mock.psa_hash_abort_CallbackBool = (char)0;
  Mock.psa_hash_abort_CallbackFunctionPointer = Callback;
}

psa_status_t psa_hash_clone(const psa_hash_operation_t* source_operation, psa_hash_operation_t* target_operation)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_hash_clone_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_hash_clone);
  cmock_call_instance = (CMOCK_psa_hash_clone_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_hash_clone_CallInstance);
  Mock.psa_hash_clone_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_clone_CallInstance);
  if (Mock.psa_hash_clone_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_hash_clone_FinalReturn;
    memcpy((void*)(&Mock.psa_hash_clone_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_hash_clone_CallbackBool &&
      Mock.psa_hash_clone_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_hash_clone_CallbackFunctionPointer(source_operation, target_operation, Mock.psa_hash_clone_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_clone,CMockString_source_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_source_operation), (void*)(source_operation), sizeof(const psa_hash_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_hash_clone,CMockString_target_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_target_operation), (void*)(target_operation), sizeof(psa_hash_operation_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_hash_clone_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_hash_clone_CallbackFunctionPointer(source_operation, target_operation, Mock.psa_hash_clone_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_hash_clone(CMOCK_psa_hash_clone_CALL_INSTANCE* cmock_call_instance, const psa_hash_operation_t* source_operation, psa_hash_operation_t* target_operation);
void CMockExpectParameters_psa_hash_clone(CMOCK_psa_hash_clone_CALL_INSTANCE* cmock_call_instance, const psa_hash_operation_t* source_operation, psa_hash_operation_t* target_operation)
{
  cmock_call_instance->Expected_source_operation = source_operation;
  cmock_call_instance->Expected_target_operation = target_operation;
}

void psa_hash_clone_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_clone_CALL_INSTANCE));
  CMOCK_psa_hash_clone_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_clone_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_clone_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_clone_CallInstance, cmock_guts_index);
  Mock.psa_hash_clone_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_hash_clone_IgnoreBool = (char)1;
}

void psa_hash_clone_CMockStopIgnore(void)
{
  if(Mock.psa_hash_clone_IgnoreBool)
    Mock.psa_hash_clone_CallInstance = CMock_Guts_MemNext(Mock.psa_hash_clone_CallInstance);
  Mock.psa_hash_clone_IgnoreBool = (char)0;
}

void psa_hash_clone_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const psa_hash_operation_t* source_operation, psa_hash_operation_t* target_operation, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_hash_clone_CALL_INSTANCE));
  CMOCK_psa_hash_clone_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_hash_clone_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_hash_clone_CallInstance = CMock_Guts_MemChain(Mock.psa_hash_clone_CallInstance, cmock_guts_index);
  Mock.psa_hash_clone_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_hash_clone(cmock_call_instance, source_operation, target_operation);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_hash_clone_AddCallback(CMOCK_psa_hash_clone_CALLBACK Callback)
{
  Mock.psa_hash_clone_IgnoreBool = (char)0;
  Mock.psa_hash_clone_CallbackBool = (char)1;
  Mock.psa_hash_clone_CallbackFunctionPointer = Callback;
}

void psa_hash_clone_Stub(CMOCK_psa_hash_clone_CALLBACK Callback)
{
  Mock.psa_hash_clone_IgnoreBool = (char)0;
  Mock.psa_hash_clone_CallbackBool = (char)0;
  Mock.psa_hash_clone_CallbackFunctionPointer = Callback;
}

psa_status_t psa_mac_compute(psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* mac, size_t mac_size, size_t* mac_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_mac_compute_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_mac_compute);
  cmock_call_instance = (CMOCK_psa_mac_compute_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_mac_compute_CallInstance);
  Mock.psa_mac_compute_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_compute_CallInstance);
  if (Mock.psa_mac_compute_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_mac_compute_FinalReturn;
    memcpy((void*)(&Mock.psa_mac_compute_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_mac_compute_CallbackBool &&
      Mock.psa_mac_compute_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_mac_compute_CallbackFunctionPointer(key, alg, input, input_length, mac, mac_size, mac_length, Mock.psa_mac_compute_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_compute,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_compute,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_compute,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_compute,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_compute,CMockString_mac);
    if (cmock_call_instance->Expected_mac == NULL)
      { UNITY_TEST_ASSERT_NULL(mac, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_mac, mac, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_compute,CMockString_mac_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mac_size), (void*)(&mac_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_compute,CMockString_mac_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_mac_length), (void*)(mac_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_mac_compute_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_mac_compute_CallbackFunctionPointer(key, alg, input, input_length, mac, mac_size, mac_length, Mock.psa_mac_compute_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_mac_compute(CMOCK_psa_mac_compute_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* mac, size_t mac_size, size_t* mac_length);
void CMockExpectParameters_psa_mac_compute(CMOCK_psa_mac_compute_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* mac, size_t mac_size, size_t* mac_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_mac = mac;
  memcpy((void*)(&cmock_call_instance->Expected_mac_size), (void*)(&mac_size),
         sizeof(size_t[sizeof(mac_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_mac_length = mac_length;
}

void psa_mac_compute_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_compute_CALL_INSTANCE));
  CMOCK_psa_mac_compute_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_compute_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_compute_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_compute_CallInstance, cmock_guts_index);
  Mock.psa_mac_compute_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_mac_compute_IgnoreBool = (char)1;
}

void psa_mac_compute_CMockStopIgnore(void)
{
  if(Mock.psa_mac_compute_IgnoreBool)
    Mock.psa_mac_compute_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_compute_CallInstance);
  Mock.psa_mac_compute_IgnoreBool = (char)0;
}

void psa_mac_compute_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* mac, size_t mac_size, size_t* mac_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_compute_CALL_INSTANCE));
  CMOCK_psa_mac_compute_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_compute_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_compute_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_compute_CallInstance, cmock_guts_index);
  Mock.psa_mac_compute_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_mac_compute(cmock_call_instance, key, alg, input, input_length, mac, mac_size, mac_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_mac_compute_AddCallback(CMOCK_psa_mac_compute_CALLBACK Callback)
{
  Mock.psa_mac_compute_IgnoreBool = (char)0;
  Mock.psa_mac_compute_CallbackBool = (char)1;
  Mock.psa_mac_compute_CallbackFunctionPointer = Callback;
}

void psa_mac_compute_Stub(CMOCK_psa_mac_compute_CALLBACK Callback)
{
  Mock.psa_mac_compute_IgnoreBool = (char)0;
  Mock.psa_mac_compute_CallbackBool = (char)0;
  Mock.psa_mac_compute_CallbackFunctionPointer = Callback;
}

psa_status_t psa_mac_verify(psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* mac, size_t mac_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_mac_verify_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_mac_verify);
  cmock_call_instance = (CMOCK_psa_mac_verify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_mac_verify_CallInstance);
  Mock.psa_mac_verify_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_verify_CallInstance);
  if (Mock.psa_mac_verify_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_mac_verify_FinalReturn;
    memcpy((void*)(&Mock.psa_mac_verify_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_mac_verify_CallbackBool &&
      Mock.psa_mac_verify_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_mac_verify_CallbackFunctionPointer(key, alg, input, input_length, mac, mac_length, Mock.psa_mac_verify_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_verify,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_verify,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_verify,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_verify,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_verify,CMockString_mac);
    if (cmock_call_instance->Expected_mac == NULL)
      { UNITY_TEST_ASSERT_NULL(mac, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_mac, mac, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_verify,CMockString_mac_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mac_length), (void*)(&mac_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_mac_verify_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_mac_verify_CallbackFunctionPointer(key, alg, input, input_length, mac, mac_length, Mock.psa_mac_verify_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_mac_verify(CMOCK_psa_mac_verify_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* mac, size_t mac_length);
void CMockExpectParameters_psa_mac_verify(CMOCK_psa_mac_verify_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* mac, size_t mac_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_mac = mac;
  memcpy((void*)(&cmock_call_instance->Expected_mac_length), (void*)(&mac_length),
         sizeof(size_t[sizeof(mac_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_mac_verify_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_verify_CALL_INSTANCE));
  CMOCK_psa_mac_verify_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_verify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_verify_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_verify_CallInstance, cmock_guts_index);
  Mock.psa_mac_verify_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_mac_verify_IgnoreBool = (char)1;
}

void psa_mac_verify_CMockStopIgnore(void)
{
  if(Mock.psa_mac_verify_IgnoreBool)
    Mock.psa_mac_verify_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_verify_CallInstance);
  Mock.psa_mac_verify_IgnoreBool = (char)0;
}

void psa_mac_verify_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* mac, size_t mac_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_verify_CALL_INSTANCE));
  CMOCK_psa_mac_verify_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_verify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_verify_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_verify_CallInstance, cmock_guts_index);
  Mock.psa_mac_verify_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_mac_verify(cmock_call_instance, key, alg, input, input_length, mac, mac_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_mac_verify_AddCallback(CMOCK_psa_mac_verify_CALLBACK Callback)
{
  Mock.psa_mac_verify_IgnoreBool = (char)0;
  Mock.psa_mac_verify_CallbackBool = (char)1;
  Mock.psa_mac_verify_CallbackFunctionPointer = Callback;
}

void psa_mac_verify_Stub(CMOCK_psa_mac_verify_CALLBACK Callback)
{
  Mock.psa_mac_verify_IgnoreBool = (char)0;
  Mock.psa_mac_verify_CallbackBool = (char)0;
  Mock.psa_mac_verify_CallbackFunctionPointer = Callback;
}

psa_mac_operation_t psa_mac_operation_init(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_mac_operation_init_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_mac_operation_init);
  cmock_call_instance = (CMOCK_psa_mac_operation_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_mac_operation_init_CallInstance);
  Mock.psa_mac_operation_init_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_operation_init_CallInstance);
  if (Mock.psa_mac_operation_init_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_mac_operation_init_FinalReturn;
    memcpy((void*)(&Mock.psa_mac_operation_init_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_mac_operation_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_mac_operation_t) ? 1 : -1])); /* add psa_mac_operation_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_mac_operation_init_CallbackBool &&
      Mock.psa_mac_operation_init_CallbackFunctionPointer != NULL)
  {
    psa_mac_operation_t cmock_cb_ret = Mock.psa_mac_operation_init_CallbackFunctionPointer(Mock.psa_mac_operation_init_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.psa_mac_operation_init_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_mac_operation_init_CallbackFunctionPointer(Mock.psa_mac_operation_init_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void psa_mac_operation_init_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_mac_operation_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_operation_init_CALL_INSTANCE));
  CMOCK_psa_mac_operation_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_operation_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_operation_init_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_operation_init_CallInstance, cmock_guts_index);
  Mock.psa_mac_operation_init_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_mac_operation_init_IgnoreBool = (char)1;
}

void psa_mac_operation_init_CMockStopIgnore(void)
{
  if(Mock.psa_mac_operation_init_IgnoreBool)
    Mock.psa_mac_operation_init_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_operation_init_CallInstance);
  Mock.psa_mac_operation_init_IgnoreBool = (char)0;
}

void psa_mac_operation_init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_mac_operation_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_operation_init_CALL_INSTANCE));
  CMOCK_psa_mac_operation_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_operation_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_operation_init_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_operation_init_CallInstance, cmock_guts_index);
  Mock.psa_mac_operation_init_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_mac_operation_t[sizeof(cmock_to_return) == sizeof(psa_mac_operation_t) ? 1 : -1])); /* add psa_mac_operation_t to :treat_as_array if this causes an error */
}

void psa_mac_operation_init_AddCallback(CMOCK_psa_mac_operation_init_CALLBACK Callback)
{
  Mock.psa_mac_operation_init_IgnoreBool = (char)0;
  Mock.psa_mac_operation_init_CallbackBool = (char)1;
  Mock.psa_mac_operation_init_CallbackFunctionPointer = Callback;
}

void psa_mac_operation_init_Stub(CMOCK_psa_mac_operation_init_CALLBACK Callback)
{
  Mock.psa_mac_operation_init_IgnoreBool = (char)0;
  Mock.psa_mac_operation_init_CallbackBool = (char)0;
  Mock.psa_mac_operation_init_CallbackFunctionPointer = Callback;
}

psa_status_t psa_mac_sign_setup(psa_mac_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_mac_sign_setup_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_mac_sign_setup);
  cmock_call_instance = (CMOCK_psa_mac_sign_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_mac_sign_setup_CallInstance);
  Mock.psa_mac_sign_setup_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_sign_setup_CallInstance);
  if (Mock.psa_mac_sign_setup_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_mac_sign_setup_FinalReturn;
    memcpy((void*)(&Mock.psa_mac_sign_setup_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_mac_sign_setup_CallbackBool &&
      Mock.psa_mac_sign_setup_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_mac_sign_setup_CallbackFunctionPointer(operation, key, alg, Mock.psa_mac_sign_setup_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_sign_setup,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_mac_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_sign_setup,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_sign_setup,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_mac_sign_setup_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_mac_sign_setup_CallbackFunctionPointer(operation, key, alg, Mock.psa_mac_sign_setup_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_mac_sign_setup(CMOCK_psa_mac_sign_setup_CALL_INSTANCE* cmock_call_instance, psa_mac_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg);
void CMockExpectParameters_psa_mac_sign_setup(CMOCK_psa_mac_sign_setup_CALL_INSTANCE* cmock_call_instance, psa_mac_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
}

void psa_mac_sign_setup_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_sign_setup_CALL_INSTANCE));
  CMOCK_psa_mac_sign_setup_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_sign_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_sign_setup_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_sign_setup_CallInstance, cmock_guts_index);
  Mock.psa_mac_sign_setup_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_mac_sign_setup_IgnoreBool = (char)1;
}

void psa_mac_sign_setup_CMockStopIgnore(void)
{
  if(Mock.psa_mac_sign_setup_IgnoreBool)
    Mock.psa_mac_sign_setup_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_sign_setup_CallInstance);
  Mock.psa_mac_sign_setup_IgnoreBool = (char)0;
}

void psa_mac_sign_setup_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_mac_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_sign_setup_CALL_INSTANCE));
  CMOCK_psa_mac_sign_setup_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_sign_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_sign_setup_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_sign_setup_CallInstance, cmock_guts_index);
  Mock.psa_mac_sign_setup_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_mac_sign_setup(cmock_call_instance, operation, key, alg);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_mac_sign_setup_AddCallback(CMOCK_psa_mac_sign_setup_CALLBACK Callback)
{
  Mock.psa_mac_sign_setup_IgnoreBool = (char)0;
  Mock.psa_mac_sign_setup_CallbackBool = (char)1;
  Mock.psa_mac_sign_setup_CallbackFunctionPointer = Callback;
}

void psa_mac_sign_setup_Stub(CMOCK_psa_mac_sign_setup_CALLBACK Callback)
{
  Mock.psa_mac_sign_setup_IgnoreBool = (char)0;
  Mock.psa_mac_sign_setup_CallbackBool = (char)0;
  Mock.psa_mac_sign_setup_CallbackFunctionPointer = Callback;
}

psa_status_t psa_mac_verify_setup(psa_mac_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_mac_verify_setup_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_mac_verify_setup);
  cmock_call_instance = (CMOCK_psa_mac_verify_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_mac_verify_setup_CallInstance);
  Mock.psa_mac_verify_setup_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_verify_setup_CallInstance);
  if (Mock.psa_mac_verify_setup_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_mac_verify_setup_FinalReturn;
    memcpy((void*)(&Mock.psa_mac_verify_setup_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_mac_verify_setup_CallbackBool &&
      Mock.psa_mac_verify_setup_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_mac_verify_setup_CallbackFunctionPointer(operation, key, alg, Mock.psa_mac_verify_setup_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_verify_setup,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_mac_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_verify_setup,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_verify_setup,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_mac_verify_setup_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_mac_verify_setup_CallbackFunctionPointer(operation, key, alg, Mock.psa_mac_verify_setup_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_mac_verify_setup(CMOCK_psa_mac_verify_setup_CALL_INSTANCE* cmock_call_instance, psa_mac_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg);
void CMockExpectParameters_psa_mac_verify_setup(CMOCK_psa_mac_verify_setup_CALL_INSTANCE* cmock_call_instance, psa_mac_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
}

void psa_mac_verify_setup_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_verify_setup_CALL_INSTANCE));
  CMOCK_psa_mac_verify_setup_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_verify_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_verify_setup_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_verify_setup_CallInstance, cmock_guts_index);
  Mock.psa_mac_verify_setup_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_mac_verify_setup_IgnoreBool = (char)1;
}

void psa_mac_verify_setup_CMockStopIgnore(void)
{
  if(Mock.psa_mac_verify_setup_IgnoreBool)
    Mock.psa_mac_verify_setup_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_verify_setup_CallInstance);
  Mock.psa_mac_verify_setup_IgnoreBool = (char)0;
}

void psa_mac_verify_setup_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_mac_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_verify_setup_CALL_INSTANCE));
  CMOCK_psa_mac_verify_setup_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_verify_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_verify_setup_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_verify_setup_CallInstance, cmock_guts_index);
  Mock.psa_mac_verify_setup_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_mac_verify_setup(cmock_call_instance, operation, key, alg);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_mac_verify_setup_AddCallback(CMOCK_psa_mac_verify_setup_CALLBACK Callback)
{
  Mock.psa_mac_verify_setup_IgnoreBool = (char)0;
  Mock.psa_mac_verify_setup_CallbackBool = (char)1;
  Mock.psa_mac_verify_setup_CallbackFunctionPointer = Callback;
}

void psa_mac_verify_setup_Stub(CMOCK_psa_mac_verify_setup_CALLBACK Callback)
{
  Mock.psa_mac_verify_setup_IgnoreBool = (char)0;
  Mock.psa_mac_verify_setup_CallbackBool = (char)0;
  Mock.psa_mac_verify_setup_CallbackFunctionPointer = Callback;
}

psa_status_t psa_mac_update(psa_mac_operation_t* operation, const uint8_t* input, size_t input_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_mac_update_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_mac_update);
  cmock_call_instance = (CMOCK_psa_mac_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_mac_update_CallInstance);
  Mock.psa_mac_update_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_update_CallInstance);
  if (Mock.psa_mac_update_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_mac_update_FinalReturn;
    memcpy((void*)(&Mock.psa_mac_update_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_mac_update_CallbackBool &&
      Mock.psa_mac_update_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_mac_update_CallbackFunctionPointer(operation, input, input_length, Mock.psa_mac_update_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_update,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_mac_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_update,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_update,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_mac_update_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_mac_update_CallbackFunctionPointer(operation, input, input_length, Mock.psa_mac_update_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_mac_update(CMOCK_psa_mac_update_CALL_INSTANCE* cmock_call_instance, psa_mac_operation_t* operation, const uint8_t* input, size_t input_length);
void CMockExpectParameters_psa_mac_update(CMOCK_psa_mac_update_CALL_INSTANCE* cmock_call_instance, psa_mac_operation_t* operation, const uint8_t* input, size_t input_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_mac_update_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_update_CALL_INSTANCE));
  CMOCK_psa_mac_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_update_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_update_CallInstance, cmock_guts_index);
  Mock.psa_mac_update_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_mac_update_IgnoreBool = (char)1;
}

void psa_mac_update_CMockStopIgnore(void)
{
  if(Mock.psa_mac_update_IgnoreBool)
    Mock.psa_mac_update_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_update_CallInstance);
  Mock.psa_mac_update_IgnoreBool = (char)0;
}

void psa_mac_update_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_mac_operation_t* operation, const uint8_t* input, size_t input_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_update_CALL_INSTANCE));
  CMOCK_psa_mac_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_update_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_update_CallInstance, cmock_guts_index);
  Mock.psa_mac_update_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_mac_update(cmock_call_instance, operation, input, input_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_mac_update_AddCallback(CMOCK_psa_mac_update_CALLBACK Callback)
{
  Mock.psa_mac_update_IgnoreBool = (char)0;
  Mock.psa_mac_update_CallbackBool = (char)1;
  Mock.psa_mac_update_CallbackFunctionPointer = Callback;
}

void psa_mac_update_Stub(CMOCK_psa_mac_update_CALLBACK Callback)
{
  Mock.psa_mac_update_IgnoreBool = (char)0;
  Mock.psa_mac_update_CallbackBool = (char)0;
  Mock.psa_mac_update_CallbackFunctionPointer = Callback;
}

psa_status_t psa_mac_sign_finish(psa_mac_operation_t* operation, uint8_t* mac, size_t mac_size, size_t* mac_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_mac_sign_finish_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_mac_sign_finish);
  cmock_call_instance = (CMOCK_psa_mac_sign_finish_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_mac_sign_finish_CallInstance);
  Mock.psa_mac_sign_finish_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_sign_finish_CallInstance);
  if (Mock.psa_mac_sign_finish_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_mac_sign_finish_FinalReturn;
    memcpy((void*)(&Mock.psa_mac_sign_finish_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_mac_sign_finish_CallbackBool &&
      Mock.psa_mac_sign_finish_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_mac_sign_finish_CallbackFunctionPointer(operation, mac, mac_size, mac_length, Mock.psa_mac_sign_finish_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_sign_finish,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_mac_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_sign_finish,CMockString_mac);
    if (cmock_call_instance->Expected_mac == NULL)
      { UNITY_TEST_ASSERT_NULL(mac, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_mac, mac, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_sign_finish,CMockString_mac_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mac_size), (void*)(&mac_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_sign_finish,CMockString_mac_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_mac_length), (void*)(mac_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_mac_sign_finish_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_mac_sign_finish_CallbackFunctionPointer(operation, mac, mac_size, mac_length, Mock.psa_mac_sign_finish_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_mac_sign_finish(CMOCK_psa_mac_sign_finish_CALL_INSTANCE* cmock_call_instance, psa_mac_operation_t* operation, uint8_t* mac, size_t mac_size, size_t* mac_length);
void CMockExpectParameters_psa_mac_sign_finish(CMOCK_psa_mac_sign_finish_CALL_INSTANCE* cmock_call_instance, psa_mac_operation_t* operation, uint8_t* mac, size_t mac_size, size_t* mac_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_mac = mac;
  memcpy((void*)(&cmock_call_instance->Expected_mac_size), (void*)(&mac_size),
         sizeof(size_t[sizeof(mac_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_mac_length = mac_length;
}

void psa_mac_sign_finish_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_sign_finish_CALL_INSTANCE));
  CMOCK_psa_mac_sign_finish_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_sign_finish_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_sign_finish_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_sign_finish_CallInstance, cmock_guts_index);
  Mock.psa_mac_sign_finish_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_mac_sign_finish_IgnoreBool = (char)1;
}

void psa_mac_sign_finish_CMockStopIgnore(void)
{
  if(Mock.psa_mac_sign_finish_IgnoreBool)
    Mock.psa_mac_sign_finish_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_sign_finish_CallInstance);
  Mock.psa_mac_sign_finish_IgnoreBool = (char)0;
}

void psa_mac_sign_finish_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_mac_operation_t* operation, uint8_t* mac, size_t mac_size, size_t* mac_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_sign_finish_CALL_INSTANCE));
  CMOCK_psa_mac_sign_finish_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_sign_finish_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_sign_finish_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_sign_finish_CallInstance, cmock_guts_index);
  Mock.psa_mac_sign_finish_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_mac_sign_finish(cmock_call_instance, operation, mac, mac_size, mac_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_mac_sign_finish_AddCallback(CMOCK_psa_mac_sign_finish_CALLBACK Callback)
{
  Mock.psa_mac_sign_finish_IgnoreBool = (char)0;
  Mock.psa_mac_sign_finish_CallbackBool = (char)1;
  Mock.psa_mac_sign_finish_CallbackFunctionPointer = Callback;
}

void psa_mac_sign_finish_Stub(CMOCK_psa_mac_sign_finish_CALLBACK Callback)
{
  Mock.psa_mac_sign_finish_IgnoreBool = (char)0;
  Mock.psa_mac_sign_finish_CallbackBool = (char)0;
  Mock.psa_mac_sign_finish_CallbackFunctionPointer = Callback;
}

psa_status_t psa_mac_verify_finish(psa_mac_operation_t* operation, const uint8_t* mac, size_t mac_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_mac_verify_finish_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_mac_verify_finish);
  cmock_call_instance = (CMOCK_psa_mac_verify_finish_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_mac_verify_finish_CallInstance);
  Mock.psa_mac_verify_finish_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_verify_finish_CallInstance);
  if (Mock.psa_mac_verify_finish_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_mac_verify_finish_FinalReturn;
    memcpy((void*)(&Mock.psa_mac_verify_finish_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_mac_verify_finish_CallbackBool &&
      Mock.psa_mac_verify_finish_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_mac_verify_finish_CallbackFunctionPointer(operation, mac, mac_length, Mock.psa_mac_verify_finish_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_verify_finish,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_mac_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_verify_finish,CMockString_mac);
    if (cmock_call_instance->Expected_mac == NULL)
      { UNITY_TEST_ASSERT_NULL(mac, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_mac, mac, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_verify_finish,CMockString_mac_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mac_length), (void*)(&mac_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_mac_verify_finish_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_mac_verify_finish_CallbackFunctionPointer(operation, mac, mac_length, Mock.psa_mac_verify_finish_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_mac_verify_finish(CMOCK_psa_mac_verify_finish_CALL_INSTANCE* cmock_call_instance, psa_mac_operation_t* operation, const uint8_t* mac, size_t mac_length);
void CMockExpectParameters_psa_mac_verify_finish(CMOCK_psa_mac_verify_finish_CALL_INSTANCE* cmock_call_instance, psa_mac_operation_t* operation, const uint8_t* mac, size_t mac_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_mac = mac;
  memcpy((void*)(&cmock_call_instance->Expected_mac_length), (void*)(&mac_length),
         sizeof(size_t[sizeof(mac_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_mac_verify_finish_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_verify_finish_CALL_INSTANCE));
  CMOCK_psa_mac_verify_finish_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_verify_finish_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_verify_finish_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_verify_finish_CallInstance, cmock_guts_index);
  Mock.psa_mac_verify_finish_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_mac_verify_finish_IgnoreBool = (char)1;
}

void psa_mac_verify_finish_CMockStopIgnore(void)
{
  if(Mock.psa_mac_verify_finish_IgnoreBool)
    Mock.psa_mac_verify_finish_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_verify_finish_CallInstance);
  Mock.psa_mac_verify_finish_IgnoreBool = (char)0;
}

void psa_mac_verify_finish_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_mac_operation_t* operation, const uint8_t* mac, size_t mac_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_verify_finish_CALL_INSTANCE));
  CMOCK_psa_mac_verify_finish_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_verify_finish_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_verify_finish_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_verify_finish_CallInstance, cmock_guts_index);
  Mock.psa_mac_verify_finish_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_mac_verify_finish(cmock_call_instance, operation, mac, mac_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_mac_verify_finish_AddCallback(CMOCK_psa_mac_verify_finish_CALLBACK Callback)
{
  Mock.psa_mac_verify_finish_IgnoreBool = (char)0;
  Mock.psa_mac_verify_finish_CallbackBool = (char)1;
  Mock.psa_mac_verify_finish_CallbackFunctionPointer = Callback;
}

void psa_mac_verify_finish_Stub(CMOCK_psa_mac_verify_finish_CALLBACK Callback)
{
  Mock.psa_mac_verify_finish_IgnoreBool = (char)0;
  Mock.psa_mac_verify_finish_CallbackBool = (char)0;
  Mock.psa_mac_verify_finish_CallbackFunctionPointer = Callback;
}

psa_status_t psa_mac_abort(psa_mac_operation_t* operation)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_mac_abort_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_mac_abort);
  cmock_call_instance = (CMOCK_psa_mac_abort_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_mac_abort_CallInstance);
  Mock.psa_mac_abort_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_abort_CallInstance);
  if (Mock.psa_mac_abort_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_mac_abort_FinalReturn;
    memcpy((void*)(&Mock.psa_mac_abort_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_mac_abort_CallbackBool &&
      Mock.psa_mac_abort_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_mac_abort_CallbackFunctionPointer(operation, Mock.psa_mac_abort_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_mac_abort,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_mac_operation_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_mac_abort_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_mac_abort_CallbackFunctionPointer(operation, Mock.psa_mac_abort_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_mac_abort(CMOCK_psa_mac_abort_CALL_INSTANCE* cmock_call_instance, psa_mac_operation_t* operation);
void CMockExpectParameters_psa_mac_abort(CMOCK_psa_mac_abort_CALL_INSTANCE* cmock_call_instance, psa_mac_operation_t* operation)
{
  cmock_call_instance->Expected_operation = operation;
}

void psa_mac_abort_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_abort_CALL_INSTANCE));
  CMOCK_psa_mac_abort_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_abort_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_abort_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_abort_CallInstance, cmock_guts_index);
  Mock.psa_mac_abort_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_mac_abort_IgnoreBool = (char)1;
}

void psa_mac_abort_CMockStopIgnore(void)
{
  if(Mock.psa_mac_abort_IgnoreBool)
    Mock.psa_mac_abort_CallInstance = CMock_Guts_MemNext(Mock.psa_mac_abort_CallInstance);
  Mock.psa_mac_abort_IgnoreBool = (char)0;
}

void psa_mac_abort_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_mac_operation_t* operation, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_mac_abort_CALL_INSTANCE));
  CMOCK_psa_mac_abort_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_mac_abort_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_mac_abort_CallInstance = CMock_Guts_MemChain(Mock.psa_mac_abort_CallInstance, cmock_guts_index);
  Mock.psa_mac_abort_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_mac_abort(cmock_call_instance, operation);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_mac_abort_AddCallback(CMOCK_psa_mac_abort_CALLBACK Callback)
{
  Mock.psa_mac_abort_IgnoreBool = (char)0;
  Mock.psa_mac_abort_CallbackBool = (char)1;
  Mock.psa_mac_abort_CallbackFunctionPointer = Callback;
}

void psa_mac_abort_Stub(CMOCK_psa_mac_abort_CALLBACK Callback)
{
  Mock.psa_mac_abort_IgnoreBool = (char)0;
  Mock.psa_mac_abort_CallbackBool = (char)0;
  Mock.psa_mac_abort_CallbackFunctionPointer = Callback;
}

psa_status_t psa_cipher_encrypt(psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_cipher_encrypt_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_cipher_encrypt);
  cmock_call_instance = (CMOCK_psa_cipher_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_cipher_encrypt_CallInstance);
  Mock.psa_cipher_encrypt_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_encrypt_CallInstance);
  if (Mock.psa_cipher_encrypt_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_cipher_encrypt_FinalReturn;
    memcpy((void*)(&Mock.psa_cipher_encrypt_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_cipher_encrypt_CallbackBool &&
      Mock.psa_cipher_encrypt_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_cipher_encrypt_CallbackFunctionPointer(key, alg, input, input_length, output, output_size, output_length, Mock.psa_cipher_encrypt_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_encrypt,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_encrypt,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_encrypt,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_encrypt,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_encrypt,CMockString_output);
    if (cmock_call_instance->Expected_output == NULL)
      { UNITY_TEST_ASSERT_NULL(output, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_output, output, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_encrypt,CMockString_output_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_encrypt,CMockString_output_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_output_length), (void*)(output_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_cipher_encrypt_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_cipher_encrypt_CallbackFunctionPointer(key, alg, input, input_length, output, output_size, output_length, Mock.psa_cipher_encrypt_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_cipher_encrypt(CMOCK_psa_cipher_encrypt_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length);
void CMockExpectParameters_psa_cipher_encrypt(CMOCK_psa_cipher_encrypt_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output = output;
  memcpy((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size),
         sizeof(size_t[sizeof(output_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output_length = output_length;
}

void psa_cipher_encrypt_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_encrypt_CALL_INSTANCE));
  CMOCK_psa_cipher_encrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_encrypt_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_encrypt_CallInstance, cmock_guts_index);
  Mock.psa_cipher_encrypt_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_cipher_encrypt_IgnoreBool = (char)1;
}

void psa_cipher_encrypt_CMockStopIgnore(void)
{
  if(Mock.psa_cipher_encrypt_IgnoreBool)
    Mock.psa_cipher_encrypt_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_encrypt_CallInstance);
  Mock.psa_cipher_encrypt_IgnoreBool = (char)0;
}

void psa_cipher_encrypt_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_encrypt_CALL_INSTANCE));
  CMOCK_psa_cipher_encrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_encrypt_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_encrypt_CallInstance, cmock_guts_index);
  Mock.psa_cipher_encrypt_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_cipher_encrypt(cmock_call_instance, key, alg, input, input_length, output, output_size, output_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_cipher_encrypt_AddCallback(CMOCK_psa_cipher_encrypt_CALLBACK Callback)
{
  Mock.psa_cipher_encrypt_IgnoreBool = (char)0;
  Mock.psa_cipher_encrypt_CallbackBool = (char)1;
  Mock.psa_cipher_encrypt_CallbackFunctionPointer = Callback;
}

void psa_cipher_encrypt_Stub(CMOCK_psa_cipher_encrypt_CALLBACK Callback)
{
  Mock.psa_cipher_encrypt_IgnoreBool = (char)0;
  Mock.psa_cipher_encrypt_CallbackBool = (char)0;
  Mock.psa_cipher_encrypt_CallbackFunctionPointer = Callback;
}

psa_status_t psa_cipher_decrypt(psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_cipher_decrypt_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_cipher_decrypt);
  cmock_call_instance = (CMOCK_psa_cipher_decrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_cipher_decrypt_CallInstance);
  Mock.psa_cipher_decrypt_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_decrypt_CallInstance);
  if (Mock.psa_cipher_decrypt_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_cipher_decrypt_FinalReturn;
    memcpy((void*)(&Mock.psa_cipher_decrypt_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_cipher_decrypt_CallbackBool &&
      Mock.psa_cipher_decrypt_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_cipher_decrypt_CallbackFunctionPointer(key, alg, input, input_length, output, output_size, output_length, Mock.psa_cipher_decrypt_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_decrypt,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_decrypt,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_decrypt,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_decrypt,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_decrypt,CMockString_output);
    if (cmock_call_instance->Expected_output == NULL)
      { UNITY_TEST_ASSERT_NULL(output, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_output, output, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_decrypt,CMockString_output_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_decrypt,CMockString_output_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_output_length), (void*)(output_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_cipher_decrypt_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_cipher_decrypt_CallbackFunctionPointer(key, alg, input, input_length, output, output_size, output_length, Mock.psa_cipher_decrypt_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_cipher_decrypt(CMOCK_psa_cipher_decrypt_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length);
void CMockExpectParameters_psa_cipher_decrypt(CMOCK_psa_cipher_decrypt_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output = output;
  memcpy((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size),
         sizeof(size_t[sizeof(output_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output_length = output_length;
}

void psa_cipher_decrypt_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_decrypt_CALL_INSTANCE));
  CMOCK_psa_cipher_decrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_decrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_decrypt_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_decrypt_CallInstance, cmock_guts_index);
  Mock.psa_cipher_decrypt_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_cipher_decrypt_IgnoreBool = (char)1;
}

void psa_cipher_decrypt_CMockStopIgnore(void)
{
  if(Mock.psa_cipher_decrypt_IgnoreBool)
    Mock.psa_cipher_decrypt_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_decrypt_CallInstance);
  Mock.psa_cipher_decrypt_IgnoreBool = (char)0;
}

void psa_cipher_decrypt_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_decrypt_CALL_INSTANCE));
  CMOCK_psa_cipher_decrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_decrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_decrypt_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_decrypt_CallInstance, cmock_guts_index);
  Mock.psa_cipher_decrypt_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_cipher_decrypt(cmock_call_instance, key, alg, input, input_length, output, output_size, output_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_cipher_decrypt_AddCallback(CMOCK_psa_cipher_decrypt_CALLBACK Callback)
{
  Mock.psa_cipher_decrypt_IgnoreBool = (char)0;
  Mock.psa_cipher_decrypt_CallbackBool = (char)1;
  Mock.psa_cipher_decrypt_CallbackFunctionPointer = Callback;
}

void psa_cipher_decrypt_Stub(CMOCK_psa_cipher_decrypt_CALLBACK Callback)
{
  Mock.psa_cipher_decrypt_IgnoreBool = (char)0;
  Mock.psa_cipher_decrypt_CallbackBool = (char)0;
  Mock.psa_cipher_decrypt_CallbackFunctionPointer = Callback;
}

psa_cipher_operation_t psa_cipher_operation_init(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_cipher_operation_init_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_cipher_operation_init);
  cmock_call_instance = (CMOCK_psa_cipher_operation_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_cipher_operation_init_CallInstance);
  Mock.psa_cipher_operation_init_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_operation_init_CallInstance);
  if (Mock.psa_cipher_operation_init_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_cipher_operation_init_FinalReturn;
    memcpy((void*)(&Mock.psa_cipher_operation_init_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_cipher_operation_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_cipher_operation_t) ? 1 : -1])); /* add psa_cipher_operation_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_cipher_operation_init_CallbackBool &&
      Mock.psa_cipher_operation_init_CallbackFunctionPointer != NULL)
  {
    psa_cipher_operation_t cmock_cb_ret = Mock.psa_cipher_operation_init_CallbackFunctionPointer(Mock.psa_cipher_operation_init_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.psa_cipher_operation_init_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_cipher_operation_init_CallbackFunctionPointer(Mock.psa_cipher_operation_init_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void psa_cipher_operation_init_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_cipher_operation_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_operation_init_CALL_INSTANCE));
  CMOCK_psa_cipher_operation_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_operation_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_operation_init_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_operation_init_CallInstance, cmock_guts_index);
  Mock.psa_cipher_operation_init_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_cipher_operation_init_IgnoreBool = (char)1;
}

void psa_cipher_operation_init_CMockStopIgnore(void)
{
  if(Mock.psa_cipher_operation_init_IgnoreBool)
    Mock.psa_cipher_operation_init_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_operation_init_CallInstance);
  Mock.psa_cipher_operation_init_IgnoreBool = (char)0;
}

void psa_cipher_operation_init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_cipher_operation_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_operation_init_CALL_INSTANCE));
  CMOCK_psa_cipher_operation_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_operation_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_operation_init_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_operation_init_CallInstance, cmock_guts_index);
  Mock.psa_cipher_operation_init_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_cipher_operation_t[sizeof(cmock_to_return) == sizeof(psa_cipher_operation_t) ? 1 : -1])); /* add psa_cipher_operation_t to :treat_as_array if this causes an error */
}

void psa_cipher_operation_init_AddCallback(CMOCK_psa_cipher_operation_init_CALLBACK Callback)
{
  Mock.psa_cipher_operation_init_IgnoreBool = (char)0;
  Mock.psa_cipher_operation_init_CallbackBool = (char)1;
  Mock.psa_cipher_operation_init_CallbackFunctionPointer = Callback;
}

void psa_cipher_operation_init_Stub(CMOCK_psa_cipher_operation_init_CALLBACK Callback)
{
  Mock.psa_cipher_operation_init_IgnoreBool = (char)0;
  Mock.psa_cipher_operation_init_CallbackBool = (char)0;
  Mock.psa_cipher_operation_init_CallbackFunctionPointer = Callback;
}

psa_status_t psa_cipher_encrypt_setup(psa_cipher_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_cipher_encrypt_setup_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_cipher_encrypt_setup);
  cmock_call_instance = (CMOCK_psa_cipher_encrypt_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_cipher_encrypt_setup_CallInstance);
  Mock.psa_cipher_encrypt_setup_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_encrypt_setup_CallInstance);
  if (Mock.psa_cipher_encrypt_setup_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_cipher_encrypt_setup_FinalReturn;
    memcpy((void*)(&Mock.psa_cipher_encrypt_setup_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_cipher_encrypt_setup_CallbackBool &&
      Mock.psa_cipher_encrypt_setup_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_cipher_encrypt_setup_CallbackFunctionPointer(operation, key, alg, Mock.psa_cipher_encrypt_setup_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_encrypt_setup,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_cipher_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_encrypt_setup,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_encrypt_setup,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_cipher_encrypt_setup_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_cipher_encrypt_setup_CallbackFunctionPointer(operation, key, alg, Mock.psa_cipher_encrypt_setup_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_cipher_encrypt_setup(CMOCK_psa_cipher_encrypt_setup_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg);
void CMockExpectParameters_psa_cipher_encrypt_setup(CMOCK_psa_cipher_encrypt_setup_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
}

void psa_cipher_encrypt_setup_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_encrypt_setup_CALL_INSTANCE));
  CMOCK_psa_cipher_encrypt_setup_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_encrypt_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_encrypt_setup_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_encrypt_setup_CallInstance, cmock_guts_index);
  Mock.psa_cipher_encrypt_setup_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_cipher_encrypt_setup_IgnoreBool = (char)1;
}

void psa_cipher_encrypt_setup_CMockStopIgnore(void)
{
  if(Mock.psa_cipher_encrypt_setup_IgnoreBool)
    Mock.psa_cipher_encrypt_setup_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_encrypt_setup_CallInstance);
  Mock.psa_cipher_encrypt_setup_IgnoreBool = (char)0;
}

void psa_cipher_encrypt_setup_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_cipher_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_encrypt_setup_CALL_INSTANCE));
  CMOCK_psa_cipher_encrypt_setup_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_encrypt_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_encrypt_setup_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_encrypt_setup_CallInstance, cmock_guts_index);
  Mock.psa_cipher_encrypt_setup_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_cipher_encrypt_setup(cmock_call_instance, operation, key, alg);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_cipher_encrypt_setup_AddCallback(CMOCK_psa_cipher_encrypt_setup_CALLBACK Callback)
{
  Mock.psa_cipher_encrypt_setup_IgnoreBool = (char)0;
  Mock.psa_cipher_encrypt_setup_CallbackBool = (char)1;
  Mock.psa_cipher_encrypt_setup_CallbackFunctionPointer = Callback;
}

void psa_cipher_encrypt_setup_Stub(CMOCK_psa_cipher_encrypt_setup_CALLBACK Callback)
{
  Mock.psa_cipher_encrypt_setup_IgnoreBool = (char)0;
  Mock.psa_cipher_encrypt_setup_CallbackBool = (char)0;
  Mock.psa_cipher_encrypt_setup_CallbackFunctionPointer = Callback;
}

psa_status_t psa_cipher_decrypt_setup(psa_cipher_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_cipher_decrypt_setup_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_cipher_decrypt_setup);
  cmock_call_instance = (CMOCK_psa_cipher_decrypt_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_cipher_decrypt_setup_CallInstance);
  Mock.psa_cipher_decrypt_setup_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_decrypt_setup_CallInstance);
  if (Mock.psa_cipher_decrypt_setup_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_cipher_decrypt_setup_FinalReturn;
    memcpy((void*)(&Mock.psa_cipher_decrypt_setup_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_cipher_decrypt_setup_CallbackBool &&
      Mock.psa_cipher_decrypt_setup_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_cipher_decrypt_setup_CallbackFunctionPointer(operation, key, alg, Mock.psa_cipher_decrypt_setup_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_decrypt_setup,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_cipher_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_decrypt_setup,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_decrypt_setup,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_cipher_decrypt_setup_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_cipher_decrypt_setup_CallbackFunctionPointer(operation, key, alg, Mock.psa_cipher_decrypt_setup_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_cipher_decrypt_setup(CMOCK_psa_cipher_decrypt_setup_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg);
void CMockExpectParameters_psa_cipher_decrypt_setup(CMOCK_psa_cipher_decrypt_setup_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
}

void psa_cipher_decrypt_setup_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_decrypt_setup_CALL_INSTANCE));
  CMOCK_psa_cipher_decrypt_setup_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_decrypt_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_decrypt_setup_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_decrypt_setup_CallInstance, cmock_guts_index);
  Mock.psa_cipher_decrypt_setup_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_cipher_decrypt_setup_IgnoreBool = (char)1;
}

void psa_cipher_decrypt_setup_CMockStopIgnore(void)
{
  if(Mock.psa_cipher_decrypt_setup_IgnoreBool)
    Mock.psa_cipher_decrypt_setup_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_decrypt_setup_CallInstance);
  Mock.psa_cipher_decrypt_setup_IgnoreBool = (char)0;
}

void psa_cipher_decrypt_setup_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_cipher_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_decrypt_setup_CALL_INSTANCE));
  CMOCK_psa_cipher_decrypt_setup_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_decrypt_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_decrypt_setup_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_decrypt_setup_CallInstance, cmock_guts_index);
  Mock.psa_cipher_decrypt_setup_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_cipher_decrypt_setup(cmock_call_instance, operation, key, alg);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_cipher_decrypt_setup_AddCallback(CMOCK_psa_cipher_decrypt_setup_CALLBACK Callback)
{
  Mock.psa_cipher_decrypt_setup_IgnoreBool = (char)0;
  Mock.psa_cipher_decrypt_setup_CallbackBool = (char)1;
  Mock.psa_cipher_decrypt_setup_CallbackFunctionPointer = Callback;
}

void psa_cipher_decrypt_setup_Stub(CMOCK_psa_cipher_decrypt_setup_CALLBACK Callback)
{
  Mock.psa_cipher_decrypt_setup_IgnoreBool = (char)0;
  Mock.psa_cipher_decrypt_setup_CallbackBool = (char)0;
  Mock.psa_cipher_decrypt_setup_CallbackFunctionPointer = Callback;
}

psa_status_t psa_cipher_generate_iv(psa_cipher_operation_t* operation, uint8_t* iv, size_t iv_size, size_t* iv_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_cipher_generate_iv_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_cipher_generate_iv);
  cmock_call_instance = (CMOCK_psa_cipher_generate_iv_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_cipher_generate_iv_CallInstance);
  Mock.psa_cipher_generate_iv_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_generate_iv_CallInstance);
  if (Mock.psa_cipher_generate_iv_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_cipher_generate_iv_FinalReturn;
    memcpy((void*)(&Mock.psa_cipher_generate_iv_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_cipher_generate_iv_CallbackBool &&
      Mock.psa_cipher_generate_iv_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_cipher_generate_iv_CallbackFunctionPointer(operation, iv, iv_size, iv_length, Mock.psa_cipher_generate_iv_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_generate_iv,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_cipher_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_generate_iv,CMockString_iv);
    if (cmock_call_instance->Expected_iv == NULL)
      { UNITY_TEST_ASSERT_NULL(iv, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_iv, iv, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_generate_iv,CMockString_iv_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_iv_size), (void*)(&iv_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_generate_iv,CMockString_iv_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_iv_length), (void*)(iv_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_cipher_generate_iv_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_cipher_generate_iv_CallbackFunctionPointer(operation, iv, iv_size, iv_length, Mock.psa_cipher_generate_iv_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_cipher_generate_iv(CMOCK_psa_cipher_generate_iv_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation, uint8_t* iv, size_t iv_size, size_t* iv_length);
void CMockExpectParameters_psa_cipher_generate_iv(CMOCK_psa_cipher_generate_iv_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation, uint8_t* iv, size_t iv_size, size_t* iv_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_iv = iv;
  memcpy((void*)(&cmock_call_instance->Expected_iv_size), (void*)(&iv_size),
         sizeof(size_t[sizeof(iv_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_iv_length = iv_length;
}

void psa_cipher_generate_iv_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_generate_iv_CALL_INSTANCE));
  CMOCK_psa_cipher_generate_iv_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_generate_iv_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_generate_iv_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_generate_iv_CallInstance, cmock_guts_index);
  Mock.psa_cipher_generate_iv_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_cipher_generate_iv_IgnoreBool = (char)1;
}

void psa_cipher_generate_iv_CMockStopIgnore(void)
{
  if(Mock.psa_cipher_generate_iv_IgnoreBool)
    Mock.psa_cipher_generate_iv_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_generate_iv_CallInstance);
  Mock.psa_cipher_generate_iv_IgnoreBool = (char)0;
}

void psa_cipher_generate_iv_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_cipher_operation_t* operation, uint8_t* iv, size_t iv_size, size_t* iv_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_generate_iv_CALL_INSTANCE));
  CMOCK_psa_cipher_generate_iv_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_generate_iv_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_generate_iv_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_generate_iv_CallInstance, cmock_guts_index);
  Mock.psa_cipher_generate_iv_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_cipher_generate_iv(cmock_call_instance, operation, iv, iv_size, iv_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_cipher_generate_iv_AddCallback(CMOCK_psa_cipher_generate_iv_CALLBACK Callback)
{
  Mock.psa_cipher_generate_iv_IgnoreBool = (char)0;
  Mock.psa_cipher_generate_iv_CallbackBool = (char)1;
  Mock.psa_cipher_generate_iv_CallbackFunctionPointer = Callback;
}

void psa_cipher_generate_iv_Stub(CMOCK_psa_cipher_generate_iv_CALLBACK Callback)
{
  Mock.psa_cipher_generate_iv_IgnoreBool = (char)0;
  Mock.psa_cipher_generate_iv_CallbackBool = (char)0;
  Mock.psa_cipher_generate_iv_CallbackFunctionPointer = Callback;
}

psa_status_t psa_cipher_set_iv(psa_cipher_operation_t* operation, const uint8_t* iv, size_t iv_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_cipher_set_iv_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_cipher_set_iv);
  cmock_call_instance = (CMOCK_psa_cipher_set_iv_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_cipher_set_iv_CallInstance);
  Mock.psa_cipher_set_iv_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_set_iv_CallInstance);
  if (Mock.psa_cipher_set_iv_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_cipher_set_iv_FinalReturn;
    memcpy((void*)(&Mock.psa_cipher_set_iv_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_cipher_set_iv_CallbackBool &&
      Mock.psa_cipher_set_iv_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_cipher_set_iv_CallbackFunctionPointer(operation, iv, iv_length, Mock.psa_cipher_set_iv_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_set_iv,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_cipher_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_set_iv,CMockString_iv);
    if (cmock_call_instance->Expected_iv == NULL)
      { UNITY_TEST_ASSERT_NULL(iv, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_iv, iv, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_set_iv,CMockString_iv_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_iv_length), (void*)(&iv_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_cipher_set_iv_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_cipher_set_iv_CallbackFunctionPointer(operation, iv, iv_length, Mock.psa_cipher_set_iv_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_cipher_set_iv(CMOCK_psa_cipher_set_iv_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation, const uint8_t* iv, size_t iv_length);
void CMockExpectParameters_psa_cipher_set_iv(CMOCK_psa_cipher_set_iv_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation, const uint8_t* iv, size_t iv_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_iv = iv;
  memcpy((void*)(&cmock_call_instance->Expected_iv_length), (void*)(&iv_length),
         sizeof(size_t[sizeof(iv_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_cipher_set_iv_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_set_iv_CALL_INSTANCE));
  CMOCK_psa_cipher_set_iv_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_set_iv_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_set_iv_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_set_iv_CallInstance, cmock_guts_index);
  Mock.psa_cipher_set_iv_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_cipher_set_iv_IgnoreBool = (char)1;
}

void psa_cipher_set_iv_CMockStopIgnore(void)
{
  if(Mock.psa_cipher_set_iv_IgnoreBool)
    Mock.psa_cipher_set_iv_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_set_iv_CallInstance);
  Mock.psa_cipher_set_iv_IgnoreBool = (char)0;
}

void psa_cipher_set_iv_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_cipher_operation_t* operation, const uint8_t* iv, size_t iv_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_set_iv_CALL_INSTANCE));
  CMOCK_psa_cipher_set_iv_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_set_iv_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_set_iv_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_set_iv_CallInstance, cmock_guts_index);
  Mock.psa_cipher_set_iv_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_cipher_set_iv(cmock_call_instance, operation, iv, iv_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_cipher_set_iv_AddCallback(CMOCK_psa_cipher_set_iv_CALLBACK Callback)
{
  Mock.psa_cipher_set_iv_IgnoreBool = (char)0;
  Mock.psa_cipher_set_iv_CallbackBool = (char)1;
  Mock.psa_cipher_set_iv_CallbackFunctionPointer = Callback;
}

void psa_cipher_set_iv_Stub(CMOCK_psa_cipher_set_iv_CALLBACK Callback)
{
  Mock.psa_cipher_set_iv_IgnoreBool = (char)0;
  Mock.psa_cipher_set_iv_CallbackBool = (char)0;
  Mock.psa_cipher_set_iv_CallbackFunctionPointer = Callback;
}

psa_status_t psa_cipher_update(psa_cipher_operation_t* operation, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_cipher_update_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_cipher_update);
  cmock_call_instance = (CMOCK_psa_cipher_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_cipher_update_CallInstance);
  Mock.psa_cipher_update_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_update_CallInstance);
  if (Mock.psa_cipher_update_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_cipher_update_FinalReturn;
    memcpy((void*)(&Mock.psa_cipher_update_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_cipher_update_CallbackBool &&
      Mock.psa_cipher_update_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_cipher_update_CallbackFunctionPointer(operation, input, input_length, output, output_size, output_length, Mock.psa_cipher_update_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_update,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_cipher_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_update,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_update,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_update,CMockString_output);
    if (cmock_call_instance->Expected_output == NULL)
      { UNITY_TEST_ASSERT_NULL(output, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_output, output, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_update,CMockString_output_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_update,CMockString_output_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_output_length), (void*)(output_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_cipher_update_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_cipher_update_CallbackFunctionPointer(operation, input, input_length, output, output_size, output_length, Mock.psa_cipher_update_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_cipher_update(CMOCK_psa_cipher_update_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length);
void CMockExpectParameters_psa_cipher_update(CMOCK_psa_cipher_update_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output = output;
  memcpy((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size),
         sizeof(size_t[sizeof(output_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output_length = output_length;
}

void psa_cipher_update_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_update_CALL_INSTANCE));
  CMOCK_psa_cipher_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_update_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_update_CallInstance, cmock_guts_index);
  Mock.psa_cipher_update_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_cipher_update_IgnoreBool = (char)1;
}

void psa_cipher_update_CMockStopIgnore(void)
{
  if(Mock.psa_cipher_update_IgnoreBool)
    Mock.psa_cipher_update_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_update_CallInstance);
  Mock.psa_cipher_update_IgnoreBool = (char)0;
}

void psa_cipher_update_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_cipher_operation_t* operation, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_update_CALL_INSTANCE));
  CMOCK_psa_cipher_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_update_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_update_CallInstance, cmock_guts_index);
  Mock.psa_cipher_update_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_cipher_update(cmock_call_instance, operation, input, input_length, output, output_size, output_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_cipher_update_AddCallback(CMOCK_psa_cipher_update_CALLBACK Callback)
{
  Mock.psa_cipher_update_IgnoreBool = (char)0;
  Mock.psa_cipher_update_CallbackBool = (char)1;
  Mock.psa_cipher_update_CallbackFunctionPointer = Callback;
}

void psa_cipher_update_Stub(CMOCK_psa_cipher_update_CALLBACK Callback)
{
  Mock.psa_cipher_update_IgnoreBool = (char)0;
  Mock.psa_cipher_update_CallbackBool = (char)0;
  Mock.psa_cipher_update_CallbackFunctionPointer = Callback;
}

psa_status_t psa_cipher_finish(psa_cipher_operation_t* operation, uint8_t* output, size_t output_size, size_t* output_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_cipher_finish_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_cipher_finish);
  cmock_call_instance = (CMOCK_psa_cipher_finish_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_cipher_finish_CallInstance);
  Mock.psa_cipher_finish_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_finish_CallInstance);
  if (Mock.psa_cipher_finish_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_cipher_finish_FinalReturn;
    memcpy((void*)(&Mock.psa_cipher_finish_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_cipher_finish_CallbackBool &&
      Mock.psa_cipher_finish_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_cipher_finish_CallbackFunctionPointer(operation, output, output_size, output_length, Mock.psa_cipher_finish_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_finish,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_cipher_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_finish,CMockString_output);
    if (cmock_call_instance->Expected_output == NULL)
      { UNITY_TEST_ASSERT_NULL(output, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_output, output, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_finish,CMockString_output_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_finish,CMockString_output_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_output_length), (void*)(output_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_cipher_finish_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_cipher_finish_CallbackFunctionPointer(operation, output, output_size, output_length, Mock.psa_cipher_finish_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_cipher_finish(CMOCK_psa_cipher_finish_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation, uint8_t* output, size_t output_size, size_t* output_length);
void CMockExpectParameters_psa_cipher_finish(CMOCK_psa_cipher_finish_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation, uint8_t* output, size_t output_size, size_t* output_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_output = output;
  memcpy((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size),
         sizeof(size_t[sizeof(output_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output_length = output_length;
}

void psa_cipher_finish_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_finish_CALL_INSTANCE));
  CMOCK_psa_cipher_finish_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_finish_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_finish_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_finish_CallInstance, cmock_guts_index);
  Mock.psa_cipher_finish_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_cipher_finish_IgnoreBool = (char)1;
}

void psa_cipher_finish_CMockStopIgnore(void)
{
  if(Mock.psa_cipher_finish_IgnoreBool)
    Mock.psa_cipher_finish_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_finish_CallInstance);
  Mock.psa_cipher_finish_IgnoreBool = (char)0;
}

void psa_cipher_finish_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_cipher_operation_t* operation, uint8_t* output, size_t output_size, size_t* output_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_finish_CALL_INSTANCE));
  CMOCK_psa_cipher_finish_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_finish_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_finish_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_finish_CallInstance, cmock_guts_index);
  Mock.psa_cipher_finish_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_cipher_finish(cmock_call_instance, operation, output, output_size, output_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_cipher_finish_AddCallback(CMOCK_psa_cipher_finish_CALLBACK Callback)
{
  Mock.psa_cipher_finish_IgnoreBool = (char)0;
  Mock.psa_cipher_finish_CallbackBool = (char)1;
  Mock.psa_cipher_finish_CallbackFunctionPointer = Callback;
}

void psa_cipher_finish_Stub(CMOCK_psa_cipher_finish_CALLBACK Callback)
{
  Mock.psa_cipher_finish_IgnoreBool = (char)0;
  Mock.psa_cipher_finish_CallbackBool = (char)0;
  Mock.psa_cipher_finish_CallbackFunctionPointer = Callback;
}

psa_status_t psa_cipher_abort(psa_cipher_operation_t* operation)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_cipher_abort_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_cipher_abort);
  cmock_call_instance = (CMOCK_psa_cipher_abort_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_cipher_abort_CallInstance);
  Mock.psa_cipher_abort_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_abort_CallInstance);
  if (Mock.psa_cipher_abort_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_cipher_abort_FinalReturn;
    memcpy((void*)(&Mock.psa_cipher_abort_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_cipher_abort_CallbackBool &&
      Mock.psa_cipher_abort_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_cipher_abort_CallbackFunctionPointer(operation, Mock.psa_cipher_abort_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_cipher_abort,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_cipher_operation_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_cipher_abort_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_cipher_abort_CallbackFunctionPointer(operation, Mock.psa_cipher_abort_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_cipher_abort(CMOCK_psa_cipher_abort_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation);
void CMockExpectParameters_psa_cipher_abort(CMOCK_psa_cipher_abort_CALL_INSTANCE* cmock_call_instance, psa_cipher_operation_t* operation)
{
  cmock_call_instance->Expected_operation = operation;
}

void psa_cipher_abort_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_abort_CALL_INSTANCE));
  CMOCK_psa_cipher_abort_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_abort_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_abort_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_abort_CallInstance, cmock_guts_index);
  Mock.psa_cipher_abort_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_cipher_abort_IgnoreBool = (char)1;
}

void psa_cipher_abort_CMockStopIgnore(void)
{
  if(Mock.psa_cipher_abort_IgnoreBool)
    Mock.psa_cipher_abort_CallInstance = CMock_Guts_MemNext(Mock.psa_cipher_abort_CallInstance);
  Mock.psa_cipher_abort_IgnoreBool = (char)0;
}

void psa_cipher_abort_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_cipher_operation_t* operation, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_cipher_abort_CALL_INSTANCE));
  CMOCK_psa_cipher_abort_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_cipher_abort_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_cipher_abort_CallInstance = CMock_Guts_MemChain(Mock.psa_cipher_abort_CallInstance, cmock_guts_index);
  Mock.psa_cipher_abort_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_cipher_abort(cmock_call_instance, operation);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_cipher_abort_AddCallback(CMOCK_psa_cipher_abort_CALLBACK Callback)
{
  Mock.psa_cipher_abort_IgnoreBool = (char)0;
  Mock.psa_cipher_abort_CallbackBool = (char)1;
  Mock.psa_cipher_abort_CallbackFunctionPointer = Callback;
}

void psa_cipher_abort_Stub(CMOCK_psa_cipher_abort_CALLBACK Callback)
{
  Mock.psa_cipher_abort_IgnoreBool = (char)0;
  Mock.psa_cipher_abort_CallbackBool = (char)0;
  Mock.psa_cipher_abort_CallbackFunctionPointer = Callback;
}

psa_status_t psa_aead_encrypt(psa_key_id_t key, psa_algorithm_t alg, const uint8_t* nonce, size_t nonce_length, const uint8_t* additional_data, size_t additional_data_length, const uint8_t* plaintext, size_t plaintext_length, uint8_t* ciphertext, size_t ciphertext_size, size_t* ciphertext_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_encrypt_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_encrypt);
  cmock_call_instance = (CMOCK_psa_aead_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_encrypt_CallInstance);
  Mock.psa_aead_encrypt_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_encrypt_CallInstance);
  if (Mock.psa_aead_encrypt_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_aead_encrypt_FinalReturn;
    memcpy((void*)(&Mock.psa_aead_encrypt_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_aead_encrypt_CallbackBool &&
      Mock.psa_aead_encrypt_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_aead_encrypt_CallbackFunctionPointer(key, alg, nonce, nonce_length, additional_data, additional_data_length, plaintext, plaintext_length, ciphertext, ciphertext_size, ciphertext_length, Mock.psa_aead_encrypt_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt,CMockString_nonce);
    if (cmock_call_instance->Expected_nonce == NULL)
      { UNITY_TEST_ASSERT_NULL(nonce, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_nonce, nonce, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt,CMockString_nonce_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_nonce_length), (void*)(&nonce_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt,CMockString_additional_data);
    if (cmock_call_instance->Expected_additional_data == NULL)
      { UNITY_TEST_ASSERT_NULL(additional_data, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_additional_data, additional_data, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt,CMockString_additional_data_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_additional_data_length), (void*)(&additional_data_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt,CMockString_plaintext);
    if (cmock_call_instance->Expected_plaintext == NULL)
      { UNITY_TEST_ASSERT_NULL(plaintext, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_plaintext, plaintext, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt,CMockString_plaintext_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_plaintext_length), (void*)(&plaintext_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt,CMockString_ciphertext);
    if (cmock_call_instance->Expected_ciphertext == NULL)
      { UNITY_TEST_ASSERT_NULL(ciphertext, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_ciphertext, ciphertext, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt,CMockString_ciphertext_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ciphertext_size), (void*)(&ciphertext_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt,CMockString_ciphertext_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_ciphertext_length), (void*)(ciphertext_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_aead_encrypt_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_aead_encrypt_CallbackFunctionPointer(key, alg, nonce, nonce_length, additional_data, additional_data_length, plaintext, plaintext_length, ciphertext, ciphertext_size, ciphertext_length, Mock.psa_aead_encrypt_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_aead_encrypt(CMOCK_psa_aead_encrypt_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* nonce, size_t nonce_length, const uint8_t* additional_data, size_t additional_data_length, const uint8_t* plaintext, size_t plaintext_length, uint8_t* ciphertext, size_t ciphertext_size, size_t* ciphertext_length);
void CMockExpectParameters_psa_aead_encrypt(CMOCK_psa_aead_encrypt_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* nonce, size_t nonce_length, const uint8_t* additional_data, size_t additional_data_length, const uint8_t* plaintext, size_t plaintext_length, uint8_t* ciphertext, size_t ciphertext_size, size_t* ciphertext_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_nonce = nonce;
  memcpy((void*)(&cmock_call_instance->Expected_nonce_length), (void*)(&nonce_length),
         sizeof(size_t[sizeof(nonce_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_additional_data = additional_data;
  memcpy((void*)(&cmock_call_instance->Expected_additional_data_length), (void*)(&additional_data_length),
         sizeof(size_t[sizeof(additional_data_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_plaintext = plaintext;
  memcpy((void*)(&cmock_call_instance->Expected_plaintext_length), (void*)(&plaintext_length),
         sizeof(size_t[sizeof(plaintext_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_ciphertext = ciphertext;
  memcpy((void*)(&cmock_call_instance->Expected_ciphertext_size), (void*)(&ciphertext_size),
         sizeof(size_t[sizeof(ciphertext_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_ciphertext_length = ciphertext_length;
}

void psa_aead_encrypt_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_encrypt_CALL_INSTANCE));
  CMOCK_psa_aead_encrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_encrypt_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_encrypt_CallInstance, cmock_guts_index);
  Mock.psa_aead_encrypt_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_aead_encrypt_IgnoreBool = (char)1;
}

void psa_aead_encrypt_CMockStopIgnore(void)
{
  if(Mock.psa_aead_encrypt_IgnoreBool)
    Mock.psa_aead_encrypt_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_encrypt_CallInstance);
  Mock.psa_aead_encrypt_IgnoreBool = (char)0;
}

void psa_aead_encrypt_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* nonce, size_t nonce_length, const uint8_t* additional_data, size_t additional_data_length, const uint8_t* plaintext, size_t plaintext_length, uint8_t* ciphertext, size_t ciphertext_size, size_t* ciphertext_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_encrypt_CALL_INSTANCE));
  CMOCK_psa_aead_encrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_encrypt_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_encrypt_CallInstance, cmock_guts_index);
  Mock.psa_aead_encrypt_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_aead_encrypt(cmock_call_instance, key, alg, nonce, nonce_length, additional_data, additional_data_length, plaintext, plaintext_length, ciphertext, ciphertext_size, ciphertext_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_aead_encrypt_AddCallback(CMOCK_psa_aead_encrypt_CALLBACK Callback)
{
  Mock.psa_aead_encrypt_IgnoreBool = (char)0;
  Mock.psa_aead_encrypt_CallbackBool = (char)1;
  Mock.psa_aead_encrypt_CallbackFunctionPointer = Callback;
}

void psa_aead_encrypt_Stub(CMOCK_psa_aead_encrypt_CALLBACK Callback)
{
  Mock.psa_aead_encrypt_IgnoreBool = (char)0;
  Mock.psa_aead_encrypt_CallbackBool = (char)0;
  Mock.psa_aead_encrypt_CallbackFunctionPointer = Callback;
}

psa_status_t psa_aead_decrypt(psa_key_id_t key, psa_algorithm_t alg, const uint8_t* nonce, size_t nonce_length, const uint8_t* additional_data, size_t additional_data_length, const uint8_t* ciphertext, size_t ciphertext_length, uint8_t* plaintext, size_t plaintext_size, size_t* plaintext_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_decrypt_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_decrypt);
  cmock_call_instance = (CMOCK_psa_aead_decrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_decrypt_CallInstance);
  Mock.psa_aead_decrypt_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_decrypt_CallInstance);
  if (Mock.psa_aead_decrypt_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_aead_decrypt_FinalReturn;
    memcpy((void*)(&Mock.psa_aead_decrypt_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_aead_decrypt_CallbackBool &&
      Mock.psa_aead_decrypt_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_aead_decrypt_CallbackFunctionPointer(key, alg, nonce, nonce_length, additional_data, additional_data_length, ciphertext, ciphertext_length, plaintext, plaintext_size, plaintext_length, Mock.psa_aead_decrypt_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt,CMockString_nonce);
    if (cmock_call_instance->Expected_nonce == NULL)
      { UNITY_TEST_ASSERT_NULL(nonce, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_nonce, nonce, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt,CMockString_nonce_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_nonce_length), (void*)(&nonce_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt,CMockString_additional_data);
    if (cmock_call_instance->Expected_additional_data == NULL)
      { UNITY_TEST_ASSERT_NULL(additional_data, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_additional_data, additional_data, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt,CMockString_additional_data_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_additional_data_length), (void*)(&additional_data_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt,CMockString_ciphertext);
    if (cmock_call_instance->Expected_ciphertext == NULL)
      { UNITY_TEST_ASSERT_NULL(ciphertext, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_ciphertext, ciphertext, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt,CMockString_ciphertext_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ciphertext_length), (void*)(&ciphertext_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt,CMockString_plaintext);
    if (cmock_call_instance->Expected_plaintext == NULL)
      { UNITY_TEST_ASSERT_NULL(plaintext, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_plaintext, plaintext, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt,CMockString_plaintext_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_plaintext_size), (void*)(&plaintext_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt,CMockString_plaintext_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_plaintext_length), (void*)(plaintext_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_aead_decrypt_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_aead_decrypt_CallbackFunctionPointer(key, alg, nonce, nonce_length, additional_data, additional_data_length, ciphertext, ciphertext_length, plaintext, plaintext_size, plaintext_length, Mock.psa_aead_decrypt_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_aead_decrypt(CMOCK_psa_aead_decrypt_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* nonce, size_t nonce_length, const uint8_t* additional_data, size_t additional_data_length, const uint8_t* ciphertext, size_t ciphertext_length, uint8_t* plaintext, size_t plaintext_size, size_t* plaintext_length);
void CMockExpectParameters_psa_aead_decrypt(CMOCK_psa_aead_decrypt_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* nonce, size_t nonce_length, const uint8_t* additional_data, size_t additional_data_length, const uint8_t* ciphertext, size_t ciphertext_length, uint8_t* plaintext, size_t plaintext_size, size_t* plaintext_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_nonce = nonce;
  memcpy((void*)(&cmock_call_instance->Expected_nonce_length), (void*)(&nonce_length),
         sizeof(size_t[sizeof(nonce_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_additional_data = additional_data;
  memcpy((void*)(&cmock_call_instance->Expected_additional_data_length), (void*)(&additional_data_length),
         sizeof(size_t[sizeof(additional_data_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_ciphertext = ciphertext;
  memcpy((void*)(&cmock_call_instance->Expected_ciphertext_length), (void*)(&ciphertext_length),
         sizeof(size_t[sizeof(ciphertext_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_plaintext = plaintext;
  memcpy((void*)(&cmock_call_instance->Expected_plaintext_size), (void*)(&plaintext_size),
         sizeof(size_t[sizeof(plaintext_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_plaintext_length = plaintext_length;
}

void psa_aead_decrypt_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_decrypt_CALL_INSTANCE));
  CMOCK_psa_aead_decrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_decrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_decrypt_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_decrypt_CallInstance, cmock_guts_index);
  Mock.psa_aead_decrypt_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_aead_decrypt_IgnoreBool = (char)1;
}

void psa_aead_decrypt_CMockStopIgnore(void)
{
  if(Mock.psa_aead_decrypt_IgnoreBool)
    Mock.psa_aead_decrypt_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_decrypt_CallInstance);
  Mock.psa_aead_decrypt_IgnoreBool = (char)0;
}

void psa_aead_decrypt_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* nonce, size_t nonce_length, const uint8_t* additional_data, size_t additional_data_length, const uint8_t* ciphertext, size_t ciphertext_length, uint8_t* plaintext, size_t plaintext_size, size_t* plaintext_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_decrypt_CALL_INSTANCE));
  CMOCK_psa_aead_decrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_decrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_decrypt_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_decrypt_CallInstance, cmock_guts_index);
  Mock.psa_aead_decrypt_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_aead_decrypt(cmock_call_instance, key, alg, nonce, nonce_length, additional_data, additional_data_length, ciphertext, ciphertext_length, plaintext, plaintext_size, plaintext_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_aead_decrypt_AddCallback(CMOCK_psa_aead_decrypt_CALLBACK Callback)
{
  Mock.psa_aead_decrypt_IgnoreBool = (char)0;
  Mock.psa_aead_decrypt_CallbackBool = (char)1;
  Mock.psa_aead_decrypt_CallbackFunctionPointer = Callback;
}

void psa_aead_decrypt_Stub(CMOCK_psa_aead_decrypt_CALLBACK Callback)
{
  Mock.psa_aead_decrypt_IgnoreBool = (char)0;
  Mock.psa_aead_decrypt_CallbackBool = (char)0;
  Mock.psa_aead_decrypt_CallbackFunctionPointer = Callback;
}

psa_aead_operation_t psa_aead_operation_init(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_operation_init_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_operation_init);
  cmock_call_instance = (CMOCK_psa_aead_operation_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_operation_init_CallInstance);
  Mock.psa_aead_operation_init_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_operation_init_CallInstance);
  if (Mock.psa_aead_operation_init_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_aead_operation_init_FinalReturn;
    memcpy((void*)(&Mock.psa_aead_operation_init_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_aead_operation_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_aead_operation_t) ? 1 : -1])); /* add psa_aead_operation_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_aead_operation_init_CallbackBool &&
      Mock.psa_aead_operation_init_CallbackFunctionPointer != NULL)
  {
    psa_aead_operation_t cmock_cb_ret = Mock.psa_aead_operation_init_CallbackFunctionPointer(Mock.psa_aead_operation_init_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.psa_aead_operation_init_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_aead_operation_init_CallbackFunctionPointer(Mock.psa_aead_operation_init_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void psa_aead_operation_init_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_aead_operation_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_operation_init_CALL_INSTANCE));
  CMOCK_psa_aead_operation_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_operation_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_operation_init_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_operation_init_CallInstance, cmock_guts_index);
  Mock.psa_aead_operation_init_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_aead_operation_init_IgnoreBool = (char)1;
}

void psa_aead_operation_init_CMockStopIgnore(void)
{
  if(Mock.psa_aead_operation_init_IgnoreBool)
    Mock.psa_aead_operation_init_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_operation_init_CallInstance);
  Mock.psa_aead_operation_init_IgnoreBool = (char)0;
}

void psa_aead_operation_init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_aead_operation_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_operation_init_CALL_INSTANCE));
  CMOCK_psa_aead_operation_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_operation_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_operation_init_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_operation_init_CallInstance, cmock_guts_index);
  Mock.psa_aead_operation_init_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_aead_operation_t[sizeof(cmock_to_return) == sizeof(psa_aead_operation_t) ? 1 : -1])); /* add psa_aead_operation_t to :treat_as_array if this causes an error */
}

void psa_aead_operation_init_AddCallback(CMOCK_psa_aead_operation_init_CALLBACK Callback)
{
  Mock.psa_aead_operation_init_IgnoreBool = (char)0;
  Mock.psa_aead_operation_init_CallbackBool = (char)1;
  Mock.psa_aead_operation_init_CallbackFunctionPointer = Callback;
}

void psa_aead_operation_init_Stub(CMOCK_psa_aead_operation_init_CALLBACK Callback)
{
  Mock.psa_aead_operation_init_IgnoreBool = (char)0;
  Mock.psa_aead_operation_init_CallbackBool = (char)0;
  Mock.psa_aead_operation_init_CallbackFunctionPointer = Callback;
}

psa_status_t psa_aead_encrypt_setup(psa_aead_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_encrypt_setup_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_encrypt_setup);
  cmock_call_instance = (CMOCK_psa_aead_encrypt_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_encrypt_setup_CallInstance);
  Mock.psa_aead_encrypt_setup_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_encrypt_setup_CallInstance);
  if (Mock.psa_aead_encrypt_setup_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_aead_encrypt_setup_FinalReturn;
    memcpy((void*)(&Mock.psa_aead_encrypt_setup_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_aead_encrypt_setup_CallbackBool &&
      Mock.psa_aead_encrypt_setup_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_aead_encrypt_setup_CallbackFunctionPointer(operation, key, alg, Mock.psa_aead_encrypt_setup_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt_setup,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_aead_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt_setup,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_encrypt_setup,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_aead_encrypt_setup_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_aead_encrypt_setup_CallbackFunctionPointer(operation, key, alg, Mock.psa_aead_encrypt_setup_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_aead_encrypt_setup(CMOCK_psa_aead_encrypt_setup_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg);
void CMockExpectParameters_psa_aead_encrypt_setup(CMOCK_psa_aead_encrypt_setup_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
}

void psa_aead_encrypt_setup_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_encrypt_setup_CALL_INSTANCE));
  CMOCK_psa_aead_encrypt_setup_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_encrypt_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_encrypt_setup_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_encrypt_setup_CallInstance, cmock_guts_index);
  Mock.psa_aead_encrypt_setup_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_aead_encrypt_setup_IgnoreBool = (char)1;
}

void psa_aead_encrypt_setup_CMockStopIgnore(void)
{
  if(Mock.psa_aead_encrypt_setup_IgnoreBool)
    Mock.psa_aead_encrypt_setup_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_encrypt_setup_CallInstance);
  Mock.psa_aead_encrypt_setup_IgnoreBool = (char)0;
}

void psa_aead_encrypt_setup_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_aead_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_encrypt_setup_CALL_INSTANCE));
  CMOCK_psa_aead_encrypt_setup_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_encrypt_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_encrypt_setup_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_encrypt_setup_CallInstance, cmock_guts_index);
  Mock.psa_aead_encrypt_setup_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_aead_encrypt_setup(cmock_call_instance, operation, key, alg);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_aead_encrypt_setup_AddCallback(CMOCK_psa_aead_encrypt_setup_CALLBACK Callback)
{
  Mock.psa_aead_encrypt_setup_IgnoreBool = (char)0;
  Mock.psa_aead_encrypt_setup_CallbackBool = (char)1;
  Mock.psa_aead_encrypt_setup_CallbackFunctionPointer = Callback;
}

void psa_aead_encrypt_setup_Stub(CMOCK_psa_aead_encrypt_setup_CALLBACK Callback)
{
  Mock.psa_aead_encrypt_setup_IgnoreBool = (char)0;
  Mock.psa_aead_encrypt_setup_CallbackBool = (char)0;
  Mock.psa_aead_encrypt_setup_CallbackFunctionPointer = Callback;
}

psa_status_t psa_aead_decrypt_setup(psa_aead_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_decrypt_setup_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_decrypt_setup);
  cmock_call_instance = (CMOCK_psa_aead_decrypt_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_decrypt_setup_CallInstance);
  Mock.psa_aead_decrypt_setup_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_decrypt_setup_CallInstance);
  if (Mock.psa_aead_decrypt_setup_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_aead_decrypt_setup_FinalReturn;
    memcpy((void*)(&Mock.psa_aead_decrypt_setup_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_aead_decrypt_setup_CallbackBool &&
      Mock.psa_aead_decrypt_setup_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_aead_decrypt_setup_CallbackFunctionPointer(operation, key, alg, Mock.psa_aead_decrypt_setup_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt_setup,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_aead_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt_setup,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_decrypt_setup,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_aead_decrypt_setup_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_aead_decrypt_setup_CallbackFunctionPointer(operation, key, alg, Mock.psa_aead_decrypt_setup_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_aead_decrypt_setup(CMOCK_psa_aead_decrypt_setup_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg);
void CMockExpectParameters_psa_aead_decrypt_setup(CMOCK_psa_aead_decrypt_setup_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
}

void psa_aead_decrypt_setup_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_decrypt_setup_CALL_INSTANCE));
  CMOCK_psa_aead_decrypt_setup_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_decrypt_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_decrypt_setup_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_decrypt_setup_CallInstance, cmock_guts_index);
  Mock.psa_aead_decrypt_setup_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_aead_decrypt_setup_IgnoreBool = (char)1;
}

void psa_aead_decrypt_setup_CMockStopIgnore(void)
{
  if(Mock.psa_aead_decrypt_setup_IgnoreBool)
    Mock.psa_aead_decrypt_setup_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_decrypt_setup_CallInstance);
  Mock.psa_aead_decrypt_setup_IgnoreBool = (char)0;
}

void psa_aead_decrypt_setup_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_aead_operation_t* operation, psa_key_id_t key, psa_algorithm_t alg, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_decrypt_setup_CALL_INSTANCE));
  CMOCK_psa_aead_decrypt_setup_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_decrypt_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_decrypt_setup_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_decrypt_setup_CallInstance, cmock_guts_index);
  Mock.psa_aead_decrypt_setup_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_aead_decrypt_setup(cmock_call_instance, operation, key, alg);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_aead_decrypt_setup_AddCallback(CMOCK_psa_aead_decrypt_setup_CALLBACK Callback)
{
  Mock.psa_aead_decrypt_setup_IgnoreBool = (char)0;
  Mock.psa_aead_decrypt_setup_CallbackBool = (char)1;
  Mock.psa_aead_decrypt_setup_CallbackFunctionPointer = Callback;
}

void psa_aead_decrypt_setup_Stub(CMOCK_psa_aead_decrypt_setup_CALLBACK Callback)
{
  Mock.psa_aead_decrypt_setup_IgnoreBool = (char)0;
  Mock.psa_aead_decrypt_setup_CallbackBool = (char)0;
  Mock.psa_aead_decrypt_setup_CallbackFunctionPointer = Callback;
}

psa_status_t psa_aead_generate_nonce(psa_aead_operation_t* operation, uint8_t* nonce, size_t nonce_size, size_t* nonce_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_generate_nonce_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_generate_nonce);
  cmock_call_instance = (CMOCK_psa_aead_generate_nonce_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_generate_nonce_CallInstance);
  Mock.psa_aead_generate_nonce_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_generate_nonce_CallInstance);
  if (Mock.psa_aead_generate_nonce_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_aead_generate_nonce_FinalReturn;
    memcpy((void*)(&Mock.psa_aead_generate_nonce_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_aead_generate_nonce_CallbackBool &&
      Mock.psa_aead_generate_nonce_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_aead_generate_nonce_CallbackFunctionPointer(operation, nonce, nonce_size, nonce_length, Mock.psa_aead_generate_nonce_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_generate_nonce,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_aead_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_generate_nonce,CMockString_nonce);
    if (cmock_call_instance->Expected_nonce == NULL)
      { UNITY_TEST_ASSERT_NULL(nonce, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_nonce, nonce, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_generate_nonce,CMockString_nonce_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_nonce_size), (void*)(&nonce_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_generate_nonce,CMockString_nonce_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_nonce_length), (void*)(nonce_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_aead_generate_nonce_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_aead_generate_nonce_CallbackFunctionPointer(operation, nonce, nonce_size, nonce_length, Mock.psa_aead_generate_nonce_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_aead_generate_nonce(CMOCK_psa_aead_generate_nonce_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, uint8_t* nonce, size_t nonce_size, size_t* nonce_length);
void CMockExpectParameters_psa_aead_generate_nonce(CMOCK_psa_aead_generate_nonce_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, uint8_t* nonce, size_t nonce_size, size_t* nonce_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_nonce = nonce;
  memcpy((void*)(&cmock_call_instance->Expected_nonce_size), (void*)(&nonce_size),
         sizeof(size_t[sizeof(nonce_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_nonce_length = nonce_length;
}

void psa_aead_generate_nonce_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_generate_nonce_CALL_INSTANCE));
  CMOCK_psa_aead_generate_nonce_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_generate_nonce_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_generate_nonce_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_generate_nonce_CallInstance, cmock_guts_index);
  Mock.psa_aead_generate_nonce_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_aead_generate_nonce_IgnoreBool = (char)1;
}

void psa_aead_generate_nonce_CMockStopIgnore(void)
{
  if(Mock.psa_aead_generate_nonce_IgnoreBool)
    Mock.psa_aead_generate_nonce_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_generate_nonce_CallInstance);
  Mock.psa_aead_generate_nonce_IgnoreBool = (char)0;
}

void psa_aead_generate_nonce_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_aead_operation_t* operation, uint8_t* nonce, size_t nonce_size, size_t* nonce_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_generate_nonce_CALL_INSTANCE));
  CMOCK_psa_aead_generate_nonce_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_generate_nonce_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_generate_nonce_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_generate_nonce_CallInstance, cmock_guts_index);
  Mock.psa_aead_generate_nonce_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_aead_generate_nonce(cmock_call_instance, operation, nonce, nonce_size, nonce_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_aead_generate_nonce_AddCallback(CMOCK_psa_aead_generate_nonce_CALLBACK Callback)
{
  Mock.psa_aead_generate_nonce_IgnoreBool = (char)0;
  Mock.psa_aead_generate_nonce_CallbackBool = (char)1;
  Mock.psa_aead_generate_nonce_CallbackFunctionPointer = Callback;
}

void psa_aead_generate_nonce_Stub(CMOCK_psa_aead_generate_nonce_CALLBACK Callback)
{
  Mock.psa_aead_generate_nonce_IgnoreBool = (char)0;
  Mock.psa_aead_generate_nonce_CallbackBool = (char)0;
  Mock.psa_aead_generate_nonce_CallbackFunctionPointer = Callback;
}

psa_status_t psa_aead_set_nonce(psa_aead_operation_t* operation, const uint8_t* nonce, size_t nonce_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_set_nonce_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_set_nonce);
  cmock_call_instance = (CMOCK_psa_aead_set_nonce_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_set_nonce_CallInstance);
  Mock.psa_aead_set_nonce_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_set_nonce_CallInstance);
  if (Mock.psa_aead_set_nonce_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_aead_set_nonce_FinalReturn;
    memcpy((void*)(&Mock.psa_aead_set_nonce_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_aead_set_nonce_CallbackBool &&
      Mock.psa_aead_set_nonce_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_aead_set_nonce_CallbackFunctionPointer(operation, nonce, nonce_length, Mock.psa_aead_set_nonce_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_set_nonce,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_aead_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_set_nonce,CMockString_nonce);
    if (cmock_call_instance->Expected_nonce == NULL)
      { UNITY_TEST_ASSERT_NULL(nonce, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_nonce, nonce, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_set_nonce,CMockString_nonce_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_nonce_length), (void*)(&nonce_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_aead_set_nonce_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_aead_set_nonce_CallbackFunctionPointer(operation, nonce, nonce_length, Mock.psa_aead_set_nonce_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_aead_set_nonce(CMOCK_psa_aead_set_nonce_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, const uint8_t* nonce, size_t nonce_length);
void CMockExpectParameters_psa_aead_set_nonce(CMOCK_psa_aead_set_nonce_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, const uint8_t* nonce, size_t nonce_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_nonce = nonce;
  memcpy((void*)(&cmock_call_instance->Expected_nonce_length), (void*)(&nonce_length),
         sizeof(size_t[sizeof(nonce_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_aead_set_nonce_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_set_nonce_CALL_INSTANCE));
  CMOCK_psa_aead_set_nonce_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_set_nonce_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_set_nonce_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_set_nonce_CallInstance, cmock_guts_index);
  Mock.psa_aead_set_nonce_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_aead_set_nonce_IgnoreBool = (char)1;
}

void psa_aead_set_nonce_CMockStopIgnore(void)
{
  if(Mock.psa_aead_set_nonce_IgnoreBool)
    Mock.psa_aead_set_nonce_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_set_nonce_CallInstance);
  Mock.psa_aead_set_nonce_IgnoreBool = (char)0;
}

void psa_aead_set_nonce_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_aead_operation_t* operation, const uint8_t* nonce, size_t nonce_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_set_nonce_CALL_INSTANCE));
  CMOCK_psa_aead_set_nonce_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_set_nonce_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_set_nonce_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_set_nonce_CallInstance, cmock_guts_index);
  Mock.psa_aead_set_nonce_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_aead_set_nonce(cmock_call_instance, operation, nonce, nonce_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_aead_set_nonce_AddCallback(CMOCK_psa_aead_set_nonce_CALLBACK Callback)
{
  Mock.psa_aead_set_nonce_IgnoreBool = (char)0;
  Mock.psa_aead_set_nonce_CallbackBool = (char)1;
  Mock.psa_aead_set_nonce_CallbackFunctionPointer = Callback;
}

void psa_aead_set_nonce_Stub(CMOCK_psa_aead_set_nonce_CALLBACK Callback)
{
  Mock.psa_aead_set_nonce_IgnoreBool = (char)0;
  Mock.psa_aead_set_nonce_CallbackBool = (char)0;
  Mock.psa_aead_set_nonce_CallbackFunctionPointer = Callback;
}

psa_status_t psa_aead_set_lengths(psa_aead_operation_t* operation, size_t ad_length, size_t plaintext_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_set_lengths_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_set_lengths);
  cmock_call_instance = (CMOCK_psa_aead_set_lengths_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_set_lengths_CallInstance);
  Mock.psa_aead_set_lengths_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_set_lengths_CallInstance);
  if (Mock.psa_aead_set_lengths_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_aead_set_lengths_FinalReturn;
    memcpy((void*)(&Mock.psa_aead_set_lengths_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_aead_set_lengths_CallbackBool &&
      Mock.psa_aead_set_lengths_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_aead_set_lengths_CallbackFunctionPointer(operation, ad_length, plaintext_length, Mock.psa_aead_set_lengths_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_set_lengths,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_aead_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_set_lengths,CMockString_ad_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ad_length), (void*)(&ad_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_set_lengths,CMockString_plaintext_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_plaintext_length), (void*)(&plaintext_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_aead_set_lengths_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_aead_set_lengths_CallbackFunctionPointer(operation, ad_length, plaintext_length, Mock.psa_aead_set_lengths_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_aead_set_lengths(CMOCK_psa_aead_set_lengths_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, size_t ad_length, size_t plaintext_length);
void CMockExpectParameters_psa_aead_set_lengths(CMOCK_psa_aead_set_lengths_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, size_t ad_length, size_t plaintext_length)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_ad_length), (void*)(&ad_length),
         sizeof(size_t[sizeof(ad_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_plaintext_length), (void*)(&plaintext_length),
         sizeof(size_t[sizeof(plaintext_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_aead_set_lengths_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_set_lengths_CALL_INSTANCE));
  CMOCK_psa_aead_set_lengths_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_set_lengths_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_set_lengths_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_set_lengths_CallInstance, cmock_guts_index);
  Mock.psa_aead_set_lengths_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_aead_set_lengths_IgnoreBool = (char)1;
}

void psa_aead_set_lengths_CMockStopIgnore(void)
{
  if(Mock.psa_aead_set_lengths_IgnoreBool)
    Mock.psa_aead_set_lengths_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_set_lengths_CallInstance);
  Mock.psa_aead_set_lengths_IgnoreBool = (char)0;
}

void psa_aead_set_lengths_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_aead_operation_t* operation, size_t ad_length, size_t plaintext_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_set_lengths_CALL_INSTANCE));
  CMOCK_psa_aead_set_lengths_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_set_lengths_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_set_lengths_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_set_lengths_CallInstance, cmock_guts_index);
  Mock.psa_aead_set_lengths_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_aead_set_lengths(cmock_call_instance, operation, ad_length, plaintext_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_aead_set_lengths_AddCallback(CMOCK_psa_aead_set_lengths_CALLBACK Callback)
{
  Mock.psa_aead_set_lengths_IgnoreBool = (char)0;
  Mock.psa_aead_set_lengths_CallbackBool = (char)1;
  Mock.psa_aead_set_lengths_CallbackFunctionPointer = Callback;
}

void psa_aead_set_lengths_Stub(CMOCK_psa_aead_set_lengths_CALLBACK Callback)
{
  Mock.psa_aead_set_lengths_IgnoreBool = (char)0;
  Mock.psa_aead_set_lengths_CallbackBool = (char)0;
  Mock.psa_aead_set_lengths_CallbackFunctionPointer = Callback;
}

psa_status_t psa_aead_update_ad(psa_aead_operation_t* operation, const uint8_t* input, size_t input_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_update_ad_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_update_ad);
  cmock_call_instance = (CMOCK_psa_aead_update_ad_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_update_ad_CallInstance);
  Mock.psa_aead_update_ad_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_update_ad_CallInstance);
  if (Mock.psa_aead_update_ad_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_aead_update_ad_FinalReturn;
    memcpy((void*)(&Mock.psa_aead_update_ad_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_aead_update_ad_CallbackBool &&
      Mock.psa_aead_update_ad_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_aead_update_ad_CallbackFunctionPointer(operation, input, input_length, Mock.psa_aead_update_ad_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_update_ad,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_aead_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_update_ad,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_update_ad,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_aead_update_ad_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_aead_update_ad_CallbackFunctionPointer(operation, input, input_length, Mock.psa_aead_update_ad_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_aead_update_ad(CMOCK_psa_aead_update_ad_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, const uint8_t* input, size_t input_length);
void CMockExpectParameters_psa_aead_update_ad(CMOCK_psa_aead_update_ad_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, const uint8_t* input, size_t input_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_aead_update_ad_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_update_ad_CALL_INSTANCE));
  CMOCK_psa_aead_update_ad_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_update_ad_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_update_ad_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_update_ad_CallInstance, cmock_guts_index);
  Mock.psa_aead_update_ad_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_aead_update_ad_IgnoreBool = (char)1;
}

void psa_aead_update_ad_CMockStopIgnore(void)
{
  if(Mock.psa_aead_update_ad_IgnoreBool)
    Mock.psa_aead_update_ad_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_update_ad_CallInstance);
  Mock.psa_aead_update_ad_IgnoreBool = (char)0;
}

void psa_aead_update_ad_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_aead_operation_t* operation, const uint8_t* input, size_t input_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_update_ad_CALL_INSTANCE));
  CMOCK_psa_aead_update_ad_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_update_ad_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_update_ad_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_update_ad_CallInstance, cmock_guts_index);
  Mock.psa_aead_update_ad_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_aead_update_ad(cmock_call_instance, operation, input, input_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_aead_update_ad_AddCallback(CMOCK_psa_aead_update_ad_CALLBACK Callback)
{
  Mock.psa_aead_update_ad_IgnoreBool = (char)0;
  Mock.psa_aead_update_ad_CallbackBool = (char)1;
  Mock.psa_aead_update_ad_CallbackFunctionPointer = Callback;
}

void psa_aead_update_ad_Stub(CMOCK_psa_aead_update_ad_CALLBACK Callback)
{
  Mock.psa_aead_update_ad_IgnoreBool = (char)0;
  Mock.psa_aead_update_ad_CallbackBool = (char)0;
  Mock.psa_aead_update_ad_CallbackFunctionPointer = Callback;
}

psa_status_t psa_aead_update(psa_aead_operation_t* operation, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_update_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_update);
  cmock_call_instance = (CMOCK_psa_aead_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_update_CallInstance);
  Mock.psa_aead_update_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_update_CallInstance);
  if (Mock.psa_aead_update_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_aead_update_FinalReturn;
    memcpy((void*)(&Mock.psa_aead_update_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_aead_update_CallbackBool &&
      Mock.psa_aead_update_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_aead_update_CallbackFunctionPointer(operation, input, input_length, output, output_size, output_length, Mock.psa_aead_update_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_update,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_aead_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_update,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_update,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_update,CMockString_output);
    if (cmock_call_instance->Expected_output == NULL)
      { UNITY_TEST_ASSERT_NULL(output, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_output, output, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_update,CMockString_output_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_update,CMockString_output_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_output_length), (void*)(output_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_aead_update_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_aead_update_CallbackFunctionPointer(operation, input, input_length, output, output_size, output_length, Mock.psa_aead_update_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_aead_update(CMOCK_psa_aead_update_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length);
void CMockExpectParameters_psa_aead_update(CMOCK_psa_aead_update_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output = output;
  memcpy((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size),
         sizeof(size_t[sizeof(output_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output_length = output_length;
}

void psa_aead_update_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_update_CALL_INSTANCE));
  CMOCK_psa_aead_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_update_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_update_CallInstance, cmock_guts_index);
  Mock.psa_aead_update_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_aead_update_IgnoreBool = (char)1;
}

void psa_aead_update_CMockStopIgnore(void)
{
  if(Mock.psa_aead_update_IgnoreBool)
    Mock.psa_aead_update_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_update_CallInstance);
  Mock.psa_aead_update_IgnoreBool = (char)0;
}

void psa_aead_update_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_aead_operation_t* operation, const uint8_t* input, size_t input_length, uint8_t* output, size_t output_size, size_t* output_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_update_CALL_INSTANCE));
  CMOCK_psa_aead_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_update_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_update_CallInstance, cmock_guts_index);
  Mock.psa_aead_update_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_aead_update(cmock_call_instance, operation, input, input_length, output, output_size, output_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_aead_update_AddCallback(CMOCK_psa_aead_update_CALLBACK Callback)
{
  Mock.psa_aead_update_IgnoreBool = (char)0;
  Mock.psa_aead_update_CallbackBool = (char)1;
  Mock.psa_aead_update_CallbackFunctionPointer = Callback;
}

void psa_aead_update_Stub(CMOCK_psa_aead_update_CALLBACK Callback)
{
  Mock.psa_aead_update_IgnoreBool = (char)0;
  Mock.psa_aead_update_CallbackBool = (char)0;
  Mock.psa_aead_update_CallbackFunctionPointer = Callback;
}

psa_status_t psa_aead_finish(psa_aead_operation_t* operation, uint8_t* ciphertext, size_t ciphertext_size, size_t* ciphertext_length, uint8_t* tag, size_t tag_size, size_t* tag_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_finish_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_finish);
  cmock_call_instance = (CMOCK_psa_aead_finish_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_finish_CallInstance);
  Mock.psa_aead_finish_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_finish_CallInstance);
  if (Mock.psa_aead_finish_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_aead_finish_FinalReturn;
    memcpy((void*)(&Mock.psa_aead_finish_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_aead_finish_CallbackBool &&
      Mock.psa_aead_finish_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_aead_finish_CallbackFunctionPointer(operation, ciphertext, ciphertext_size, ciphertext_length, tag, tag_size, tag_length, Mock.psa_aead_finish_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_finish,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_aead_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_finish,CMockString_ciphertext);
    if (cmock_call_instance->Expected_ciphertext == NULL)
      { UNITY_TEST_ASSERT_NULL(ciphertext, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_ciphertext, ciphertext, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_finish,CMockString_ciphertext_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ciphertext_size), (void*)(&ciphertext_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_finish,CMockString_ciphertext_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_ciphertext_length), (void*)(ciphertext_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_finish,CMockString_tag);
    if (cmock_call_instance->Expected_tag == NULL)
      { UNITY_TEST_ASSERT_NULL(tag, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_tag, tag, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_finish,CMockString_tag_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_tag_size), (void*)(&tag_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_finish,CMockString_tag_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_tag_length), (void*)(tag_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_aead_finish_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_aead_finish_CallbackFunctionPointer(operation, ciphertext, ciphertext_size, ciphertext_length, tag, tag_size, tag_length, Mock.psa_aead_finish_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_aead_finish(CMOCK_psa_aead_finish_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, uint8_t* ciphertext, size_t ciphertext_size, size_t* ciphertext_length, uint8_t* tag, size_t tag_size, size_t* tag_length);
void CMockExpectParameters_psa_aead_finish(CMOCK_psa_aead_finish_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, uint8_t* ciphertext, size_t ciphertext_size, size_t* ciphertext_length, uint8_t* tag, size_t tag_size, size_t* tag_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_ciphertext = ciphertext;
  memcpy((void*)(&cmock_call_instance->Expected_ciphertext_size), (void*)(&ciphertext_size),
         sizeof(size_t[sizeof(ciphertext_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_ciphertext_length = ciphertext_length;
  cmock_call_instance->Expected_tag = tag;
  memcpy((void*)(&cmock_call_instance->Expected_tag_size), (void*)(&tag_size),
         sizeof(size_t[sizeof(tag_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_tag_length = tag_length;
}

void psa_aead_finish_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_finish_CALL_INSTANCE));
  CMOCK_psa_aead_finish_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_finish_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_finish_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_finish_CallInstance, cmock_guts_index);
  Mock.psa_aead_finish_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_aead_finish_IgnoreBool = (char)1;
}

void psa_aead_finish_CMockStopIgnore(void)
{
  if(Mock.psa_aead_finish_IgnoreBool)
    Mock.psa_aead_finish_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_finish_CallInstance);
  Mock.psa_aead_finish_IgnoreBool = (char)0;
}

void psa_aead_finish_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_aead_operation_t* operation, uint8_t* ciphertext, size_t ciphertext_size, size_t* ciphertext_length, uint8_t* tag, size_t tag_size, size_t* tag_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_finish_CALL_INSTANCE));
  CMOCK_psa_aead_finish_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_finish_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_finish_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_finish_CallInstance, cmock_guts_index);
  Mock.psa_aead_finish_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_aead_finish(cmock_call_instance, operation, ciphertext, ciphertext_size, ciphertext_length, tag, tag_size, tag_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_aead_finish_AddCallback(CMOCK_psa_aead_finish_CALLBACK Callback)
{
  Mock.psa_aead_finish_IgnoreBool = (char)0;
  Mock.psa_aead_finish_CallbackBool = (char)1;
  Mock.psa_aead_finish_CallbackFunctionPointer = Callback;
}

void psa_aead_finish_Stub(CMOCK_psa_aead_finish_CALLBACK Callback)
{
  Mock.psa_aead_finish_IgnoreBool = (char)0;
  Mock.psa_aead_finish_CallbackBool = (char)0;
  Mock.psa_aead_finish_CallbackFunctionPointer = Callback;
}

psa_status_t psa_aead_verify(psa_aead_operation_t* operation, uint8_t* plaintext, size_t plaintext_size, size_t* plaintext_length, const uint8_t* tag, size_t tag_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_verify_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_verify);
  cmock_call_instance = (CMOCK_psa_aead_verify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_verify_CallInstance);
  Mock.psa_aead_verify_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_verify_CallInstance);
  if (Mock.psa_aead_verify_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_aead_verify_FinalReturn;
    memcpy((void*)(&Mock.psa_aead_verify_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_aead_verify_CallbackBool &&
      Mock.psa_aead_verify_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_aead_verify_CallbackFunctionPointer(operation, plaintext, plaintext_size, plaintext_length, tag, tag_length, Mock.psa_aead_verify_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_verify,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_aead_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_verify,CMockString_plaintext);
    if (cmock_call_instance->Expected_plaintext == NULL)
      { UNITY_TEST_ASSERT_NULL(plaintext, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_plaintext, plaintext, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_verify,CMockString_plaintext_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_plaintext_size), (void*)(&plaintext_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_verify,CMockString_plaintext_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_plaintext_length), (void*)(plaintext_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_verify,CMockString_tag);
    if (cmock_call_instance->Expected_tag == NULL)
      { UNITY_TEST_ASSERT_NULL(tag, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_tag, tag, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_verify,CMockString_tag_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_tag_length), (void*)(&tag_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_aead_verify_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_aead_verify_CallbackFunctionPointer(operation, plaintext, plaintext_size, plaintext_length, tag, tag_length, Mock.psa_aead_verify_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_aead_verify(CMOCK_psa_aead_verify_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, uint8_t* plaintext, size_t plaintext_size, size_t* plaintext_length, const uint8_t* tag, size_t tag_length);
void CMockExpectParameters_psa_aead_verify(CMOCK_psa_aead_verify_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation, uint8_t* plaintext, size_t plaintext_size, size_t* plaintext_length, const uint8_t* tag, size_t tag_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_plaintext = plaintext;
  memcpy((void*)(&cmock_call_instance->Expected_plaintext_size), (void*)(&plaintext_size),
         sizeof(size_t[sizeof(plaintext_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_plaintext_length = plaintext_length;
  cmock_call_instance->Expected_tag = tag;
  memcpy((void*)(&cmock_call_instance->Expected_tag_length), (void*)(&tag_length),
         sizeof(size_t[sizeof(tag_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_aead_verify_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_verify_CALL_INSTANCE));
  CMOCK_psa_aead_verify_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_verify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_verify_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_verify_CallInstance, cmock_guts_index);
  Mock.psa_aead_verify_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_aead_verify_IgnoreBool = (char)1;
}

void psa_aead_verify_CMockStopIgnore(void)
{
  if(Mock.psa_aead_verify_IgnoreBool)
    Mock.psa_aead_verify_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_verify_CallInstance);
  Mock.psa_aead_verify_IgnoreBool = (char)0;
}

void psa_aead_verify_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_aead_operation_t* operation, uint8_t* plaintext, size_t plaintext_size, size_t* plaintext_length, const uint8_t* tag, size_t tag_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_verify_CALL_INSTANCE));
  CMOCK_psa_aead_verify_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_verify_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_verify_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_verify_CallInstance, cmock_guts_index);
  Mock.psa_aead_verify_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_aead_verify(cmock_call_instance, operation, plaintext, plaintext_size, plaintext_length, tag, tag_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_aead_verify_AddCallback(CMOCK_psa_aead_verify_CALLBACK Callback)
{
  Mock.psa_aead_verify_IgnoreBool = (char)0;
  Mock.psa_aead_verify_CallbackBool = (char)1;
  Mock.psa_aead_verify_CallbackFunctionPointer = Callback;
}

void psa_aead_verify_Stub(CMOCK_psa_aead_verify_CALLBACK Callback)
{
  Mock.psa_aead_verify_IgnoreBool = (char)0;
  Mock.psa_aead_verify_CallbackBool = (char)0;
  Mock.psa_aead_verify_CallbackFunctionPointer = Callback;
}

psa_status_t psa_aead_abort(psa_aead_operation_t* operation)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_aead_abort_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_aead_abort);
  cmock_call_instance = (CMOCK_psa_aead_abort_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_aead_abort_CallInstance);
  Mock.psa_aead_abort_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_abort_CallInstance);
  if (Mock.psa_aead_abort_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_aead_abort_FinalReturn;
    memcpy((void*)(&Mock.psa_aead_abort_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_aead_abort_CallbackBool &&
      Mock.psa_aead_abort_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_aead_abort_CallbackFunctionPointer(operation, Mock.psa_aead_abort_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_aead_abort,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_aead_operation_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_aead_abort_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_aead_abort_CallbackFunctionPointer(operation, Mock.psa_aead_abort_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_aead_abort(CMOCK_psa_aead_abort_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation);
void CMockExpectParameters_psa_aead_abort(CMOCK_psa_aead_abort_CALL_INSTANCE* cmock_call_instance, psa_aead_operation_t* operation)
{
  cmock_call_instance->Expected_operation = operation;
}

void psa_aead_abort_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_abort_CALL_INSTANCE));
  CMOCK_psa_aead_abort_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_abort_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_abort_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_abort_CallInstance, cmock_guts_index);
  Mock.psa_aead_abort_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_aead_abort_IgnoreBool = (char)1;
}

void psa_aead_abort_CMockStopIgnore(void)
{
  if(Mock.psa_aead_abort_IgnoreBool)
    Mock.psa_aead_abort_CallInstance = CMock_Guts_MemNext(Mock.psa_aead_abort_CallInstance);
  Mock.psa_aead_abort_IgnoreBool = (char)0;
}

void psa_aead_abort_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_aead_operation_t* operation, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_aead_abort_CALL_INSTANCE));
  CMOCK_psa_aead_abort_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_aead_abort_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_aead_abort_CallInstance = CMock_Guts_MemChain(Mock.psa_aead_abort_CallInstance, cmock_guts_index);
  Mock.psa_aead_abort_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_aead_abort(cmock_call_instance, operation);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_aead_abort_AddCallback(CMOCK_psa_aead_abort_CALLBACK Callback)
{
  Mock.psa_aead_abort_IgnoreBool = (char)0;
  Mock.psa_aead_abort_CallbackBool = (char)1;
  Mock.psa_aead_abort_CallbackFunctionPointer = Callback;
}

void psa_aead_abort_Stub(CMOCK_psa_aead_abort_CALLBACK Callback)
{
  Mock.psa_aead_abort_IgnoreBool = (char)0;
  Mock.psa_aead_abort_CallbackBool = (char)0;
  Mock.psa_aead_abort_CallbackFunctionPointer = Callback;
}

psa_status_t psa_sign_message(psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* signature, size_t signature_size, size_t* signature_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_sign_message_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_sign_message);
  cmock_call_instance = (CMOCK_psa_sign_message_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_sign_message_CallInstance);
  Mock.psa_sign_message_CallInstance = CMock_Guts_MemNext(Mock.psa_sign_message_CallInstance);
  if (Mock.psa_sign_message_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_sign_message_FinalReturn;
    memcpy((void*)(&Mock.psa_sign_message_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_sign_message_CallbackBool &&
      Mock.psa_sign_message_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_sign_message_CallbackFunctionPointer(key, alg, input, input_length, signature, signature_size, signature_length, Mock.psa_sign_message_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_message,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_message,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_message,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_message,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_message,CMockString_signature);
    if (cmock_call_instance->Expected_signature == NULL)
      { UNITY_TEST_ASSERT_NULL(signature, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_signature, signature, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_message,CMockString_signature_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_signature_size), (void*)(&signature_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_message,CMockString_signature_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_signature_length), (void*)(signature_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_sign_message_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_sign_message_CallbackFunctionPointer(key, alg, input, input_length, signature, signature_size, signature_length, Mock.psa_sign_message_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_sign_message(CMOCK_psa_sign_message_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* signature, size_t signature_size, size_t* signature_length);
void CMockExpectParameters_psa_sign_message(CMOCK_psa_sign_message_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* signature, size_t signature_size, size_t* signature_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_signature = signature;
  memcpy((void*)(&cmock_call_instance->Expected_signature_size), (void*)(&signature_size),
         sizeof(size_t[sizeof(signature_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_signature_length = signature_length;
}

void psa_sign_message_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_sign_message_CALL_INSTANCE));
  CMOCK_psa_sign_message_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_sign_message_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_sign_message_CallInstance = CMock_Guts_MemChain(Mock.psa_sign_message_CallInstance, cmock_guts_index);
  Mock.psa_sign_message_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_sign_message_IgnoreBool = (char)1;
}

void psa_sign_message_CMockStopIgnore(void)
{
  if(Mock.psa_sign_message_IgnoreBool)
    Mock.psa_sign_message_CallInstance = CMock_Guts_MemNext(Mock.psa_sign_message_CallInstance);
  Mock.psa_sign_message_IgnoreBool = (char)0;
}

void psa_sign_message_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, uint8_t* signature, size_t signature_size, size_t* signature_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_sign_message_CALL_INSTANCE));
  CMOCK_psa_sign_message_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_sign_message_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_sign_message_CallInstance = CMock_Guts_MemChain(Mock.psa_sign_message_CallInstance, cmock_guts_index);
  Mock.psa_sign_message_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_sign_message(cmock_call_instance, key, alg, input, input_length, signature, signature_size, signature_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_sign_message_AddCallback(CMOCK_psa_sign_message_CALLBACK Callback)
{
  Mock.psa_sign_message_IgnoreBool = (char)0;
  Mock.psa_sign_message_CallbackBool = (char)1;
  Mock.psa_sign_message_CallbackFunctionPointer = Callback;
}

void psa_sign_message_Stub(CMOCK_psa_sign_message_CALLBACK Callback)
{
  Mock.psa_sign_message_IgnoreBool = (char)0;
  Mock.psa_sign_message_CallbackBool = (char)0;
  Mock.psa_sign_message_CallbackFunctionPointer = Callback;
}

psa_status_t psa_verify_message(psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* signature, size_t signature_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_verify_message_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_verify_message);
  cmock_call_instance = (CMOCK_psa_verify_message_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_verify_message_CallInstance);
  Mock.psa_verify_message_CallInstance = CMock_Guts_MemNext(Mock.psa_verify_message_CallInstance);
  if (Mock.psa_verify_message_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_verify_message_FinalReturn;
    memcpy((void*)(&Mock.psa_verify_message_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_verify_message_CallbackBool &&
      Mock.psa_verify_message_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_verify_message_CallbackFunctionPointer(key, alg, input, input_length, signature, signature_length, Mock.psa_verify_message_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_verify_message,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_verify_message,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_verify_message,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_verify_message,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_verify_message,CMockString_signature);
    if (cmock_call_instance->Expected_signature == NULL)
      { UNITY_TEST_ASSERT_NULL(signature, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_signature, signature, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_verify_message,CMockString_signature_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_signature_length), (void*)(&signature_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_verify_message_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_verify_message_CallbackFunctionPointer(key, alg, input, input_length, signature, signature_length, Mock.psa_verify_message_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_verify_message(CMOCK_psa_verify_message_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* signature, size_t signature_length);
void CMockExpectParameters_psa_verify_message(CMOCK_psa_verify_message_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* signature, size_t signature_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_signature = signature;
  memcpy((void*)(&cmock_call_instance->Expected_signature_length), (void*)(&signature_length),
         sizeof(size_t[sizeof(signature_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_verify_message_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_verify_message_CALL_INSTANCE));
  CMOCK_psa_verify_message_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_verify_message_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_verify_message_CallInstance = CMock_Guts_MemChain(Mock.psa_verify_message_CallInstance, cmock_guts_index);
  Mock.psa_verify_message_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_verify_message_IgnoreBool = (char)1;
}

void psa_verify_message_CMockStopIgnore(void)
{
  if(Mock.psa_verify_message_IgnoreBool)
    Mock.psa_verify_message_CallInstance = CMock_Guts_MemNext(Mock.psa_verify_message_CallInstance);
  Mock.psa_verify_message_IgnoreBool = (char)0;
}

void psa_verify_message_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* signature, size_t signature_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_verify_message_CALL_INSTANCE));
  CMOCK_psa_verify_message_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_verify_message_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_verify_message_CallInstance = CMock_Guts_MemChain(Mock.psa_verify_message_CallInstance, cmock_guts_index);
  Mock.psa_verify_message_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_verify_message(cmock_call_instance, key, alg, input, input_length, signature, signature_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_verify_message_AddCallback(CMOCK_psa_verify_message_CALLBACK Callback)
{
  Mock.psa_verify_message_IgnoreBool = (char)0;
  Mock.psa_verify_message_CallbackBool = (char)1;
  Mock.psa_verify_message_CallbackFunctionPointer = Callback;
}

void psa_verify_message_Stub(CMOCK_psa_verify_message_CALLBACK Callback)
{
  Mock.psa_verify_message_IgnoreBool = (char)0;
  Mock.psa_verify_message_CallbackBool = (char)0;
  Mock.psa_verify_message_CallbackFunctionPointer = Callback;
}

psa_status_t psa_sign_hash(psa_key_id_t key, psa_algorithm_t alg, const uint8_t* hash, size_t hash_length, uint8_t* signature, size_t signature_size, size_t* signature_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_sign_hash_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_sign_hash);
  cmock_call_instance = (CMOCK_psa_sign_hash_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_sign_hash_CallInstance);
  Mock.psa_sign_hash_CallInstance = CMock_Guts_MemNext(Mock.psa_sign_hash_CallInstance);
  if (Mock.psa_sign_hash_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_sign_hash_FinalReturn;
    memcpy((void*)(&Mock.psa_sign_hash_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_sign_hash_CallbackBool &&
      Mock.psa_sign_hash_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_sign_hash_CallbackFunctionPointer(key, alg, hash, hash_length, signature, signature_size, signature_length, Mock.psa_sign_hash_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_hash,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_hash,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_hash,CMockString_hash);
    if (cmock_call_instance->Expected_hash == NULL)
      { UNITY_TEST_ASSERT_NULL(hash, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_hash, hash, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_hash,CMockString_hash_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_hash_length), (void*)(&hash_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_hash,CMockString_signature);
    if (cmock_call_instance->Expected_signature == NULL)
      { UNITY_TEST_ASSERT_NULL(signature, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_signature, signature, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_hash,CMockString_signature_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_signature_size), (void*)(&signature_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_sign_hash,CMockString_signature_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_signature_length), (void*)(signature_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_sign_hash_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_sign_hash_CallbackFunctionPointer(key, alg, hash, hash_length, signature, signature_size, signature_length, Mock.psa_sign_hash_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_sign_hash(CMOCK_psa_sign_hash_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* hash, size_t hash_length, uint8_t* signature, size_t signature_size, size_t* signature_length);
void CMockExpectParameters_psa_sign_hash(CMOCK_psa_sign_hash_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* hash, size_t hash_length, uint8_t* signature, size_t signature_size, size_t* signature_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_hash = hash;
  memcpy((void*)(&cmock_call_instance->Expected_hash_length), (void*)(&hash_length),
         sizeof(size_t[sizeof(hash_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_signature = signature;
  memcpy((void*)(&cmock_call_instance->Expected_signature_size), (void*)(&signature_size),
         sizeof(size_t[sizeof(signature_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_signature_length = signature_length;
}

void psa_sign_hash_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_sign_hash_CALL_INSTANCE));
  CMOCK_psa_sign_hash_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_sign_hash_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_sign_hash_CallInstance = CMock_Guts_MemChain(Mock.psa_sign_hash_CallInstance, cmock_guts_index);
  Mock.psa_sign_hash_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_sign_hash_IgnoreBool = (char)1;
}

void psa_sign_hash_CMockStopIgnore(void)
{
  if(Mock.psa_sign_hash_IgnoreBool)
    Mock.psa_sign_hash_CallInstance = CMock_Guts_MemNext(Mock.psa_sign_hash_CallInstance);
  Mock.psa_sign_hash_IgnoreBool = (char)0;
}

void psa_sign_hash_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* hash, size_t hash_length, uint8_t* signature, size_t signature_size, size_t* signature_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_sign_hash_CALL_INSTANCE));
  CMOCK_psa_sign_hash_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_sign_hash_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_sign_hash_CallInstance = CMock_Guts_MemChain(Mock.psa_sign_hash_CallInstance, cmock_guts_index);
  Mock.psa_sign_hash_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_sign_hash(cmock_call_instance, key, alg, hash, hash_length, signature, signature_size, signature_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_sign_hash_AddCallback(CMOCK_psa_sign_hash_CALLBACK Callback)
{
  Mock.psa_sign_hash_IgnoreBool = (char)0;
  Mock.psa_sign_hash_CallbackBool = (char)1;
  Mock.psa_sign_hash_CallbackFunctionPointer = Callback;
}

void psa_sign_hash_Stub(CMOCK_psa_sign_hash_CALLBACK Callback)
{
  Mock.psa_sign_hash_IgnoreBool = (char)0;
  Mock.psa_sign_hash_CallbackBool = (char)0;
  Mock.psa_sign_hash_CallbackFunctionPointer = Callback;
}

psa_status_t psa_verify_hash(psa_key_id_t key, psa_algorithm_t alg, const uint8_t* hash, size_t hash_length, const uint8_t* signature, size_t signature_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_verify_hash_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_verify_hash);
  cmock_call_instance = (CMOCK_psa_verify_hash_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_verify_hash_CallInstance);
  Mock.psa_verify_hash_CallInstance = CMock_Guts_MemNext(Mock.psa_verify_hash_CallInstance);
  if (Mock.psa_verify_hash_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_verify_hash_FinalReturn;
    memcpy((void*)(&Mock.psa_verify_hash_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_verify_hash_CallbackBool &&
      Mock.psa_verify_hash_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_verify_hash_CallbackFunctionPointer(key, alg, hash, hash_length, signature, signature_length, Mock.psa_verify_hash_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_verify_hash,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_verify_hash,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_verify_hash,CMockString_hash);
    if (cmock_call_instance->Expected_hash == NULL)
      { UNITY_TEST_ASSERT_NULL(hash, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_hash, hash, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_verify_hash,CMockString_hash_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_hash_length), (void*)(&hash_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_verify_hash,CMockString_signature);
    if (cmock_call_instance->Expected_signature == NULL)
      { UNITY_TEST_ASSERT_NULL(signature, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_signature, signature, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_verify_hash,CMockString_signature_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_signature_length), (void*)(&signature_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_verify_hash_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_verify_hash_CallbackFunctionPointer(key, alg, hash, hash_length, signature, signature_length, Mock.psa_verify_hash_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_verify_hash(CMOCK_psa_verify_hash_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* hash, size_t hash_length, const uint8_t* signature, size_t signature_length);
void CMockExpectParameters_psa_verify_hash(CMOCK_psa_verify_hash_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* hash, size_t hash_length, const uint8_t* signature, size_t signature_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_hash = hash;
  memcpy((void*)(&cmock_call_instance->Expected_hash_length), (void*)(&hash_length),
         sizeof(size_t[sizeof(hash_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_signature = signature;
  memcpy((void*)(&cmock_call_instance->Expected_signature_length), (void*)(&signature_length),
         sizeof(size_t[sizeof(signature_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_verify_hash_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_verify_hash_CALL_INSTANCE));
  CMOCK_psa_verify_hash_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_verify_hash_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_verify_hash_CallInstance = CMock_Guts_MemChain(Mock.psa_verify_hash_CallInstance, cmock_guts_index);
  Mock.psa_verify_hash_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_verify_hash_IgnoreBool = (char)1;
}

void psa_verify_hash_CMockStopIgnore(void)
{
  if(Mock.psa_verify_hash_IgnoreBool)
    Mock.psa_verify_hash_CallInstance = CMock_Guts_MemNext(Mock.psa_verify_hash_CallInstance);
  Mock.psa_verify_hash_IgnoreBool = (char)0;
}

void psa_verify_hash_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* hash, size_t hash_length, const uint8_t* signature, size_t signature_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_verify_hash_CALL_INSTANCE));
  CMOCK_psa_verify_hash_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_verify_hash_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_verify_hash_CallInstance = CMock_Guts_MemChain(Mock.psa_verify_hash_CallInstance, cmock_guts_index);
  Mock.psa_verify_hash_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_verify_hash(cmock_call_instance, key, alg, hash, hash_length, signature, signature_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_verify_hash_AddCallback(CMOCK_psa_verify_hash_CALLBACK Callback)
{
  Mock.psa_verify_hash_IgnoreBool = (char)0;
  Mock.psa_verify_hash_CallbackBool = (char)1;
  Mock.psa_verify_hash_CallbackFunctionPointer = Callback;
}

void psa_verify_hash_Stub(CMOCK_psa_verify_hash_CALLBACK Callback)
{
  Mock.psa_verify_hash_IgnoreBool = (char)0;
  Mock.psa_verify_hash_CallbackBool = (char)0;
  Mock.psa_verify_hash_CallbackFunctionPointer = Callback;
}

psa_status_t psa_asymmetric_encrypt(psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* salt, size_t salt_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_asymmetric_encrypt_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_asymmetric_encrypt);
  cmock_call_instance = (CMOCK_psa_asymmetric_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_asymmetric_encrypt_CallInstance);
  Mock.psa_asymmetric_encrypt_CallInstance = CMock_Guts_MemNext(Mock.psa_asymmetric_encrypt_CallInstance);
  if (Mock.psa_asymmetric_encrypt_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_asymmetric_encrypt_FinalReturn;
    memcpy((void*)(&Mock.psa_asymmetric_encrypt_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_asymmetric_encrypt_CallbackBool &&
      Mock.psa_asymmetric_encrypt_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_asymmetric_encrypt_CallbackFunctionPointer(key, alg, input, input_length, salt, salt_length, output, output_size, output_length, Mock.psa_asymmetric_encrypt_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_encrypt,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_encrypt,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_encrypt,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_encrypt,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_encrypt,CMockString_salt);
    if (cmock_call_instance->Expected_salt == NULL)
      { UNITY_TEST_ASSERT_NULL(salt, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_salt, salt, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_encrypt,CMockString_salt_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_salt_length), (void*)(&salt_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_encrypt,CMockString_output);
    if (cmock_call_instance->Expected_output == NULL)
      { UNITY_TEST_ASSERT_NULL(output, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_output, output, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_encrypt,CMockString_output_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_encrypt,CMockString_output_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_output_length), (void*)(output_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_asymmetric_encrypt_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_asymmetric_encrypt_CallbackFunctionPointer(key, alg, input, input_length, salt, salt_length, output, output_size, output_length, Mock.psa_asymmetric_encrypt_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_asymmetric_encrypt(CMOCK_psa_asymmetric_encrypt_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* salt, size_t salt_length, uint8_t* output, size_t output_size, size_t* output_length);
void CMockExpectParameters_psa_asymmetric_encrypt(CMOCK_psa_asymmetric_encrypt_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* salt, size_t salt_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_salt = salt;
  memcpy((void*)(&cmock_call_instance->Expected_salt_length), (void*)(&salt_length),
         sizeof(size_t[sizeof(salt_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output = output;
  memcpy((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size),
         sizeof(size_t[sizeof(output_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output_length = output_length;
}

void psa_asymmetric_encrypt_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_asymmetric_encrypt_CALL_INSTANCE));
  CMOCK_psa_asymmetric_encrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_asymmetric_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_asymmetric_encrypt_CallInstance = CMock_Guts_MemChain(Mock.psa_asymmetric_encrypt_CallInstance, cmock_guts_index);
  Mock.psa_asymmetric_encrypt_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_asymmetric_encrypt_IgnoreBool = (char)1;
}

void psa_asymmetric_encrypt_CMockStopIgnore(void)
{
  if(Mock.psa_asymmetric_encrypt_IgnoreBool)
    Mock.psa_asymmetric_encrypt_CallInstance = CMock_Guts_MemNext(Mock.psa_asymmetric_encrypt_CallInstance);
  Mock.psa_asymmetric_encrypt_IgnoreBool = (char)0;
}

void psa_asymmetric_encrypt_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* salt, size_t salt_length, uint8_t* output, size_t output_size, size_t* output_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_asymmetric_encrypt_CALL_INSTANCE));
  CMOCK_psa_asymmetric_encrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_asymmetric_encrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_asymmetric_encrypt_CallInstance = CMock_Guts_MemChain(Mock.psa_asymmetric_encrypt_CallInstance, cmock_guts_index);
  Mock.psa_asymmetric_encrypt_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_asymmetric_encrypt(cmock_call_instance, key, alg, input, input_length, salt, salt_length, output, output_size, output_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_asymmetric_encrypt_AddCallback(CMOCK_psa_asymmetric_encrypt_CALLBACK Callback)
{
  Mock.psa_asymmetric_encrypt_IgnoreBool = (char)0;
  Mock.psa_asymmetric_encrypt_CallbackBool = (char)1;
  Mock.psa_asymmetric_encrypt_CallbackFunctionPointer = Callback;
}

void psa_asymmetric_encrypt_Stub(CMOCK_psa_asymmetric_encrypt_CALLBACK Callback)
{
  Mock.psa_asymmetric_encrypt_IgnoreBool = (char)0;
  Mock.psa_asymmetric_encrypt_CallbackBool = (char)0;
  Mock.psa_asymmetric_encrypt_CallbackFunctionPointer = Callback;
}

psa_status_t psa_asymmetric_decrypt(psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* salt, size_t salt_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_asymmetric_decrypt_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_asymmetric_decrypt);
  cmock_call_instance = (CMOCK_psa_asymmetric_decrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_asymmetric_decrypt_CallInstance);
  Mock.psa_asymmetric_decrypt_CallInstance = CMock_Guts_MemNext(Mock.psa_asymmetric_decrypt_CallInstance);
  if (Mock.psa_asymmetric_decrypt_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_asymmetric_decrypt_FinalReturn;
    memcpy((void*)(&Mock.psa_asymmetric_decrypt_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_asymmetric_decrypt_CallbackBool &&
      Mock.psa_asymmetric_decrypt_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_asymmetric_decrypt_CallbackFunctionPointer(key, alg, input, input_length, salt, salt_length, output, output_size, output_length, Mock.psa_asymmetric_decrypt_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_decrypt,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_decrypt,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_decrypt,CMockString_input);
    if (cmock_call_instance->Expected_input == NULL)
      { UNITY_TEST_ASSERT_NULL(input, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_input, input, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_decrypt,CMockString_input_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_decrypt,CMockString_salt);
    if (cmock_call_instance->Expected_salt == NULL)
      { UNITY_TEST_ASSERT_NULL(salt, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_salt, salt, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_decrypt,CMockString_salt_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_salt_length), (void*)(&salt_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_decrypt,CMockString_output);
    if (cmock_call_instance->Expected_output == NULL)
      { UNITY_TEST_ASSERT_NULL(output, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_output, output, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_decrypt,CMockString_output_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_asymmetric_decrypt,CMockString_output_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_output_length), (void*)(output_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_asymmetric_decrypt_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_asymmetric_decrypt_CallbackFunctionPointer(key, alg, input, input_length, salt, salt_length, output, output_size, output_length, Mock.psa_asymmetric_decrypt_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_asymmetric_decrypt(CMOCK_psa_asymmetric_decrypt_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* salt, size_t salt_length, uint8_t* output, size_t output_size, size_t* output_length);
void CMockExpectParameters_psa_asymmetric_decrypt(CMOCK_psa_asymmetric_decrypt_CALL_INSTANCE* cmock_call_instance, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* salt, size_t salt_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_input = input;
  memcpy((void*)(&cmock_call_instance->Expected_input_length), (void*)(&input_length),
         sizeof(size_t[sizeof(input_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_salt = salt;
  memcpy((void*)(&cmock_call_instance->Expected_salt_length), (void*)(&salt_length),
         sizeof(size_t[sizeof(salt_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output = output;
  memcpy((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size),
         sizeof(size_t[sizeof(output_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output_length = output_length;
}

void psa_asymmetric_decrypt_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_asymmetric_decrypt_CALL_INSTANCE));
  CMOCK_psa_asymmetric_decrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_asymmetric_decrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_asymmetric_decrypt_CallInstance = CMock_Guts_MemChain(Mock.psa_asymmetric_decrypt_CallInstance, cmock_guts_index);
  Mock.psa_asymmetric_decrypt_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_asymmetric_decrypt_IgnoreBool = (char)1;
}

void psa_asymmetric_decrypt_CMockStopIgnore(void)
{
  if(Mock.psa_asymmetric_decrypt_IgnoreBool)
    Mock.psa_asymmetric_decrypt_CallInstance = CMock_Guts_MemNext(Mock.psa_asymmetric_decrypt_CallInstance);
  Mock.psa_asymmetric_decrypt_IgnoreBool = (char)0;
}

void psa_asymmetric_decrypt_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_id_t key, psa_algorithm_t alg, const uint8_t* input, size_t input_length, const uint8_t* salt, size_t salt_length, uint8_t* output, size_t output_size, size_t* output_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_asymmetric_decrypt_CALL_INSTANCE));
  CMOCK_psa_asymmetric_decrypt_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_asymmetric_decrypt_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_asymmetric_decrypt_CallInstance = CMock_Guts_MemChain(Mock.psa_asymmetric_decrypt_CallInstance, cmock_guts_index);
  Mock.psa_asymmetric_decrypt_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_asymmetric_decrypt(cmock_call_instance, key, alg, input, input_length, salt, salt_length, output, output_size, output_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_asymmetric_decrypt_AddCallback(CMOCK_psa_asymmetric_decrypt_CALLBACK Callback)
{
  Mock.psa_asymmetric_decrypt_IgnoreBool = (char)0;
  Mock.psa_asymmetric_decrypt_CallbackBool = (char)1;
  Mock.psa_asymmetric_decrypt_CallbackFunctionPointer = Callback;
}

void psa_asymmetric_decrypt_Stub(CMOCK_psa_asymmetric_decrypt_CALLBACK Callback)
{
  Mock.psa_asymmetric_decrypt_IgnoreBool = (char)0;
  Mock.psa_asymmetric_decrypt_CallbackBool = (char)0;
  Mock.psa_asymmetric_decrypt_CallbackFunctionPointer = Callback;
}

psa_key_derivation_operation_t psa_key_derivation_operation_init(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_operation_init_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_operation_init);
  cmock_call_instance = (CMOCK_psa_key_derivation_operation_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_operation_init_CallInstance);
  Mock.psa_key_derivation_operation_init_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_operation_init_CallInstance);
  if (Mock.psa_key_derivation_operation_init_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_key_derivation_operation_init_FinalReturn;
    memcpy((void*)(&Mock.psa_key_derivation_operation_init_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_key_derivation_operation_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_key_derivation_operation_t) ? 1 : -1])); /* add psa_key_derivation_operation_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_key_derivation_operation_init_CallbackBool &&
      Mock.psa_key_derivation_operation_init_CallbackFunctionPointer != NULL)
  {
    psa_key_derivation_operation_t cmock_cb_ret = Mock.psa_key_derivation_operation_init_CallbackFunctionPointer(Mock.psa_key_derivation_operation_init_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.psa_key_derivation_operation_init_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_key_derivation_operation_init_CallbackFunctionPointer(Mock.psa_key_derivation_operation_init_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void psa_key_derivation_operation_init_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_derivation_operation_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_operation_init_CALL_INSTANCE));
  CMOCK_psa_key_derivation_operation_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_operation_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_operation_init_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_operation_init_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_operation_init_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_key_derivation_operation_init_IgnoreBool = (char)1;
}

void psa_key_derivation_operation_init_CMockStopIgnore(void)
{
  if(Mock.psa_key_derivation_operation_init_IgnoreBool)
    Mock.psa_key_derivation_operation_init_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_operation_init_CallInstance);
  Mock.psa_key_derivation_operation_init_IgnoreBool = (char)0;
}

void psa_key_derivation_operation_init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_derivation_operation_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_operation_init_CALL_INSTANCE));
  CMOCK_psa_key_derivation_operation_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_operation_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_operation_init_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_operation_init_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_operation_init_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_key_derivation_operation_t[sizeof(cmock_to_return) == sizeof(psa_key_derivation_operation_t) ? 1 : -1])); /* add psa_key_derivation_operation_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_operation_init_AddCallback(CMOCK_psa_key_derivation_operation_init_CALLBACK Callback)
{
  Mock.psa_key_derivation_operation_init_IgnoreBool = (char)0;
  Mock.psa_key_derivation_operation_init_CallbackBool = (char)1;
  Mock.psa_key_derivation_operation_init_CallbackFunctionPointer = Callback;
}

void psa_key_derivation_operation_init_Stub(CMOCK_psa_key_derivation_operation_init_CALLBACK Callback)
{
  Mock.psa_key_derivation_operation_init_IgnoreBool = (char)0;
  Mock.psa_key_derivation_operation_init_CallbackBool = (char)0;
  Mock.psa_key_derivation_operation_init_CallbackFunctionPointer = Callback;
}

psa_status_t psa_key_derivation_setup(psa_key_derivation_operation_t* operation, psa_algorithm_t alg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_setup_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_setup);
  cmock_call_instance = (CMOCK_psa_key_derivation_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_setup_CallInstance);
  Mock.psa_key_derivation_setup_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_setup_CallInstance);
  if (Mock.psa_key_derivation_setup_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_key_derivation_setup_FinalReturn;
    memcpy((void*)(&Mock.psa_key_derivation_setup_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_key_derivation_setup_CallbackBool &&
      Mock.psa_key_derivation_setup_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_key_derivation_setup_CallbackFunctionPointer(operation, alg, Mock.psa_key_derivation_setup_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_setup,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_key_derivation_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_setup,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_key_derivation_setup_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_key_derivation_setup_CallbackFunctionPointer(operation, alg, Mock.psa_key_derivation_setup_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_key_derivation_setup(CMOCK_psa_key_derivation_setup_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, psa_algorithm_t alg);
void CMockExpectParameters_psa_key_derivation_setup(CMOCK_psa_key_derivation_setup_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, psa_algorithm_t alg)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_setup_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_setup_CALL_INSTANCE));
  CMOCK_psa_key_derivation_setup_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_setup_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_setup_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_setup_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_key_derivation_setup_IgnoreBool = (char)1;
}

void psa_key_derivation_setup_CMockStopIgnore(void)
{
  if(Mock.psa_key_derivation_setup_IgnoreBool)
    Mock.psa_key_derivation_setup_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_setup_CallInstance);
  Mock.psa_key_derivation_setup_IgnoreBool = (char)0;
}

void psa_key_derivation_setup_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_derivation_operation_t* operation, psa_algorithm_t alg, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_setup_CALL_INSTANCE));
  CMOCK_psa_key_derivation_setup_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_setup_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_setup_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_setup_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_setup_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_key_derivation_setup(cmock_call_instance, operation, alg);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_setup_AddCallback(CMOCK_psa_key_derivation_setup_CALLBACK Callback)
{
  Mock.psa_key_derivation_setup_IgnoreBool = (char)0;
  Mock.psa_key_derivation_setup_CallbackBool = (char)1;
  Mock.psa_key_derivation_setup_CallbackFunctionPointer = Callback;
}

void psa_key_derivation_setup_Stub(CMOCK_psa_key_derivation_setup_CALLBACK Callback)
{
  Mock.psa_key_derivation_setup_IgnoreBool = (char)0;
  Mock.psa_key_derivation_setup_CallbackBool = (char)0;
  Mock.psa_key_derivation_setup_CallbackFunctionPointer = Callback;
}

psa_status_t psa_key_derivation_get_capacity(const psa_key_derivation_operation_t* operation, size_t* capacity)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_get_capacity_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_get_capacity);
  cmock_call_instance = (CMOCK_psa_key_derivation_get_capacity_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_get_capacity_CallInstance);
  Mock.psa_key_derivation_get_capacity_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_get_capacity_CallInstance);
  if (Mock.psa_key_derivation_get_capacity_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_key_derivation_get_capacity_FinalReturn;
    memcpy((void*)(&Mock.psa_key_derivation_get_capacity_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_key_derivation_get_capacity_CallbackBool &&
      Mock.psa_key_derivation_get_capacity_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_key_derivation_get_capacity_CallbackFunctionPointer(operation, capacity, Mock.psa_key_derivation_get_capacity_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_get_capacity,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(const psa_key_derivation_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_get_capacity,CMockString_capacity);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_capacity), (void*)(capacity), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_key_derivation_get_capacity_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_key_derivation_get_capacity_CallbackFunctionPointer(operation, capacity, Mock.psa_key_derivation_get_capacity_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_key_derivation_get_capacity(CMOCK_psa_key_derivation_get_capacity_CALL_INSTANCE* cmock_call_instance, const psa_key_derivation_operation_t* operation, size_t* capacity);
void CMockExpectParameters_psa_key_derivation_get_capacity(CMOCK_psa_key_derivation_get_capacity_CALL_INSTANCE* cmock_call_instance, const psa_key_derivation_operation_t* operation, size_t* capacity)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_capacity = capacity;
}

void psa_key_derivation_get_capacity_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_get_capacity_CALL_INSTANCE));
  CMOCK_psa_key_derivation_get_capacity_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_get_capacity_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_get_capacity_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_get_capacity_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_get_capacity_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_key_derivation_get_capacity_IgnoreBool = (char)1;
}

void psa_key_derivation_get_capacity_CMockStopIgnore(void)
{
  if(Mock.psa_key_derivation_get_capacity_IgnoreBool)
    Mock.psa_key_derivation_get_capacity_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_get_capacity_CallInstance);
  Mock.psa_key_derivation_get_capacity_IgnoreBool = (char)0;
}

void psa_key_derivation_get_capacity_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const psa_key_derivation_operation_t* operation, size_t* capacity, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_get_capacity_CALL_INSTANCE));
  CMOCK_psa_key_derivation_get_capacity_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_get_capacity_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_get_capacity_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_get_capacity_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_get_capacity_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_key_derivation_get_capacity(cmock_call_instance, operation, capacity);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_get_capacity_AddCallback(CMOCK_psa_key_derivation_get_capacity_CALLBACK Callback)
{
  Mock.psa_key_derivation_get_capacity_IgnoreBool = (char)0;
  Mock.psa_key_derivation_get_capacity_CallbackBool = (char)1;
  Mock.psa_key_derivation_get_capacity_CallbackFunctionPointer = Callback;
}

void psa_key_derivation_get_capacity_Stub(CMOCK_psa_key_derivation_get_capacity_CALLBACK Callback)
{
  Mock.psa_key_derivation_get_capacity_IgnoreBool = (char)0;
  Mock.psa_key_derivation_get_capacity_CallbackBool = (char)0;
  Mock.psa_key_derivation_get_capacity_CallbackFunctionPointer = Callback;
}

psa_status_t psa_key_derivation_set_capacity(psa_key_derivation_operation_t* operation, size_t capacity)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_set_capacity_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_set_capacity);
  cmock_call_instance = (CMOCK_psa_key_derivation_set_capacity_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_set_capacity_CallInstance);
  Mock.psa_key_derivation_set_capacity_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_set_capacity_CallInstance);
  if (Mock.psa_key_derivation_set_capacity_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_key_derivation_set_capacity_FinalReturn;
    memcpy((void*)(&Mock.psa_key_derivation_set_capacity_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_key_derivation_set_capacity_CallbackBool &&
      Mock.psa_key_derivation_set_capacity_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_key_derivation_set_capacity_CallbackFunctionPointer(operation, capacity, Mock.psa_key_derivation_set_capacity_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_set_capacity,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_key_derivation_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_set_capacity,CMockString_capacity);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_capacity), (void*)(&capacity), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_key_derivation_set_capacity_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_key_derivation_set_capacity_CallbackFunctionPointer(operation, capacity, Mock.psa_key_derivation_set_capacity_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_key_derivation_set_capacity(CMOCK_psa_key_derivation_set_capacity_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, size_t capacity);
void CMockExpectParameters_psa_key_derivation_set_capacity(CMOCK_psa_key_derivation_set_capacity_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, size_t capacity)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_capacity), (void*)(&capacity),
         sizeof(size_t[sizeof(capacity) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_set_capacity_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_set_capacity_CALL_INSTANCE));
  CMOCK_psa_key_derivation_set_capacity_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_set_capacity_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_set_capacity_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_set_capacity_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_set_capacity_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_key_derivation_set_capacity_IgnoreBool = (char)1;
}

void psa_key_derivation_set_capacity_CMockStopIgnore(void)
{
  if(Mock.psa_key_derivation_set_capacity_IgnoreBool)
    Mock.psa_key_derivation_set_capacity_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_set_capacity_CallInstance);
  Mock.psa_key_derivation_set_capacity_IgnoreBool = (char)0;
}

void psa_key_derivation_set_capacity_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_derivation_operation_t* operation, size_t capacity, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_set_capacity_CALL_INSTANCE));
  CMOCK_psa_key_derivation_set_capacity_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_set_capacity_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_set_capacity_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_set_capacity_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_set_capacity_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_key_derivation_set_capacity(cmock_call_instance, operation, capacity);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_set_capacity_AddCallback(CMOCK_psa_key_derivation_set_capacity_CALLBACK Callback)
{
  Mock.psa_key_derivation_set_capacity_IgnoreBool = (char)0;
  Mock.psa_key_derivation_set_capacity_CallbackBool = (char)1;
  Mock.psa_key_derivation_set_capacity_CallbackFunctionPointer = Callback;
}

void psa_key_derivation_set_capacity_Stub(CMOCK_psa_key_derivation_set_capacity_CALLBACK Callback)
{
  Mock.psa_key_derivation_set_capacity_IgnoreBool = (char)0;
  Mock.psa_key_derivation_set_capacity_CallbackBool = (char)0;
  Mock.psa_key_derivation_set_capacity_CallbackFunctionPointer = Callback;
}

psa_status_t psa_key_derivation_input_bytes(psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, const uint8_t* data, size_t data_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_input_bytes_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_input_bytes);
  cmock_call_instance = (CMOCK_psa_key_derivation_input_bytes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_input_bytes_CallInstance);
  Mock.psa_key_derivation_input_bytes_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_input_bytes_CallInstance);
  if (Mock.psa_key_derivation_input_bytes_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_key_derivation_input_bytes_FinalReturn;
    memcpy((void*)(&Mock.psa_key_derivation_input_bytes_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_key_derivation_input_bytes_CallbackBool &&
      Mock.psa_key_derivation_input_bytes_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_key_derivation_input_bytes_CallbackFunctionPointer(operation, step, data, data_length, Mock.psa_key_derivation_input_bytes_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_input_bytes,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_key_derivation_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_input_bytes,CMockString_step);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_step), (void*)(&step), sizeof(psa_key_derivation_step_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_input_bytes,CMockString_data);
    if (cmock_call_instance->Expected_data == NULL)
      { UNITY_TEST_ASSERT_NULL(data, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_data, data, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_input_bytes,CMockString_data_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_data_length), (void*)(&data_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_key_derivation_input_bytes_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_key_derivation_input_bytes_CallbackFunctionPointer(operation, step, data, data_length, Mock.psa_key_derivation_input_bytes_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_key_derivation_input_bytes(CMOCK_psa_key_derivation_input_bytes_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, const uint8_t* data, size_t data_length);
void CMockExpectParameters_psa_key_derivation_input_bytes(CMOCK_psa_key_derivation_input_bytes_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, const uint8_t* data, size_t data_length)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_step), (void*)(&step),
         sizeof(psa_key_derivation_step_t[sizeof(step) == sizeof(psa_key_derivation_step_t) ? 1 : -1])); /* add psa_key_derivation_step_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_data = data;
  memcpy((void*)(&cmock_call_instance->Expected_data_length), (void*)(&data_length),
         sizeof(size_t[sizeof(data_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_input_bytes_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_input_bytes_CALL_INSTANCE));
  CMOCK_psa_key_derivation_input_bytes_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_input_bytes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_input_bytes_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_input_bytes_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_input_bytes_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_key_derivation_input_bytes_IgnoreBool = (char)1;
}

void psa_key_derivation_input_bytes_CMockStopIgnore(void)
{
  if(Mock.psa_key_derivation_input_bytes_IgnoreBool)
    Mock.psa_key_derivation_input_bytes_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_input_bytes_CallInstance);
  Mock.psa_key_derivation_input_bytes_IgnoreBool = (char)0;
}

void psa_key_derivation_input_bytes_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, const uint8_t* data, size_t data_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_input_bytes_CALL_INSTANCE));
  CMOCK_psa_key_derivation_input_bytes_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_input_bytes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_input_bytes_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_input_bytes_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_input_bytes_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_key_derivation_input_bytes(cmock_call_instance, operation, step, data, data_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_input_bytes_AddCallback(CMOCK_psa_key_derivation_input_bytes_CALLBACK Callback)
{
  Mock.psa_key_derivation_input_bytes_IgnoreBool = (char)0;
  Mock.psa_key_derivation_input_bytes_CallbackBool = (char)1;
  Mock.psa_key_derivation_input_bytes_CallbackFunctionPointer = Callback;
}

void psa_key_derivation_input_bytes_Stub(CMOCK_psa_key_derivation_input_bytes_CALLBACK Callback)
{
  Mock.psa_key_derivation_input_bytes_IgnoreBool = (char)0;
  Mock.psa_key_derivation_input_bytes_CallbackBool = (char)0;
  Mock.psa_key_derivation_input_bytes_CallbackFunctionPointer = Callback;
}

psa_status_t psa_key_derivation_input_integer(psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, uint64_t value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_input_integer_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_input_integer);
  cmock_call_instance = (CMOCK_psa_key_derivation_input_integer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_input_integer_CallInstance);
  Mock.psa_key_derivation_input_integer_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_input_integer_CallInstance);
  if (Mock.psa_key_derivation_input_integer_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_key_derivation_input_integer_FinalReturn;
    memcpy((void*)(&Mock.psa_key_derivation_input_integer_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_key_derivation_input_integer_CallbackBool &&
      Mock.psa_key_derivation_input_integer_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_key_derivation_input_integer_CallbackFunctionPointer(operation, step, value, Mock.psa_key_derivation_input_integer_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_input_integer,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_key_derivation_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_input_integer,CMockString_step);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_step), (void*)(&step), sizeof(psa_key_derivation_step_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_input_integer,CMockString_value);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_value), (void*)(&value), sizeof(uint64_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_key_derivation_input_integer_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_key_derivation_input_integer_CallbackFunctionPointer(operation, step, value, Mock.psa_key_derivation_input_integer_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_key_derivation_input_integer(CMOCK_psa_key_derivation_input_integer_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, uint64_t value);
void CMockExpectParameters_psa_key_derivation_input_integer(CMOCK_psa_key_derivation_input_integer_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, uint64_t value)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_step), (void*)(&step),
         sizeof(psa_key_derivation_step_t[sizeof(step) == sizeof(psa_key_derivation_step_t) ? 1 : -1])); /* add psa_key_derivation_step_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_value), (void*)(&value),
         sizeof(uint64_t[sizeof(value) == sizeof(uint64_t) ? 1 : -1])); /* add uint64_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_input_integer_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_input_integer_CALL_INSTANCE));
  CMOCK_psa_key_derivation_input_integer_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_input_integer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_input_integer_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_input_integer_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_input_integer_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_key_derivation_input_integer_IgnoreBool = (char)1;
}

void psa_key_derivation_input_integer_CMockStopIgnore(void)
{
  if(Mock.psa_key_derivation_input_integer_IgnoreBool)
    Mock.psa_key_derivation_input_integer_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_input_integer_CallInstance);
  Mock.psa_key_derivation_input_integer_IgnoreBool = (char)0;
}

void psa_key_derivation_input_integer_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, uint64_t value, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_input_integer_CALL_INSTANCE));
  CMOCK_psa_key_derivation_input_integer_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_input_integer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_input_integer_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_input_integer_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_input_integer_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_key_derivation_input_integer(cmock_call_instance, operation, step, value);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_input_integer_AddCallback(CMOCK_psa_key_derivation_input_integer_CALLBACK Callback)
{
  Mock.psa_key_derivation_input_integer_IgnoreBool = (char)0;
  Mock.psa_key_derivation_input_integer_CallbackBool = (char)1;
  Mock.psa_key_derivation_input_integer_CallbackFunctionPointer = Callback;
}

void psa_key_derivation_input_integer_Stub(CMOCK_psa_key_derivation_input_integer_CALLBACK Callback)
{
  Mock.psa_key_derivation_input_integer_IgnoreBool = (char)0;
  Mock.psa_key_derivation_input_integer_CallbackBool = (char)0;
  Mock.psa_key_derivation_input_integer_CallbackFunctionPointer = Callback;
}

psa_status_t psa_key_derivation_input_key(psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, psa_key_id_t key)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_input_key_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_input_key);
  cmock_call_instance = (CMOCK_psa_key_derivation_input_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_input_key_CallInstance);
  Mock.psa_key_derivation_input_key_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_input_key_CallInstance);
  if (Mock.psa_key_derivation_input_key_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_key_derivation_input_key_FinalReturn;
    memcpy((void*)(&Mock.psa_key_derivation_input_key_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_key_derivation_input_key_CallbackBool &&
      Mock.psa_key_derivation_input_key_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_key_derivation_input_key_CallbackFunctionPointer(operation, step, key, Mock.psa_key_derivation_input_key_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_input_key,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_key_derivation_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_input_key,CMockString_step);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_step), (void*)(&step), sizeof(psa_key_derivation_step_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_input_key,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_key), (void*)(&key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_key_derivation_input_key_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_key_derivation_input_key_CallbackFunctionPointer(operation, step, key, Mock.psa_key_derivation_input_key_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_key_derivation_input_key(CMOCK_psa_key_derivation_input_key_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, psa_key_id_t key);
void CMockExpectParameters_psa_key_derivation_input_key(CMOCK_psa_key_derivation_input_key_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, psa_key_id_t key)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_step), (void*)(&step),
         sizeof(psa_key_derivation_step_t[sizeof(step) == sizeof(psa_key_derivation_step_t) ? 1 : -1])); /* add psa_key_derivation_step_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_key), (void*)(&key),
         sizeof(psa_key_id_t[sizeof(key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_input_key_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_input_key_CALL_INSTANCE));
  CMOCK_psa_key_derivation_input_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_input_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_input_key_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_input_key_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_input_key_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_key_derivation_input_key_IgnoreBool = (char)1;
}

void psa_key_derivation_input_key_CMockStopIgnore(void)
{
  if(Mock.psa_key_derivation_input_key_IgnoreBool)
    Mock.psa_key_derivation_input_key_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_input_key_CallInstance);
  Mock.psa_key_derivation_input_key_IgnoreBool = (char)0;
}

void psa_key_derivation_input_key_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, psa_key_id_t key, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_input_key_CALL_INSTANCE));
  CMOCK_psa_key_derivation_input_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_input_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_input_key_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_input_key_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_input_key_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_key_derivation_input_key(cmock_call_instance, operation, step, key);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_input_key_AddCallback(CMOCK_psa_key_derivation_input_key_CALLBACK Callback)
{
  Mock.psa_key_derivation_input_key_IgnoreBool = (char)0;
  Mock.psa_key_derivation_input_key_CallbackBool = (char)1;
  Mock.psa_key_derivation_input_key_CallbackFunctionPointer = Callback;
}

void psa_key_derivation_input_key_Stub(CMOCK_psa_key_derivation_input_key_CALLBACK Callback)
{
  Mock.psa_key_derivation_input_key_IgnoreBool = (char)0;
  Mock.psa_key_derivation_input_key_CallbackBool = (char)0;
  Mock.psa_key_derivation_input_key_CallbackFunctionPointer = Callback;
}

psa_status_t psa_key_derivation_key_agreement(psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, psa_key_id_t private_key, const uint8_t* peer_key, size_t peer_key_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_key_agreement_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_key_agreement);
  cmock_call_instance = (CMOCK_psa_key_derivation_key_agreement_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_key_agreement_CallInstance);
  Mock.psa_key_derivation_key_agreement_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_key_agreement_CallInstance);
  if (Mock.psa_key_derivation_key_agreement_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_key_derivation_key_agreement_FinalReturn;
    memcpy((void*)(&Mock.psa_key_derivation_key_agreement_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_key_derivation_key_agreement_CallbackBool &&
      Mock.psa_key_derivation_key_agreement_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_key_derivation_key_agreement_CallbackFunctionPointer(operation, step, private_key, peer_key, peer_key_length, Mock.psa_key_derivation_key_agreement_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_key_agreement,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_key_derivation_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_key_agreement,CMockString_step);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_step), (void*)(&step), sizeof(psa_key_derivation_step_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_key_agreement,CMockString_private_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_private_key), (void*)(&private_key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_key_agreement,CMockString_peer_key);
    if (cmock_call_instance->Expected_peer_key == NULL)
      { UNITY_TEST_ASSERT_NULL(peer_key, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_peer_key, peer_key, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_key_agreement,CMockString_peer_key_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_peer_key_length), (void*)(&peer_key_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_key_derivation_key_agreement_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_key_derivation_key_agreement_CallbackFunctionPointer(operation, step, private_key, peer_key, peer_key_length, Mock.psa_key_derivation_key_agreement_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_key_derivation_key_agreement(CMOCK_psa_key_derivation_key_agreement_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, psa_key_id_t private_key, const uint8_t* peer_key, size_t peer_key_length);
void CMockExpectParameters_psa_key_derivation_key_agreement(CMOCK_psa_key_derivation_key_agreement_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, psa_key_id_t private_key, const uint8_t* peer_key, size_t peer_key_length)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_step), (void*)(&step),
         sizeof(psa_key_derivation_step_t[sizeof(step) == sizeof(psa_key_derivation_step_t) ? 1 : -1])); /* add psa_key_derivation_step_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_private_key), (void*)(&private_key),
         sizeof(psa_key_id_t[sizeof(private_key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_peer_key = peer_key;
  memcpy((void*)(&cmock_call_instance->Expected_peer_key_length), (void*)(&peer_key_length),
         sizeof(size_t[sizeof(peer_key_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_key_agreement_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_key_agreement_CALL_INSTANCE));
  CMOCK_psa_key_derivation_key_agreement_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_key_agreement_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_key_agreement_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_key_agreement_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_key_agreement_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_key_derivation_key_agreement_IgnoreBool = (char)1;
}

void psa_key_derivation_key_agreement_CMockStopIgnore(void)
{
  if(Mock.psa_key_derivation_key_agreement_IgnoreBool)
    Mock.psa_key_derivation_key_agreement_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_key_agreement_CallInstance);
  Mock.psa_key_derivation_key_agreement_IgnoreBool = (char)0;
}

void psa_key_derivation_key_agreement_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_derivation_operation_t* operation, psa_key_derivation_step_t step, psa_key_id_t private_key, const uint8_t* peer_key, size_t peer_key_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_key_agreement_CALL_INSTANCE));
  CMOCK_psa_key_derivation_key_agreement_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_key_agreement_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_key_agreement_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_key_agreement_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_key_agreement_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_key_derivation_key_agreement(cmock_call_instance, operation, step, private_key, peer_key, peer_key_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_key_agreement_AddCallback(CMOCK_psa_key_derivation_key_agreement_CALLBACK Callback)
{
  Mock.psa_key_derivation_key_agreement_IgnoreBool = (char)0;
  Mock.psa_key_derivation_key_agreement_CallbackBool = (char)1;
  Mock.psa_key_derivation_key_agreement_CallbackFunctionPointer = Callback;
}

void psa_key_derivation_key_agreement_Stub(CMOCK_psa_key_derivation_key_agreement_CALLBACK Callback)
{
  Mock.psa_key_derivation_key_agreement_IgnoreBool = (char)0;
  Mock.psa_key_derivation_key_agreement_CallbackBool = (char)0;
  Mock.psa_key_derivation_key_agreement_CallbackFunctionPointer = Callback;
}

psa_status_t psa_key_derivation_output_bytes(psa_key_derivation_operation_t* operation, uint8_t* output, size_t output_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_output_bytes_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_output_bytes);
  cmock_call_instance = (CMOCK_psa_key_derivation_output_bytes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_output_bytes_CallInstance);
  Mock.psa_key_derivation_output_bytes_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_output_bytes_CallInstance);
  if (Mock.psa_key_derivation_output_bytes_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_key_derivation_output_bytes_FinalReturn;
    memcpy((void*)(&Mock.psa_key_derivation_output_bytes_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_key_derivation_output_bytes_CallbackBool &&
      Mock.psa_key_derivation_output_bytes_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_key_derivation_output_bytes_CallbackFunctionPointer(operation, output, output_length, Mock.psa_key_derivation_output_bytes_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_output_bytes,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_key_derivation_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_output_bytes,CMockString_output);
    if (cmock_call_instance->Expected_output == NULL)
      { UNITY_TEST_ASSERT_NULL(output, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_output, output, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_output_bytes,CMockString_output_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_output_length), (void*)(&output_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_key_derivation_output_bytes_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_key_derivation_output_bytes_CallbackFunctionPointer(operation, output, output_length, Mock.psa_key_derivation_output_bytes_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_key_derivation_output_bytes(CMOCK_psa_key_derivation_output_bytes_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, uint8_t* output, size_t output_length);
void CMockExpectParameters_psa_key_derivation_output_bytes(CMOCK_psa_key_derivation_output_bytes_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, uint8_t* output, size_t output_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_output = output;
  memcpy((void*)(&cmock_call_instance->Expected_output_length), (void*)(&output_length),
         sizeof(size_t[sizeof(output_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_output_bytes_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_output_bytes_CALL_INSTANCE));
  CMOCK_psa_key_derivation_output_bytes_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_output_bytes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_output_bytes_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_output_bytes_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_output_bytes_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_key_derivation_output_bytes_IgnoreBool = (char)1;
}

void psa_key_derivation_output_bytes_CMockStopIgnore(void)
{
  if(Mock.psa_key_derivation_output_bytes_IgnoreBool)
    Mock.psa_key_derivation_output_bytes_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_output_bytes_CallInstance);
  Mock.psa_key_derivation_output_bytes_IgnoreBool = (char)0;
}

void psa_key_derivation_output_bytes_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_derivation_operation_t* operation, uint8_t* output, size_t output_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_output_bytes_CALL_INSTANCE));
  CMOCK_psa_key_derivation_output_bytes_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_output_bytes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_output_bytes_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_output_bytes_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_output_bytes_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_key_derivation_output_bytes(cmock_call_instance, operation, output, output_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_output_bytes_AddCallback(CMOCK_psa_key_derivation_output_bytes_CALLBACK Callback)
{
  Mock.psa_key_derivation_output_bytes_IgnoreBool = (char)0;
  Mock.psa_key_derivation_output_bytes_CallbackBool = (char)1;
  Mock.psa_key_derivation_output_bytes_CallbackFunctionPointer = Callback;
}

void psa_key_derivation_output_bytes_Stub(CMOCK_psa_key_derivation_output_bytes_CALLBACK Callback)
{
  Mock.psa_key_derivation_output_bytes_IgnoreBool = (char)0;
  Mock.psa_key_derivation_output_bytes_CallbackBool = (char)0;
  Mock.psa_key_derivation_output_bytes_CallbackFunctionPointer = Callback;
}

psa_status_t psa_key_derivation_output_key(const psa_key_attributes_t* attributes, psa_key_derivation_operation_t* operation, psa_key_id_t* key)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_output_key_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_output_key);
  cmock_call_instance = (CMOCK_psa_key_derivation_output_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_output_key_CallInstance);
  Mock.psa_key_derivation_output_key_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_output_key_CallInstance);
  if (Mock.psa_key_derivation_output_key_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_key_derivation_output_key_FinalReturn;
    memcpy((void*)(&Mock.psa_key_derivation_output_key_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_key_derivation_output_key_CallbackBool &&
      Mock.psa_key_derivation_output_key_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_key_derivation_output_key_CallbackFunctionPointer(attributes, operation, key, Mock.psa_key_derivation_output_key_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_output_key,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(const psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_output_key,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_key_derivation_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_output_key,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_key), (void*)(key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_key_derivation_output_key_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_key_derivation_output_key_CallbackFunctionPointer(attributes, operation, key, Mock.psa_key_derivation_output_key_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_key_derivation_output_key(CMOCK_psa_key_derivation_output_key_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes, psa_key_derivation_operation_t* operation, psa_key_id_t* key);
void CMockExpectParameters_psa_key_derivation_output_key(CMOCK_psa_key_derivation_output_key_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes, psa_key_derivation_operation_t* operation, psa_key_id_t* key)
{
  cmock_call_instance->Expected_attributes = attributes;
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_key = key;
}

void psa_key_derivation_output_key_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_output_key_CALL_INSTANCE));
  CMOCK_psa_key_derivation_output_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_output_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_output_key_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_output_key_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_output_key_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_key_derivation_output_key_IgnoreBool = (char)1;
}

void psa_key_derivation_output_key_CMockStopIgnore(void)
{
  if(Mock.psa_key_derivation_output_key_IgnoreBool)
    Mock.psa_key_derivation_output_key_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_output_key_CallInstance);
  Mock.psa_key_derivation_output_key_IgnoreBool = (char)0;
}

void psa_key_derivation_output_key_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const psa_key_attributes_t* attributes, psa_key_derivation_operation_t* operation, psa_key_id_t* key, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_output_key_CALL_INSTANCE));
  CMOCK_psa_key_derivation_output_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_output_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_output_key_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_output_key_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_output_key_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_key_derivation_output_key(cmock_call_instance, attributes, operation, key);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_output_key_AddCallback(CMOCK_psa_key_derivation_output_key_CALLBACK Callback)
{
  Mock.psa_key_derivation_output_key_IgnoreBool = (char)0;
  Mock.psa_key_derivation_output_key_CallbackBool = (char)1;
  Mock.psa_key_derivation_output_key_CallbackFunctionPointer = Callback;
}

void psa_key_derivation_output_key_Stub(CMOCK_psa_key_derivation_output_key_CALLBACK Callback)
{
  Mock.psa_key_derivation_output_key_IgnoreBool = (char)0;
  Mock.psa_key_derivation_output_key_CallbackBool = (char)0;
  Mock.psa_key_derivation_output_key_CallbackFunctionPointer = Callback;
}

psa_status_t psa_key_derivation_verify_bytes(psa_key_derivation_operation_t* operation, const uint8_t* expected_output, size_t output_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_verify_bytes_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_verify_bytes);
  cmock_call_instance = (CMOCK_psa_key_derivation_verify_bytes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_verify_bytes_CallInstance);
  Mock.psa_key_derivation_verify_bytes_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_verify_bytes_CallInstance);
  if (Mock.psa_key_derivation_verify_bytes_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_key_derivation_verify_bytes_FinalReturn;
    memcpy((void*)(&Mock.psa_key_derivation_verify_bytes_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_key_derivation_verify_bytes_CallbackBool &&
      Mock.psa_key_derivation_verify_bytes_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_key_derivation_verify_bytes_CallbackFunctionPointer(operation, expected_output, output_length, Mock.psa_key_derivation_verify_bytes_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_verify_bytes,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_key_derivation_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_verify_bytes,CMockString_expected_output);
    if (cmock_call_instance->Expected_expected_output == NULL)
      { UNITY_TEST_ASSERT_NULL(expected_output, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_expected_output, expected_output, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_verify_bytes,CMockString_output_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_output_length), (void*)(&output_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_key_derivation_verify_bytes_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_key_derivation_verify_bytes_CallbackFunctionPointer(operation, expected_output, output_length, Mock.psa_key_derivation_verify_bytes_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_key_derivation_verify_bytes(CMOCK_psa_key_derivation_verify_bytes_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, const uint8_t* expected_output, size_t output_length);
void CMockExpectParameters_psa_key_derivation_verify_bytes(CMOCK_psa_key_derivation_verify_bytes_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, const uint8_t* expected_output, size_t output_length)
{
  cmock_call_instance->Expected_operation = operation;
  cmock_call_instance->Expected_expected_output = expected_output;
  memcpy((void*)(&cmock_call_instance->Expected_output_length), (void*)(&output_length),
         sizeof(size_t[sizeof(output_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_verify_bytes_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_verify_bytes_CALL_INSTANCE));
  CMOCK_psa_key_derivation_verify_bytes_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_verify_bytes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_verify_bytes_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_verify_bytes_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_verify_bytes_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_key_derivation_verify_bytes_IgnoreBool = (char)1;
}

void psa_key_derivation_verify_bytes_CMockStopIgnore(void)
{
  if(Mock.psa_key_derivation_verify_bytes_IgnoreBool)
    Mock.psa_key_derivation_verify_bytes_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_verify_bytes_CallInstance);
  Mock.psa_key_derivation_verify_bytes_IgnoreBool = (char)0;
}

void psa_key_derivation_verify_bytes_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_derivation_operation_t* operation, const uint8_t* expected_output, size_t output_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_verify_bytes_CALL_INSTANCE));
  CMOCK_psa_key_derivation_verify_bytes_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_verify_bytes_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_verify_bytes_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_verify_bytes_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_verify_bytes_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_key_derivation_verify_bytes(cmock_call_instance, operation, expected_output, output_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_verify_bytes_AddCallback(CMOCK_psa_key_derivation_verify_bytes_CALLBACK Callback)
{
  Mock.psa_key_derivation_verify_bytes_IgnoreBool = (char)0;
  Mock.psa_key_derivation_verify_bytes_CallbackBool = (char)1;
  Mock.psa_key_derivation_verify_bytes_CallbackFunctionPointer = Callback;
}

void psa_key_derivation_verify_bytes_Stub(CMOCK_psa_key_derivation_verify_bytes_CALLBACK Callback)
{
  Mock.psa_key_derivation_verify_bytes_IgnoreBool = (char)0;
  Mock.psa_key_derivation_verify_bytes_CallbackBool = (char)0;
  Mock.psa_key_derivation_verify_bytes_CallbackFunctionPointer = Callback;
}

psa_status_t psa_key_derivation_verify_key(psa_key_derivation_operation_t* operation, psa_key_id_t expected)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_verify_key_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_verify_key);
  cmock_call_instance = (CMOCK_psa_key_derivation_verify_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_verify_key_CallInstance);
  Mock.psa_key_derivation_verify_key_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_verify_key_CallInstance);
  if (Mock.psa_key_derivation_verify_key_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_key_derivation_verify_key_FinalReturn;
    memcpy((void*)(&Mock.psa_key_derivation_verify_key_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_key_derivation_verify_key_CallbackBool &&
      Mock.psa_key_derivation_verify_key_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_key_derivation_verify_key_CallbackFunctionPointer(operation, expected, Mock.psa_key_derivation_verify_key_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_verify_key,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_key_derivation_operation_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_verify_key,CMockString_expected);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_expected), (void*)(&expected), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_key_derivation_verify_key_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_key_derivation_verify_key_CallbackFunctionPointer(operation, expected, Mock.psa_key_derivation_verify_key_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_key_derivation_verify_key(CMOCK_psa_key_derivation_verify_key_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, psa_key_id_t expected);
void CMockExpectParameters_psa_key_derivation_verify_key(CMOCK_psa_key_derivation_verify_key_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation, psa_key_id_t expected)
{
  cmock_call_instance->Expected_operation = operation;
  memcpy((void*)(&cmock_call_instance->Expected_expected), (void*)(&expected),
         sizeof(psa_key_id_t[sizeof(expected) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_verify_key_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_verify_key_CALL_INSTANCE));
  CMOCK_psa_key_derivation_verify_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_verify_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_verify_key_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_verify_key_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_verify_key_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_key_derivation_verify_key_IgnoreBool = (char)1;
}

void psa_key_derivation_verify_key_CMockStopIgnore(void)
{
  if(Mock.psa_key_derivation_verify_key_IgnoreBool)
    Mock.psa_key_derivation_verify_key_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_verify_key_CallInstance);
  Mock.psa_key_derivation_verify_key_IgnoreBool = (char)0;
}

void psa_key_derivation_verify_key_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_derivation_operation_t* operation, psa_key_id_t expected, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_verify_key_CALL_INSTANCE));
  CMOCK_psa_key_derivation_verify_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_verify_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_verify_key_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_verify_key_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_verify_key_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_key_derivation_verify_key(cmock_call_instance, operation, expected);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_verify_key_AddCallback(CMOCK_psa_key_derivation_verify_key_CALLBACK Callback)
{
  Mock.psa_key_derivation_verify_key_IgnoreBool = (char)0;
  Mock.psa_key_derivation_verify_key_CallbackBool = (char)1;
  Mock.psa_key_derivation_verify_key_CallbackFunctionPointer = Callback;
}

void psa_key_derivation_verify_key_Stub(CMOCK_psa_key_derivation_verify_key_CALLBACK Callback)
{
  Mock.psa_key_derivation_verify_key_IgnoreBool = (char)0;
  Mock.psa_key_derivation_verify_key_CallbackBool = (char)0;
  Mock.psa_key_derivation_verify_key_CallbackFunctionPointer = Callback;
}

psa_status_t psa_key_derivation_abort(psa_key_derivation_operation_t* operation)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_key_derivation_abort_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_key_derivation_abort);
  cmock_call_instance = (CMOCK_psa_key_derivation_abort_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_key_derivation_abort_CallInstance);
  Mock.psa_key_derivation_abort_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_abort_CallInstance);
  if (Mock.psa_key_derivation_abort_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_key_derivation_abort_FinalReturn;
    memcpy((void*)(&Mock.psa_key_derivation_abort_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_key_derivation_abort_CallbackBool &&
      Mock.psa_key_derivation_abort_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_key_derivation_abort_CallbackFunctionPointer(operation, Mock.psa_key_derivation_abort_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_key_derivation_abort,CMockString_operation);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_operation), (void*)(operation), sizeof(psa_key_derivation_operation_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_key_derivation_abort_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_key_derivation_abort_CallbackFunctionPointer(operation, Mock.psa_key_derivation_abort_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_key_derivation_abort(CMOCK_psa_key_derivation_abort_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation);
void CMockExpectParameters_psa_key_derivation_abort(CMOCK_psa_key_derivation_abort_CALL_INSTANCE* cmock_call_instance, psa_key_derivation_operation_t* operation)
{
  cmock_call_instance->Expected_operation = operation;
}

void psa_key_derivation_abort_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_abort_CALL_INSTANCE));
  CMOCK_psa_key_derivation_abort_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_abort_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_abort_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_abort_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_abort_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_key_derivation_abort_IgnoreBool = (char)1;
}

void psa_key_derivation_abort_CMockStopIgnore(void)
{
  if(Mock.psa_key_derivation_abort_IgnoreBool)
    Mock.psa_key_derivation_abort_CallInstance = CMock_Guts_MemNext(Mock.psa_key_derivation_abort_CallInstance);
  Mock.psa_key_derivation_abort_IgnoreBool = (char)0;
}

void psa_key_derivation_abort_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_key_derivation_operation_t* operation, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_key_derivation_abort_CALL_INSTANCE));
  CMOCK_psa_key_derivation_abort_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_key_derivation_abort_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_key_derivation_abort_CallInstance = CMock_Guts_MemChain(Mock.psa_key_derivation_abort_CallInstance, cmock_guts_index);
  Mock.psa_key_derivation_abort_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_key_derivation_abort(cmock_call_instance, operation);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_key_derivation_abort_AddCallback(CMOCK_psa_key_derivation_abort_CALLBACK Callback)
{
  Mock.psa_key_derivation_abort_IgnoreBool = (char)0;
  Mock.psa_key_derivation_abort_CallbackBool = (char)1;
  Mock.psa_key_derivation_abort_CallbackFunctionPointer = Callback;
}

void psa_key_derivation_abort_Stub(CMOCK_psa_key_derivation_abort_CALLBACK Callback)
{
  Mock.psa_key_derivation_abort_IgnoreBool = (char)0;
  Mock.psa_key_derivation_abort_CallbackBool = (char)0;
  Mock.psa_key_derivation_abort_CallbackFunctionPointer = Callback;
}

psa_status_t psa_raw_key_agreement(psa_algorithm_t alg, psa_key_id_t private_key, const uint8_t* peer_key, size_t peer_key_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_raw_key_agreement_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_raw_key_agreement);
  cmock_call_instance = (CMOCK_psa_raw_key_agreement_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_raw_key_agreement_CallInstance);
  Mock.psa_raw_key_agreement_CallInstance = CMock_Guts_MemNext(Mock.psa_raw_key_agreement_CallInstance);
  if (Mock.psa_raw_key_agreement_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_raw_key_agreement_FinalReturn;
    memcpy((void*)(&Mock.psa_raw_key_agreement_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_raw_key_agreement_CallbackBool &&
      Mock.psa_raw_key_agreement_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_raw_key_agreement_CallbackFunctionPointer(alg, private_key, peer_key, peer_key_length, output, output_size, output_length, Mock.psa_raw_key_agreement_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_raw_key_agreement,CMockString_alg);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg), sizeof(psa_algorithm_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_raw_key_agreement,CMockString_private_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_private_key), (void*)(&private_key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_raw_key_agreement,CMockString_peer_key);
    if (cmock_call_instance->Expected_peer_key == NULL)
      { UNITY_TEST_ASSERT_NULL(peer_key, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_peer_key, peer_key, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_raw_key_agreement,CMockString_peer_key_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_peer_key_length), (void*)(&peer_key_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_raw_key_agreement,CMockString_output);
    if (cmock_call_instance->Expected_output == NULL)
      { UNITY_TEST_ASSERT_NULL(output, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_output, output, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_raw_key_agreement,CMockString_output_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_raw_key_agreement,CMockString_output_length);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_output_length), (void*)(output_length), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_raw_key_agreement_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_raw_key_agreement_CallbackFunctionPointer(alg, private_key, peer_key, peer_key_length, output, output_size, output_length, Mock.psa_raw_key_agreement_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_raw_key_agreement(CMOCK_psa_raw_key_agreement_CALL_INSTANCE* cmock_call_instance, psa_algorithm_t alg, psa_key_id_t private_key, const uint8_t* peer_key, size_t peer_key_length, uint8_t* output, size_t output_size, size_t* output_length);
void CMockExpectParameters_psa_raw_key_agreement(CMOCK_psa_raw_key_agreement_CALL_INSTANCE* cmock_call_instance, psa_algorithm_t alg, psa_key_id_t private_key, const uint8_t* peer_key, size_t peer_key_length, uint8_t* output, size_t output_size, size_t* output_length)
{
  memcpy((void*)(&cmock_call_instance->Expected_alg), (void*)(&alg),
         sizeof(psa_algorithm_t[sizeof(alg) == sizeof(psa_algorithm_t) ? 1 : -1])); /* add psa_algorithm_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_private_key), (void*)(&private_key),
         sizeof(psa_key_id_t[sizeof(private_key) == sizeof(psa_key_id_t) ? 1 : -1])); /* add psa_key_id_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_peer_key = peer_key;
  memcpy((void*)(&cmock_call_instance->Expected_peer_key_length), (void*)(&peer_key_length),
         sizeof(size_t[sizeof(peer_key_length) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output = output;
  memcpy((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size),
         sizeof(size_t[sizeof(output_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_output_length = output_length;
}

void psa_raw_key_agreement_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_raw_key_agreement_CALL_INSTANCE));
  CMOCK_psa_raw_key_agreement_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_raw_key_agreement_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_raw_key_agreement_CallInstance = CMock_Guts_MemChain(Mock.psa_raw_key_agreement_CallInstance, cmock_guts_index);
  Mock.psa_raw_key_agreement_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_raw_key_agreement_IgnoreBool = (char)1;
}

void psa_raw_key_agreement_CMockStopIgnore(void)
{
  if(Mock.psa_raw_key_agreement_IgnoreBool)
    Mock.psa_raw_key_agreement_CallInstance = CMock_Guts_MemNext(Mock.psa_raw_key_agreement_CallInstance);
  Mock.psa_raw_key_agreement_IgnoreBool = (char)0;
}

void psa_raw_key_agreement_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, psa_algorithm_t alg, psa_key_id_t private_key, const uint8_t* peer_key, size_t peer_key_length, uint8_t* output, size_t output_size, size_t* output_length, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_raw_key_agreement_CALL_INSTANCE));
  CMOCK_psa_raw_key_agreement_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_raw_key_agreement_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_raw_key_agreement_CallInstance = CMock_Guts_MemChain(Mock.psa_raw_key_agreement_CallInstance, cmock_guts_index);
  Mock.psa_raw_key_agreement_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_raw_key_agreement(cmock_call_instance, alg, private_key, peer_key, peer_key_length, output, output_size, output_length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_raw_key_agreement_AddCallback(CMOCK_psa_raw_key_agreement_CALLBACK Callback)
{
  Mock.psa_raw_key_agreement_IgnoreBool = (char)0;
  Mock.psa_raw_key_agreement_CallbackBool = (char)1;
  Mock.psa_raw_key_agreement_CallbackFunctionPointer = Callback;
}

void psa_raw_key_agreement_Stub(CMOCK_psa_raw_key_agreement_CALLBACK Callback)
{
  Mock.psa_raw_key_agreement_IgnoreBool = (char)0;
  Mock.psa_raw_key_agreement_CallbackBool = (char)0;
  Mock.psa_raw_key_agreement_CallbackFunctionPointer = Callback;
}

psa_status_t psa_generate_random(uint8_t* output, size_t output_size)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_generate_random_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_generate_random);
  cmock_call_instance = (CMOCK_psa_generate_random_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_generate_random_CallInstance);
  Mock.psa_generate_random_CallInstance = CMock_Guts_MemNext(Mock.psa_generate_random_CallInstance);
  if (Mock.psa_generate_random_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_generate_random_FinalReturn;
    memcpy((void*)(&Mock.psa_generate_random_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_generate_random_CallbackBool &&
      Mock.psa_generate_random_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_generate_random_CallbackFunctionPointer(output, output_size, Mock.psa_generate_random_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_generate_random,CMockString_output);
    if (cmock_call_instance->Expected_output == NULL)
      { UNITY_TEST_ASSERT_NULL(output, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_output, output, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_generate_random,CMockString_output_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_generate_random_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_generate_random_CallbackFunctionPointer(output, output_size, Mock.psa_generate_random_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_generate_random(CMOCK_psa_generate_random_CALL_INSTANCE* cmock_call_instance, uint8_t* output, size_t output_size);
void CMockExpectParameters_psa_generate_random(CMOCK_psa_generate_random_CALL_INSTANCE* cmock_call_instance, uint8_t* output, size_t output_size)
{
  cmock_call_instance->Expected_output = output;
  memcpy((void*)(&cmock_call_instance->Expected_output_size), (void*)(&output_size),
         sizeof(size_t[sizeof(output_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void psa_generate_random_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_generate_random_CALL_INSTANCE));
  CMOCK_psa_generate_random_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_generate_random_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_generate_random_CallInstance = CMock_Guts_MemChain(Mock.psa_generate_random_CallInstance, cmock_guts_index);
  Mock.psa_generate_random_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_generate_random_IgnoreBool = (char)1;
}

void psa_generate_random_CMockStopIgnore(void)
{
  if(Mock.psa_generate_random_IgnoreBool)
    Mock.psa_generate_random_CallInstance = CMock_Guts_MemNext(Mock.psa_generate_random_CallInstance);
  Mock.psa_generate_random_IgnoreBool = (char)0;
}

void psa_generate_random_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* output, size_t output_size, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_generate_random_CALL_INSTANCE));
  CMOCK_psa_generate_random_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_generate_random_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_generate_random_CallInstance = CMock_Guts_MemChain(Mock.psa_generate_random_CallInstance, cmock_guts_index);
  Mock.psa_generate_random_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_generate_random(cmock_call_instance, output, output_size);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_generate_random_AddCallback(CMOCK_psa_generate_random_CALLBACK Callback)
{
  Mock.psa_generate_random_IgnoreBool = (char)0;
  Mock.psa_generate_random_CallbackBool = (char)1;
  Mock.psa_generate_random_CallbackFunctionPointer = Callback;
}

void psa_generate_random_Stub(CMOCK_psa_generate_random_CALLBACK Callback)
{
  Mock.psa_generate_random_IgnoreBool = (char)0;
  Mock.psa_generate_random_CallbackBool = (char)0;
  Mock.psa_generate_random_CallbackFunctionPointer = Callback;
}

psa_status_t psa_generate_key(const psa_key_attributes_t* attributes, psa_key_id_t* key)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_psa_generate_key_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_psa_generate_key);
  cmock_call_instance = (CMOCK_psa_generate_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.psa_generate_key_CallInstance);
  Mock.psa_generate_key_CallInstance = CMock_Guts_MemNext(Mock.psa_generate_key_CallInstance);
  if (Mock.psa_generate_key_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.psa_generate_key_FinalReturn;
    memcpy((void*)(&Mock.psa_generate_key_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(psa_status_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.psa_generate_key_CallbackBool &&
      Mock.psa_generate_key_CallbackFunctionPointer != NULL)
  {
    psa_status_t cmock_cb_ret = Mock.psa_generate_key_CallbackFunctionPointer(attributes, key, Mock.psa_generate_key_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_psa_generate_key,CMockString_attributes);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_attributes), (void*)(attributes), sizeof(const psa_key_attributes_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_psa_generate_key,CMockString_key);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_key), (void*)(key), sizeof(psa_key_id_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.psa_generate_key_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.psa_generate_key_CallbackFunctionPointer(attributes, key, Mock.psa_generate_key_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_psa_generate_key(CMOCK_psa_generate_key_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes, psa_key_id_t* key);
void CMockExpectParameters_psa_generate_key(CMOCK_psa_generate_key_CALL_INSTANCE* cmock_call_instance, const psa_key_attributes_t* attributes, psa_key_id_t* key)
{
  cmock_call_instance->Expected_attributes = attributes;
  cmock_call_instance->Expected_key = key;
}

void psa_generate_key_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_generate_key_CALL_INSTANCE));
  CMOCK_psa_generate_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_generate_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_generate_key_CallInstance = CMock_Guts_MemChain(Mock.psa_generate_key_CallInstance, cmock_guts_index);
  Mock.psa_generate_key_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.psa_generate_key_IgnoreBool = (char)1;
}

void psa_generate_key_CMockStopIgnore(void)
{
  if(Mock.psa_generate_key_IgnoreBool)
    Mock.psa_generate_key_CallInstance = CMock_Guts_MemNext(Mock.psa_generate_key_CallInstance);
  Mock.psa_generate_key_IgnoreBool = (char)0;
}

void psa_generate_key_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const psa_key_attributes_t* attributes, psa_key_id_t* key, psa_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_psa_generate_key_CALL_INSTANCE));
  CMOCK_psa_generate_key_CALL_INSTANCE* cmock_call_instance = (CMOCK_psa_generate_key_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.psa_generate_key_CallInstance = CMock_Guts_MemChain(Mock.psa_generate_key_CallInstance, cmock_guts_index);
  Mock.psa_generate_key_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_psa_generate_key(cmock_call_instance, attributes, key);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(psa_status_t[sizeof(cmock_to_return) == sizeof(psa_status_t) ? 1 : -1])); /* add psa_status_t to :treat_as_array if this causes an error */
}

void psa_generate_key_AddCallback(CMOCK_psa_generate_key_CALLBACK Callback)
{
  Mock.psa_generate_key_IgnoreBool = (char)0;
  Mock.psa_generate_key_CallbackBool = (char)1;
  Mock.psa_generate_key_CallbackFunctionPointer = Callback;
}

void psa_generate_key_Stub(CMOCK_psa_generate_key_CALLBACK Callback)
{
  Mock.psa_generate_key_IgnoreBool = (char)0;
  Mock.psa_generate_key_CallbackBool = (char)0;
  Mock.psa_generate_key_CallbackFunctionPointer = Callback;
}

